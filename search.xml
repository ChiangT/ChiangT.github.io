<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面试汇总</title>
      <link href="/2023/04/03/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
      <url>/2023/04/03/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h2 id="Java-Base"><a href="#Java-Base" class="headerlink" title="Java Base"></a>Java Base</h2><h3 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，多用于实现多态</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名相同，参数的类型、个数、顺序不同，方法的返回值与访问修饰符可以不同</p><h4 id="重写（遵循两同两小一大）"><a href="#重写（遵循两同两小一大）" class="headerlink" title="重写（遵循两同两小一大）"></a>重写（遵循两同两小一大）</h4><ul><li><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p></li><li><p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p></li><li><p>构造方法无法被重写</p></li><li><p>如果方法的返回类型是<code>void</code>和基本数据类型，则返回值重写时不可修改；但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li></ul><h3 id="、equals-、hashCode"><a href="#、equals-、hashCode" class="headerlink" title="==、equals()、hashCode()"></a><code>==</code>、<code>equals()</code>、<code>hashCode()</code></h3><ul><li>对于基本数据类型，<code>==</code>比较的是变量的值</li><li>对于引用数据类型，<code>==</code>比较的是对象的内存地址</li></ul><p><code>equals()</code>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。</p><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。由于哈希碰撞的原因，不同的对象也有可能得到相同的<code>hashCode</code>值，如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p><h4 id="为什么重写equals-必须重写hashCode"><a href="#为什么重写equals-必须重写hashCode" class="headerlink" title="为什么重写equals()必须重写hashCode()"></a>为什么重写<code>equals()</code>必须重写<code>hashCode()</code></h4><p>如果只重写<code>equals()</code>而不重写<code>hashCode()</code>，那么<code>equals()</code>判断是相等的两个对象，<code>hashCode()</code>有可能不同；例如，HashSet进行去重添加时，会先通过<code>hashCode()</code>判断，那么没有重写的<code>hashCode()</code>就会返回<code>false</code>，即认为这两个对象是不同的，最终导致Set加入了重复元素。</p><h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a><code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>的区别</h3><ul><li>可变性<ul><li>String是不可变的，StringBuilder和StringBuffer可变</li></ul></li><li>线程安全性<ul><li>String和StringBuffer是线程安全的，StringBuilder是线程不安全的</li></ul></li><li>性能<ul><li>StringBuilder性能比StringBuffer略好</li></ul></li></ul><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li></ul><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet、LinkedHashSet、TreeSet的区别"><a href="#HashSet、LinkedHashSet、TreeSet的区别" class="headerlink" title="HashSet、LinkedHashSet、TreeSet的区别"></a>HashSet、LinkedHashSet、TreeSet的区别</h4><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p></li><li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h4><ul><li><p><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</p></li><li><p><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</p></li><li><p><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</p></li><li><p><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><ul><li><strong>线程安全性</strong>：HashMap是非线程安全的，HashTable是线程安全的（内部方法经过synchronized修饰）</li><li><strong>对Null key和Null value的支持</strong>：HashMap可以存储null的key和value，但null作为key只能有一个，作为value可有多个；HashTable不允许存在null key和null value</li><li><strong>底层数据结构</strong>：HashMap采用数组+链表&#x2F;数组+红黑树（链表长度超过阈值时，会转换为红黑树），HashTable采用数组+链表</li></ul><h4 id="HashMap和TreeMap的区别"><a href="#HashMap和TreeMap的区别" class="headerlink" title="HashMap和TreeMap的区别"></a>HashMap和TreeMap的区别</h4><ul><li><strong>底层数据结构</strong>：HashMap采用数组+链表&#x2F;数组+红黑树，TreeMap采用红黑树</li><li><strong>功能</strong>：TreeMap由于实现了NavigableMap接口和SortedMap接口，因此相较于HashMap增加了对集合内元素的搜索能力和对元素根据key排序的能力</li></ul><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><ul><li>NEW 初始状态，线程被创建出来但还没被调用start()</li><li>RUNNABLE 运行状态，线程被调用了start()，则变为READY可运行状态，等获得了CPU时间片后，处于RUNNING运行中状态</li><li>BLOCKED 阻塞状态，需要等待锁释放</li><li>WAITING 等待状态，需要其他线程做出一些特定动作（通知或者中断）</li><li>TIME_WAITING 超时等待状态，等待指定时间后返回而不是WAITING那样一直等待</li><li>TERMINATED 终止状态，线程执行完毕</li></ul><h4 id="死锁的产生和避免"><a href="#死锁的产生和避免" class="headerlink" title="死锁的产生和避免"></a>死锁的产生和避免</h4><ul><li><p>死锁产生的必要条件</p><ul><li>互斥：该资源任意一个时刻只能有一个线程占有</li><li>请求与保持：一个线程请求新资源的同时，不释放已占有的资源</li><li>不剥夺：占用中的资源只能由对应线程主动释放，无法被其他线程抢占</li><li>循环等待：若干线程形成一种环形的等待资源关系</li></ul></li><li><p>死锁的预防</p><ul><li>破坏请求与保持：一次性申请所有的资源</li><li>破坏不剥夺：线程在申请新资源时，释放自己占有的当前资源</li><li>破坏循环等待：按照某一顺序申请资源，释放资源则按照逆序</li></ul></li></ul><h4 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h4><p><strong>同</strong>：两者都可以暂停线程的执行</p><p><strong>异</strong>：</p><ul><li>sleep()没有释放锁，wait()释放了锁</li><li>wait()默认需要notify()或者notifyAll()来唤醒目标线程，sleep()执行完成后，目标线程会自动苏醒，或者也可以用wait(long timeout)，这样超时后线程也会自动苏醒</li><li>sleep()是Thread类的静态本地方法，wait()是Object类的本地方法</li></ul><h5 id="为什么wait-定义在Object类中，而sleep-定义在Thread类中"><a href="#为什么wait-定义在Object类中，而sleep-定义在Thread类中" class="headerlink" title="为什么wait()定义在Object类中，而sleep()定义在Thread类中"></a>为什么wait()定义在Object类中，而sleep()定义在Thread类中</h5><p>因为wait()是让获得对象锁的线程等待，自动释放当前线程占有的对象锁，所以操作的目标是Object而不是当前的Thread；</p><p>sleep()是让当前线程暂停执行，不涉及到Object，也不需要获得对象锁</p><h5 id="可以直接调用Thread类的run-方法吗"><a href="#可以直接调用Thread类的run-方法吗" class="headerlink" title="可以直接调用Thread类的run()方法吗"></a>可以直接调用Thread类的run()方法吗</h5><p>调用start()方法，会启动一个线程并使其进入Ready状态，当得到CPU时间片后即开始运行；因此真正的多线程工作方式是：start()执行线程的准备工作，然后自动执行run()方法；若直接调用run()，则当前方法会被当成一个main线程下的普通方法去执行，而不是在某个线程中执行</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><ul><li><p>volatile关键字可以保证变量的可见性，即该变量是共享且不稳定的，每次使用它都到主存中读取</p></li><li><p>volatile关键字可以防止JVM的指令重排序（通过插入特定的内存屏障来实现），例如单例模式的双重检验锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断对象是否已经实例过，没有实例过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>uniqueInstance = new Singleton()</code>这句代码是分成三步执行的：</p><ul><li>为<code>uniqueInstance</code>分配内存空间</li><li>初始化<code>uniqueInstance</code></li><li>将<code>uniqueInstance</code>指向分配的内存地址</li></ul><p>由于JVM有指令重排的特性，这三步的顺序可能发生调换，在多线程环境下可能会发生一个线程获得了尚未初始化的实例这类问题</p></li><li><p>volatile关键字无法保证原子性</p><ul><li>可用synchronized、AtomicInteger、ReentrantLock实现</li></ul></li></ul><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><h4 id="synchronized使用方式"><a href="#synchronized使用方式" class="headerlink" title="synchronized使用方式"></a>synchronized使用方式</h4><ul><li><p>修饰实例方法（锁当前对象实例）</p><p>进入同步代码前需要获得当前对象实例的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法（锁当前类）</p><p>因为静态方法是属于当前类而不是对象的，所以进入同步代码前需要获得当前类的锁。但静态synchronized方法和非静态synchronized方法可以互相调用，这是因为两者加锁的目标不同（一个是当前类，一个是当前对象实例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰代码块（锁指定的对象&#x2F;类）</p><p>对括号内的对象&#x2F;类加锁</p><ul><li><code>synchronized(object)</code>锁<code>object</code>对象</li><li><code>synchronized(类.class)</code>锁该类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指向同步代码块的起始位置，monitorexit指向同步代码块的结束位置；当执行monitorenter时，线程会试图获取对象监视器monitor的持有权；此时会去判断该锁的计数器是否为0，若为0，则获取锁成功，并将计数器+1；锁的拥有者可以通过monitorexit指令来释放锁，释放后将计数器-1</p><p>synchronized修饰方法时并没有monitorenter和monitorexit指令，而是通过ACC_SYNCHRONIZED标识；JVM借助该标识来辨别一个方法是否是同步方法</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是一个可重入且独占的锁，底层由AQS来实现</p><h3 id="各机制之间的对比"><a href="#各机制之间的对比" class="headerlink" title="各机制之间的对比"></a>各机制之间的对比</h3><h4 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h4><ul><li>volatile是线程同步的轻量级实现，所以性能相对于synchronized较好</li><li>volatile只能作用于变量之上，synchronized可修饰方法和代码块</li><li>volatile可以保证可见性，synchronized可以保证可见性和原子性</li></ul><h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><ul><li>两者都是可重入锁，即递归锁，指的是线程可以再次获取自己的内部锁，这样当出现线程递归申请锁的时候，不会产生死锁现象</li><li>synchronized依赖于JVM层面实现，ReentrantLock依赖于JDK层面实现</li><li>ReentrantLock实现了等待可中断，即正在等待的线程可以放弃等待，改为处理其他事情；synchronized等待不可中断</li><li>ReentrantLock可指定锁的公平性，synchronized只能是非公平锁；公平锁指的是先等待的线程先获得锁</li><li>ReentrantLock可绑定多个Condition，synchronized只能通过wait和notify绑定一个条件</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal类主要解决的就是让每个线程绑定自己的值</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>当有任务需要处理时，可从线程池中取出线程，处理完后线程不会销毁，而是等待下一个任务；池化思想的目的是为了减少每次获取资源的消耗，提高资源利用率</p><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><ul><li>通过<code>ThreadPoolExecutor</code>构造函数来创建</li><li>通过<code>Executor</code>框架的工具类<code>Executors</code>来创建</li></ul><h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul><li><code>corePoolSize</code>：任务队列未达到队列容量时，最大可以同时运行的线程数量</li><li><code>maximumPoolSize</code>：任务队列中存放的任务达到队列容量时，当前可同时运行的线程数变为最大线程数</li><li><code>workQueue</code>：新任务来的时候先判断当前运行的线程数是否达到核心线程数，若达到，则新任务会被放在队列中</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是<code>AbstractQueueSynchronizer</code>，即抽象队列同步器；这个抽象类主要用来构建锁和同步锁</p><p><strong>AQS的原理</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将该共享资源锁定；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。AQS用了<strong>CLH队列锁</strong>来实现该机制，即将暂时获取不到锁的线程加入到队列中</p><p>CLH队列是一个虚拟的双向队列；AQS将每条请求共享资源的线程封装成一个节点，每个节点保存了线程的引用、当前节点的状态、前驱和后继</p><p>节点的同步状态是用volatile修饰的，通过CAS等方法进行操作。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="悲观锁和应用场景"><a href="#悲观锁和应用场景" class="headerlink" title="悲观锁和应用场景"></a>悲观锁和应用场景</h4><p>共享资源每次只给一个线程使用，其他线程阻塞，用完后再将资源转让给其他线程，例如ReentrantLock和synchronized这种独占锁；悲观锁一般用于多写场景</p><h4 id="乐观锁和应用场景"><a href="#乐观锁和应用场景" class="headerlink" title="乐观锁和应用场景"></a>乐观锁和应用场景</h4><p>乐观锁只有在提交修改时才去验证对应的资源是否被其他线程修改；一般用于多读场景</p><h4 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h4><p>一般用版本号机制或CAS算法实现</p><ul><li><p>版本号机制</p><p>在数据表中加一个版本号字段，当数据被修改时，版本号加一。线程A更新数据时，读取数据的同时也读取版本号，提交更新时，若刚刚读到的版本号和数据库记录的版本号相等，则更新成功；否则重试直到成功</p></li><li><p>CAS算法</p><p>Compare And Swap 比较与交换。用一个预期值和要更新的变量值进行比较，两者相等才进行更新操作。</p><p>CAS是一个原子操作，涉及到三个操作数：</p><ul><li>V：要更新的变量值</li><li>E：预期值</li><li>N：拟写入的新值</li></ul><p>当且仅当V和E相等时，CAS通过原子方式用N来更新E；否则就说明有其他线程更新了V，当前线程放弃更新</p></li></ul><h4 id="乐观锁的问题"><a href="#乐观锁的问题" class="headerlink" title="乐观锁的问题"></a>乐观锁的问题</h4><ul><li><p><strong>ABA问题</strong>是乐观锁最常见的问题</p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过</p><p>解决方案：可以在变量前追加<strong>时间戳或者版本号</strong></p></li><li><p>循环时间长开销大</p><p>可通过pause指令降低资源消耗</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>主要由五个部分组成，可分为两个类别：</p><ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：堆、方法区</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</p></li><li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</p></li></ul><p>因此，程序计数器必须是每个线程独有的，无法共享</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址</p><ul><li>局部变量表：数据类型、对象引用之类</li><li>操作数栈：临时变量、中间计算结果等</li><li>动态链接：将符号引用转换为所要调用方法的直接引用</li><li>方法返回地址</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为执行本地方法（Java调用非Java代码的接口）而服务</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>存放对象实例以及数组</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>当JVM要使用一个类时，它需要读取并解析Class文件并获取相关信息，这些信息就会被存入方法区。方法区会存储<strong>已被JVM加载的类信息、字段信息、方法信息、常量等数据</strong>。</p><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1 类加载检查"></a>Step1 类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2 分配内存"></a>Step2 分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>，分配方式有两种：<strong>指针碰撞</strong>和<strong>空闲列表</strong>，<strong>选择哪种分配方式由 Java 堆是否规整（即有无内存碎片）决定，而 Java 堆是否规整又由所采用的GC收集算法决定</strong></p><ul><li>指针碰撞<ul><li>适用情况：堆内存规整，无内存碎片</li><li>操作：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小即可</li><li>使用该分配方式的GC收集器：Serial、ParNew</li></ul></li><li>空闲列表<ul><li>适用情况：堆内存不规整</li><li>操作：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录</li><li>使用该分配方式的GC收集器：CMS</li></ul></li></ul><p><strong>创建对象时的线程安全问题</strong></p><ul><li><strong>CAS+失败重试</strong>：CAS是乐观锁的一种实现方式，乐观锁指的是，不加锁而是假设不存在冲突去执行操作，如果因为冲突失败就进行重试，直到操作成功</li><li><strong>TLAB</strong>：为每一个线程预先在Eden区分配一块内存，JVM在给对象分配内存时，首先在TLAB分配，当对象大于TLAB剩余内存时，再采用CAS+失败重试方法</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3 初始化零值"></a>Step3 初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4 设置对象头"></a>Step4 设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息， <strong>这些信息存放在对象头中</strong></p><h4 id="Step5-执行init方法"><a href="#Step5-执行init方法" class="headerlink" title="Step5 执行init方法"></a>Step5 执行init方法</h4><p>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化</p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><strong>对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h4><ul><li>新生代：Eden区、Survivor S0区、Survivor S1区</li><li>老年代</li><li>元空间，使用的是直接内存</li></ul><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><ul><li>对象优先在Eden区分配，若Eden区空间不足，则发起Minor GC</li><li>大对象直接进入老年代，如字符串、数组等需要大量连续内存空间的对象，以此避免由于复制而降低效率</li><li>长期存活的对象将进入老年代，对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁</li></ul><h4 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h4><p>可达性分析算法：基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p><p>可作为GC Roots的对象：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li>标记-清除<ul><li>该算法分为标记和清除阶段：首先标记出存活的对象，在标记完成后统一回收掉所有未标记的对象。效率不高，且会产生大量内存碎片</li></ul></li><li>标记-复制<ul><li>将内存分为相同大小的两块，每次使用其中一块，当一块的内存用完后，把存活的对象复制到另一块内存，然后把当前内存块清理掉</li></ul></li><li>标记-整理<ul><li>先标记出存活的对象，然后将存活对象向一端移动，再清理掉端边界以外的内存</li></ul></li><li>分代收集<ul><li>将堆分为新生代和老年代，新生代采用标记-复制的GC算法，老年代采用标记-清除或标记-整理的GC算法</li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li>Serial<ul><li>单线程，必须暂停其他所有的工作线程；新生代标记-复制，老年代标记-整理</li></ul></li><li>ParNew<ul><li>多线程，新生代标记-复制，老年代标记-整理；唯一能与CMS配合工作</li></ul></li><li>Parallel Scavenge<ul><li>关注点在于吞吐量（CPU中运行用户代码的时间与CPU总耗时的比值）</li></ul></li><li>Serial Old<ul><li>Serial的老年代版本</li></ul></li><li>Parallel Old<ul><li>Parallel Scavenge的老年代版本</li></ul></li><li>CMS<ul><li>关注点在于用户线程的停顿时间</li><li>并发收集，GC收集线程可与用户线程几乎同时工作，标记-清除</li><li>具体运作过程分为四个阶段<ul><li>初始标记：暂停其他线程，记录与GC Roots相连的对象</li><li>并发标记：GC线程和用户线程同时开启，记录可达对象和发生引用更新的地方</li><li>重新标记：修正并发阶段由于用户线程运行而产生的标记变动，该阶段的暂停时段比初始阶段稍长，远小于并发阶段</li><li>并发清除：用户线程开启，GC线程同时开始清除未标记区域</li></ul></li><li>缺点：无法处理浮动垃圾，且由于使用标记-清除算法，会产生内存碎片</li></ul></li><li>G1<ul><li>标记-复制</li></ul></li><li>ZGC<ul><li>标记-复制</li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载过程：加载 -&gt; 连接 -&gt; 初始化</li><li>连接过程分为三步：验证 -&gt; 准备 -&gt; 解析</li></ul><p>类加载器的主要作用是加载Java类的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）</p><p>加载规则：JVM启动时，只会在类被用到的时候去加载，对于已经加载过的类会放到ClassLoader中；系统会首先判断该类是否加载过，已加载的类会直接返回。因此，对于一个类加载器来说，相同二进制名称的类只会被加载一次</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型如下图所示</p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 75%;" /><ul><li>BootstrapClassLoader启动类加载器：最顶层的加载器，无父类，主要用来加载JDK内部的核心类库和Xbootclasspath参数指定路径下的所有类</li><li>ExtensionClassLoader扩展类加载器：主要加载ext目录下的jar包和类以及java.ext.dirs系统变量所指定的路径下的所有类</li><li>AppClassLoader应用程序类加载器：面向用户的类加载器，负责加载当前应用classpath下的所有jar包和类</li></ul><h5 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h5><ul><li>在类加载时，系统会首先判断当前类是否已加载过，已加载过的类会直接返回，否则会尝试加载</li><li>类加载器首先不会自己去尝试加载这个类，而是先将这个请求委派给父类加载器（调用父类加载器的<code>loadClass()</code>方法）来完成；那么，所有的请求最终都会传给最顶层的BootstrapClassLoader</li><li>只有当父类加载器反馈无法完成当前的加载请求时，子加载器才会尝试自己去加载（调用<code>findClass()</code>方法）</li></ul><p><strong>JVM判定两个Java类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同，才认为两个类是相同的</p><h5 id="为什么要使用双亲委派"><a href="#为什么要使用双亲委派" class="headerlink" title="为什么要使用双亲委派"></a>为什么要使用双亲委派</h5><ul><li>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改</li><li>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类</li></ul><h5 id="如何打破双亲委派"><a href="#如何打破双亲委派" class="headerlink" title="如何打破双亲委派"></a>如何打破双亲委派</h5><p>重写<code>loadClass()</code>方法</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="使用TCP和UDP的协议分别有哪些"><a href="#使用TCP和UDP的协议分别有哪些" class="headerlink" title="使用TCP和UDP的协议分别有哪些"></a>使用TCP和UDP的协议分别有哪些</h4><ul><li>运行于TCP之上的协议<ul><li>HTTP&#x2F;HTTPS</li><li>FTP</li><li>SMTP</li><li>POP3&#x2F;IMAP</li><li>Telnet</li><li>SSH</li></ul></li><li>运行于UDP之上的协议<ul><li>DHCP</li><li>DNS</li></ul></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="输入URL到页面展示的过程"><a href="#输入URL到页面展示的过程" class="headerlink" title="输入URL到页面展示的过程"></a>输入URL到页面展示的过程</h4><ul><li>DNS解析（浏览器缓存 -&gt; 路由器缓存 -&gt; DNS缓存），获取域名对应IP</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>断开连接</li></ul><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul><li>1类：信息性状态码</li><li>2类：成功状态码</li><li>3类：重定向状态码</li><li>4类：客户端错误状态码</li><li>5类：服务端错误状态码</li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul><li>端口：HTTP默认是80，HTTPS默认是443</li><li>安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>常见排序算法可分为比较类和非比较类</p><ul><li>比较类排序算法<ul><li>冒泡排序：稳定、原地、最佳$O(n)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>快速排序：不稳定、原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(nlogn)$</li><li>插入排序：稳定、原地、最佳$O(n)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>希尔排序：稳定、原地、最佳$O(nlogn)$，最差$O(n^2)$，平均$O(nlogn)$、空间$O(1)$</li><li>选择排序：不稳定、原地、最佳$O(n^2)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>堆排序：不稳定、原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(1)$</li><li>归并排序：稳定、非原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(n)$</li></ul></li><li>非比较类排序算法<ul><li>基数排序：稳定、非原地、最佳$O(n\times k)$，最差$O(n\times k)$，平均$O(n\times k)$、空间$O(n+k)$</li><li>桶排序：稳定、非原地、最佳$O(n+k)$，最差$O(n^2)$，平均$O(n+k)$、空间$O(k)$</li><li>计数排序：稳定、非原地、最佳$O(n+k)$，最差$O(n+k)$，平均$O(n+k)$、空间$O(k)$</li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="事务的酸性ACID"><a href="#事务的酸性ACID" class="headerlink" title="事务的酸性ACID"></a>事务的酸性ACID</h4><ul><li>原子性：事务是最小的执行单位</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：一个用户的事务不被其他事务干扰</li><li>持久性：事务提交后，其对数据库的改变是持久的</li></ul><h4 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h4><ul><li>丢失修改：在一个事务读取一个数据时，另一个事务也访问了该数据，在第一个事务修改这个数据后，第二个事务也修改了这个数据，导致第一个事务所做的修改结果丢失</li><li>脏读：一个事务修改了一个数据，在其尚未提交之前，另一个事务读取了修改后的数据，此时第一个事务突然回滚，导致第二个事务读取了脏数据</li><li>不可重复读：在一个事务内多次读数据，但数据被另一个事务所修改，导致两次读取的数据不一致</li><li>幻读：发生在一个事务读取了几行数据，接着另一个事务插入了一些数据时。然后，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li></ul><h4 id="并发事务的控制方式"><a href="#并发事务的控制方式" class="headerlink" title="并发事务的控制方式"></a>并发事务的控制方式</h4><p>锁（悲观控制）和MVCC（乐观控制）</p><ul><li>锁可分为读写锁（可以读读并行，无法读写&#x2F;写写并行）<ul><li>共享锁（S锁）：读锁，事务在读取记录时获取共享锁，允许多个事务同时获取</li><li>排他锁（X锁）：写锁，事务在修改记录时获得排他锁，不允许多个事务同时获得；若一个记录已经被加了排他锁，其他事务不能再对该记录加任何锁</li><li>根据粒度可分为表级锁和行级锁<ul><li>表级锁是针对非索引字段的锁，加锁快，不会出现死锁，但触发锁冲突概率高，高并发场景效率较低</li><li>行级锁是针对索引字段的锁，开销大加锁慢，会出现死锁，但并发度高</li></ul></li></ul></li><li>MVCC对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本，实现手段主要是隐藏字段、read view和undo log<ul><li>undo log用来记录某行数据的多个版本的数据</li><li>read view和隐藏字段用来判断当前版本数据的可见性</li></ul></li></ul><h4 id="四个隔离级别"><a href="#四个隔离级别" class="headerlink" title="四个隔离级别"></a>四个隔离级别</h4><p>从低到高分别为：</p><ul><li>读取未提交 Read Uncommitted（脏读、不可重复读、幻读）</li><li>读取已提交 Read Committed（不可重复读、幻读）</li><li>可重复读 Repeatable Read（幻读）</li><li>可串行化 Serializable</li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><ul><li>MyISAM只支持表级别的锁粒度，而InnoDB可支持行级别的锁粒度</li><li>MyISAM不支持事务，InnoDB支持事务，实现了SQL的四个隔离级别</li><li>MyISAM不支持外键，InnoDB支持</li><li>MyISAM不支持MVCC，InnoDB支持</li><li>虽然两者均用B+树作为索引结构，但实现方式不同；InnoDB中，其数据文件本身就是索引文件。而MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录</li><li>MyISAM不支持数据库异常崩溃后的安全恢复，InnoDB支持</li><li>InnoDB性能更好</li></ul><h4 id="MySQL的隔离级别是如何实现的，默认隔离级别是什么"><a href="#MySQL的隔离级别是如何实现的，默认隔离级别是什么" class="headerlink" title="MySQL的隔离级别是如何实现的，默认隔离级别是什么"></a>MySQL的隔离级别是如何实现的，默认隔离级别是什么</h4><p>可串行化是通过锁来实现的，RR和RC是通过MVCC来实现的；默认隔离级别是RR</p><h4 id="InnoDB有哪几类行锁"><a href="#InnoDB有哪几类行锁" class="headerlink" title="InnoDB有哪几类行锁"></a>InnoDB有哪几类行锁</h4><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围</strong></p><h4 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h4><p>意向锁是一种表级锁，可以用来快速判断是否可对某个表使用表锁。意向锁之间是互相兼容的 </p><ul><li>意向共享锁：事务有意向表中的某些记录加共享锁，则必须先获得该表的IS锁</li><li>意向排他锁：事务有意向表中的某些记录加排他锁，则必须先获得该表的IX锁</li></ul><h4 id="快照读（一致性非锁定读）和当前读（一致性锁定读）的区别"><a href="#快照读（一致性非锁定读）和当前读（一致性锁定读）的区别" class="headerlink" title="快照读（一致性非锁定读）和当前读（一致性锁定读）的区别"></a>快照读（一致性非锁定读）和当前读（一致性锁定读）的区别</h4><p><strong>快照读</strong>的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景</p><p><strong>当前读</strong> 就是给行记录加 X 锁或 S 锁</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h5><p><strong>Hash表</strong></p><p>Hash表的优势在于O(1)的取值，但存在哈希冲突的问题，一般用拉链法解决（相同哈希结果的数据连在同一个链表中，后用红黑树代替链表）；作为索引不具备范围查找的功能，每次IO只能取一个值</p><p><strong>B树 &amp; B+树</strong></p><ul><li><p>B 树的所有节点既存放key也存放data，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</p></li></ul><h5 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h5><p>聚簇索引是索引结构和数据一起存放的索引，例如InnoDB的主键索引</p><ul><li>优点<ul><li>查询速度快：由于B+树本身就是平衡的，且叶子节点也都是有序的，定位到索引的同时，也就定位到了数据，相比于非聚簇，少了一次读取数据的IO操作</li><li>利于排序查找和范围查找</li></ul></li><li>缺点<ul><li>依赖于数据的有序性</li><li>更新代价大</li></ul></li></ul><p>非聚簇索引是索引结构和数据分开存放的索引，MyISAM使用的就是非聚簇索引；非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</p><ul><li>优点<ul><li>更新代价比聚簇小，因为叶子节点不存放数据</li></ul></li><li>缺点<ul><li>依赖于数据的有序性</li><li>可能需要回表：即根据查到的主键，再进行查询</li></ul></li></ul><h5 id="覆盖索引与联合索引"><a href="#覆盖索引与联合索引" class="headerlink" title="覆盖索引与联合索引"></a>覆盖索引与联合索引</h5><p>覆盖索引：一个索引包含所有需要查询的字段的值，则为覆盖索引；这种情况是不需要回表查询的</p><p>联合索引：使用表中的多个字段创建索引</p><h5 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h5><p>在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **<code>&gt;</code><strong>、</strong><code>&lt;</code>**）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><h5 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h5><h6 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h6><p>一种物理日志，InnoDB独有的功能，使MySQL具备了崩溃恢复的能力</p><p>MySQL中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里（刷盘时机由策略决定）</p><h6 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h6><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的；采用的是环形数组形式，从头开始写，写到末尾又回到头循环写</p><h5 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h5><p>binlog是逻辑日志，属于MySQL Server层，保证数据库的数据同步和一致性，记录所有涉及更新数据的逻辑操作，并且是顺序写</p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>在执行更新语句时，由于redo log可以在事务过程中写入，而binlog只能在提交事务时写入，因此可能会产生问题：</p><p>假设在redo log写完，binlog写入期间发生了异常，那么当MySQL重启后，redo log恢复出来的是修改后的新数据，而binlog由于没有记录到这次更新操作，因此会导致数据不一致的问题；为了解决这一问题，InnoDB采用了两阶段提交的方案</p><p>将redo log的写入拆分为两个步骤：<strong>prepare</strong>和<strong>commit</strong>，其中prepare阶段在事务执行过程中写入，commit阶段放在binlog写入之后完成，这样即使在binlog写入过程中发生异常，MySQL重启后只需检查redo log是否还处于prepare阶段，若redo log还处于prepare阶段，则将该事务回滚，以此保持数据的一致性</p><h5 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log 回滚日志"></a>undo log 回滚日志</h5><p>在 MySQL 中，恢复机制是通过undo log实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用undo log中的信息将数据回滚到修改之前的样子即可；并且，undo log会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询undo log来回滚之前未完成的事务</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><p>Redis中的key均为String类型，value包含五种基础数据类型，分别是：<strong>String、List、Set、Hash、Zset</strong></p><p><strong>String value</strong></p><p>String可以包含任何数据，例如数字、字符串、图片或者序列化对象等。</p><p><strong>应用场景：</strong>利用String value来做常用数据的缓存，redis做缓存层，mysql做持久化层，这样可以降低mysql的读写压力。</p><p><strong>List value</strong></p><p>Redis中的List是一种链表（以双端链表的形式来实现），其可以在队头队尾同时进行数据的压入弹出操作。</p><p><strong>应用场景</strong>：消息队列，例如微博的TimeLine</p><p><strong>Set value</strong></p><p>Redis中的Set是一种保存String的无序集合，其中的String变量无重复值。通过哈希表来实现，增删查的效率均为O(1)。</p><p><strong>应用场景：</strong>网站的点赞信息、网页元素的标签等。</p><p><strong>Hash value</strong></p><p>Redis中的Hash是一种k-v映射结构，其适用于存储对象。</p><p><strong>应用场景：</strong>是比String更加直观的一种存储方式。</p><p><strong>Zset value</strong></p><p>Redis中的Zset是一种有序集合，其和set一样不允许存在重复成员，不同的是Zset中每个成员会拥有一个分数，所有成员按照该分数来进行排序，不同成员的分数可以重复。</p><p>有序集合是通过两种数据结构实现：</p><ol><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的<strong>双向链表</strong>。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关；一般在：<strong>元素数量少于128和每个元素的长度小于64字节</strong>的时候才会采用压缩列表来实现Zset。</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li></ol><p><strong>应用场景：</strong>网站数据的排行榜等。</p><h5 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h5><p>Redis除了上述五种基础数据类型外，还包括三种特殊数据类型，分别是<strong>HyperLogLog基数统计、Bitmap位图、Geospatial地理位置</strong>。</p><p><strong>HyperLogLog基数统计</strong></p><p>这个结构可以非常省内存的去统计各种基数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。但这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值</p><p><strong>Bitmap位图</strong></p><p>操作二进制位来进行相关数据的记录，仅有0和1两个状态。比如：统计用户信息中的活跃与不活跃，登录与未登录，打卡与不打卡</p><p><strong>Geospatial地理位置</strong></p><p>可以推算地理位置的信息: 两地之间的距离, 方圆几里的人，获取成员的经纬度等。底层实现原理是Zset。</p><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Redis 5.0中增加了一个数据类型Stream，其借鉴了Kafka的设计，是一个支持多播的可持久化消息队列（Message Queue，MQ）</p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h5 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h5><p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。触发快照持久化有手动和自动两种方式。</p><p><strong>实际应用问题</strong></p><ul><li><p>一般Redis占据的内存较大，做快照的时间也可能较长，在快照时间内Redis很可能收到写数据的请求，那么在这种情况下如何保证Redis中的数据一致性？</p><p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p></li><li><p>在快照过程中，如果发生了服务的崩溃如何处理？</p><p>如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。</p></li><li><p>做快照的时间间隔越短越好？</p><p><strong>如果频繁地执行全量快照，会带来两方面的开销</strong>：</p><ul><li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁<strong>阻塞主线程</strong>了。</li></ul><p>因此可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。但这种方法需要使用另外的空间去记录哪些数据被修改了，所以一般采用RDB和AOF混合的持久化方式。</p></li></ul><h5 id="AOF写后日志"><a href="#AOF写后日志" class="headerlink" title="AOF写后日志"></a>AOF写后日志</h5><p><strong>实际应用问题</strong></p><ul><li><p>如何解决AOF日志不断增大的膨胀问题？</p><p>Redis会创建一个新的AOF文件，新旧AOF文件保存的数据没有区别，但新的AOF日志相较旧的AOF日志去除了冗余的中间命令。</p></li><li><p>AOF日志在重写的过程中会阻塞吗？</p><p>AOF日志的重写是通过fork创造的后台线程来进行的，因此阻塞只会在fork后台线程时发生。</p></li><li><p>重写AOF日志时，如果发生写操作如何应对？</p><p>在发生写操作时，Redis会将相应的命令存入AOF缓冲区，当负责重写的后台线程完成既定工作时，其会通知主线程，此时主线程则会将缓冲区内保存的写命令追加到重写日志中。</p></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>为了避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。Redis提供了主从复制的机制来实现数据的高可用性。</p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>主从库之间采用的是<strong>读写分离</strong>的方式。</p><ul><li><p>读操作：主库、从库都可以接收；</p></li><li><p>写操作：首先到主库执行，然后，主库将写操作同步给从库。</p></li></ul><h4 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h4><p>哨兵实现了如下所述的四个主要功能：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h5 id="哨兵集群的组建"><a href="#哨兵集群的组建" class="headerlink" title="哨兵集群的组建"></a>哨兵集群的组建</h5><p>哨兵通过在主库的频道上发布自己的IP和端口信息，其他哨兵通过订阅该频道从而获悉该哨兵的IP和端口，并建立网络连接。</p><h5 id="哨兵监控Redis库"><a href="#哨兵监控Redis库" class="headerlink" title="哨兵监控Redis库"></a>哨兵监控Redis库</h5><p>哨兵向主库发送INFO命令，主库则会将从库列表返回给该哨兵，那么该哨兵就可以和每个从库建立连接并进行监控。</p><h5 id="哨兵判断主库下线"><a href="#哨兵判断主库下线" class="headerlink" title="哨兵判断主库下线"></a>哨兵判断主库下线</h5><p>首先，哨兵可对主库做出“主观下线”的判断，并向其他哨兵发送信号；其他哨兵也会相应做出“主观下线”的判断，若所有的“主观下线”判断中“是”的数量不少于配置中的指标量，则可以认为主库已经达到“客观下线”。</p><h5 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h5><p>当主库“客观下线”后，需要有一个领头的哨兵节点来执行后续主从切换的动作。选举条件为：1. 拿到半数以上的赞成票；2. 得票数同时还需要不少于配置文件中的指标量（即主库达到“客观下线”的那个指标量）。</p><h5 id="新主库的选出"><a href="#新主库的选出" class="headerlink" title="新主库的选出"></a>新主库的选出</h5><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><h5 id="故障的转移"><a href="#故障的转移" class="headerlink" title="故障的转移"></a>故障的转移</h5><p>新主库选出后，最后哨兵leader要进行故障的转移，具体步骤如下：</p><ul><li><p>将某个slave节点脱离原从节点，升级成主节点；</p></li><li><p>将其他从节点指向新的主节点</p></li><li><p>通知客户端主节点已更换</p></li><li><p>将原主节点变成从节点，指向新的主节点</p></li></ul><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><ul><li>缓存穿透<ul><li><strong>问题来源</strong>：缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</li><li>解决方案<ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>布隆过滤器。bloomfilter就类似于一个HashSet，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小</li></ul></li></ul></li><li>缓存击穿<ul><li><strong>问题来源</strong>：缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</li><li><strong>解决方案</strong><ul><li>设置热点数据永远不过期。</li><li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li><li>加互斥锁</li></ul></li></ul></li><li>缓存雪崩<ul><li><strong>问题来源</strong>：缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机</strong>。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li><li><strong>解决方案</strong><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul></li></ul></li><li>缓存污染<ul><li><strong>问题来源</strong>：缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</li><li><strong>解决方案</strong><ul><li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li></ul></li></ul></li></ul><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>Consistency一致性：所有节点访问同一份最新的数据副本</li><li>Availability可用性：非故障的节点在合理的时间内返回合理的响应</li><li>Partition Tolerance分区容错性：分布式系统出现网络分区时，仍能够对外提供服务</li></ul><p>如果分布式系统发生了“分区”（某些节点由于故障不连通了，网络被分成了几块区域），则理论上只能支持CP或者AP架构，即P一定是要满足的。Nacos不仅支持AP也支持CP</p><h3 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h3><p>当分库之后，数据分布在不同服务器的DB上，DB的自增主键已经无法满足要求，因此需要生成分布式ID。</p><h4 id="分布式ID解决方案"><a href="#分布式ID解决方案" class="headerlink" title="分布式ID解决方案"></a>分布式ID解决方案</h4><ul><li>数据库<ul><li>关系型数据库自增主键</li><li>号段模式相比于自增主键，对于数据库的访问次数更少，DB压力更小</li><li>非关系型数据库使用Redis</li></ul></li><li>算法<ul><li>UUID（32个16进制）</li><li>雪花算法（64bit二进制数字）<ul><li>第0位符号位，1-41位时间戳，42-52位机房ID+机器ID，53-64位序列号</li></ul></li></ul></li><li>开源框架</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h4><ul><li>加锁<ul><li>用SETNX命令判断对应的锁是否存在，若不存在则加锁失败</li></ul></li><li>解锁<ul><li>为了保证释放锁的原子性，Redis会通过Lua脚本首先判断误删其他锁，没有问题则执行DEL命令释放锁</li></ul></li></ul><p>但存在这样的问题：<strong>释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问</strong></p><p>因此需要对锁设置一个过期时间，但又存在资源操作时间超过了过期时间导致服务中断的情况</p><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><p>Redisson提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>一台主数据库负责写，其他的从数据库负责读；主库和从库之间会进行数据同步，以保证从库中数据的准确性</p><h4 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h4><p>写完主库后，主库的新数据同步到从库需要一定时间，这段时间内会产生主从数据库的数据不一致问题</p><ul><li>强制将读请求路由到主库</li><li>延迟读取</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>代理方式<ul><li>在应用和数据中间加一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中</li></ul></li><li>组件方式<ul><li>引入第三方组件来帮助处理读写请求（sharding-jdbc）</li></ul></li></ul><h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><p>根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中，具体步骤如下</p><ul><li><p>主库将数据库中数据的变化写入到 binlog</p></li><li><p>从库连接主库</p></li><li><p>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</p></li><li><p>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</p></li><li><p>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中</p></li><li><p>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）</p></li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>为了解决MySQL的存储压力，可以使用分库分表的方案</p><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库；<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分</p><h4 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h4><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题</p><ul><li>哈希分片，求指定key的哈希值，根据哈希值确定分配的表，适合随机读写场景，不适合大量范围查询场景</li><li>范围分片，分成连续的若干段数据</li><li>融合分片</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列的应用场景：通过异步处理提高系统性能、削峰限流、降低耦合度</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><strong>如何保证消息不丢失</strong></p><ul><li>生产者丢失消息<ul><li>当send后通过回调函数的形式返回发送消息成功与否，同时设置合理的retry间隔时间</li></ul></li><li>消费者丢失消息<ul><li>真正消费完当前消息后手动提交offset的更新，但如果提交offset之前自己挂了，则会产生重复消费的问题</li></ul></li></ul><p><strong>如何保证消息不被重复消费</strong></p><ul><li>消费后做幂等校验</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/31/hello-world/"/>
      <url>/2023/03/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
