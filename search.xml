<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JUC线程池</title>
      <link href="/2023/08/16/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/08/16/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC线程池"><a href="#JUC线程池" class="headerlink" title="JUC线程池"></a>JUC线程池</h1><p>JUC的线程池包含了很多并发环境下使用的工具和类，包括FutureTask、ThreadPoolExecutor、ScheduledThreadPoolExecutor等。</p><p>线程池的存在能够对线程进行统一分配、调优和监控：</p><ul><li>避免程序无限制地创建线程，降低资源消耗</li><li>提高响应速度</li><li>提高线程的复用率和可管理性</li></ul><hr><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>Future是JUC下的一个接口，它代表了一个任务的生命周期，提供了一种在异步计算完成后获取结果的机制。</p><p>RunnableFuture接口继承了Runnable和Future，是一个可被运行的任务，同时也能返回异步计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask类则是实现了RunnableFuture接口，因此既能当作一个Runnable直接被Thread执行，也可以作为Future来得到Callable的计算结果；同时提供了相应方法的实现，例如：获取任务执行结果（get）、取消任务（cancel）等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt;</span><br></pre></td></tr></table></figure><p>FutureTask的线程安全性是由CAS来保证的。</p><hr><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>一般有两种方式去创建线程池：</p><ul><li>通过Executors类的内置方法来创建</li><li>通过ThreadPoolExecutor的构造函数来创建（推荐）</li></ul><p>但是，并不建议使用第一种方式。</p><div class="note warning flat"><p>为什么不建议用Executors来创建线程池</p></div><p>Executors有四个内置方法用来创建四种类型的线程池：</p><ul><li><code>newCachedThreadPool</code>：创建一个可缓存线程池，若线程池长度超过处理需要，则可回收空闲线程，没有空闲则创建新线程</li><li><code>newFixedThreadPool</code>：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li><li><code>newScheduledThreadPool</code>：创建一个定长线程池，支持定时及周期性任务执行</li><li><code>newSingleThreadExecutor</code>：创建一个单线程化的线程池，只会用唯一的工作线程来执行任务，按照指定的调度顺序来执行</li></ul><p>上述方法创建线程池时，无法让程序员能够显式地控制，容易出现资源耗尽的风险。例如：</p><ul><li><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>会产生大量的堆积请求队列，内存消耗极大，容易OOM</li><li><code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>容纳的线程最大数是<code>Integer.MAX_VALUE</code>，创建的线程数过多，也会OOM</li></ul><div class="note info flat"><p>ThreadPoolExecutor数据结构</p></div><p>ThreadPoolExecutor的一种构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知与线程池相关的参数包括：</p><ul><li><code>corePoolSize</code>：核心线程数。这是线程池中保持活动状态的线程数量的下限，即创建新的线程直到活跃线程数达到<code>corePoolSize</code>；如果当前线程数等于<code>corePoolSize</code>，那么后续提交的任务会保存到阻塞队列中等待。</li><li><code>maximumPoolSize</code>：最大线程数。如果阻塞队列满了，并且仍有任务提交上来，那么会创建新的线程来执行任务，直到线程数抵达<code>maximumPoolSize</code>，后续再出现的任务则会根据饱和策略进行处理；如果阻塞队列是无界队列，那么这个参数就没用了</li><li><code>keepAliveTime</code>：线程空闲时的存活时间。</li><li><code>unit</code>：存活时间的单位</li><li><code>workQueue</code>：保存等待被执行的任务的阻塞队列。具体可看<a href="">JUC集合</a>这篇文章。<ul><li><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列，按照FIFO调度任务</li><li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，按照FIFO调度任务，吞吐量一般高于<code>ArrayBlockingQueue</code></li><li><code>SynchronousQueue</code>：这个阻塞队列不存储任何元素，采用「即时消费，即时生产」的方式。即：一个线程若向<code>SynchronousQueue</code>插入元素，则必须有一个消费者线程准备好接收该元素，否则会阻塞；反之亦然</li><li><code>PriorityBlockingQueue</code>：基于优先级的无界阻塞队列，按照优先级调度任务</li></ul></li><li><code>handler</code>：线程池的饱和策略。<ul><li><code>AbortPolicy</code>：直接抛出一个<code>RejectedExecutionException</code>，默认是这个策略</li><li><code>CallerRunsPolicy</code>：用调用者所在的线程来执行任务</li><li><code>DiscardOldestPolicy</code>：丢弃阻塞队列中最老（最靠前）的任务，并执行当前任务</li><li><code>DiscardPolicy</code>：直接丢弃当前的任务</li></ul></li></ul><div class="note info flat"><p>线程池处理任务全流程</p></div><p>线程池处理任务的全流程如图所示：</p><img src="https://i.ibb.co/WzRmJj9/Thread-Pool.png" alt="ThreadPool" style="zoom:60%;" /><ul><li><p>提交任务后，首先判断核心线程的数量是否超过<code>corePoolSize</code>；若没有超过，则创建线程来处理任务；否则，将任务加入到<code>workQueue</code></p></li><li><p>然后判断<code>workQueue</code>是否已满，若未满，则加入；否则，尝试创建线程来处理</p></li><li><p>判断当前线程数是否已达到<code>maximumPoolSize</code>，若未过量，则创建新线程来处理任务；否则，按照<code>handler</code>指定的饱和策略来处理</p></li></ul><div class="note warning flat"><p>配置线程池要考虑哪些因素</p></div><p>一般考虑任务的优先级、任务的执行时间长短、任务的性质、任务的依赖关系这四个方面的因素，尽可能使用有界的阻塞队列。</p><p>另外，如何设置线程池的大小主要由任务的性质来决定。</p><ul><li>CPU密集型任务：主要消耗CPU资源，可将线程数设置为<strong>N+1</strong>（N为CPU核心数）。比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间</li><li>I&#x2F;O密集型任务：主要处理I&#x2F;O交互，可将线程数设置为<strong>2N</strong>。线程在处理I&#x2F;O的时间段内不会占用CPU，这时就可以将CPU交出给其它线程使用。因此在I&#x2F;O密集型任务的应用中，可以多配置一些线程</li></ul><hr><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，一般用于周期性任务或者任务延迟。与ThreadPoolExecutor不同的是：</p><ul><li>使用专门的任务类型ScheduledFutureTask来执行周期任务</li><li>使用专门的存储队列DelayedWorkQueue来存储任务，这是无界阻塞队列DelayQueue的一种</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC锁</title>
      <link href="/2023/08/14/JUC%E9%94%81/"/>
      <url>/2023/08/14/JUC%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC锁"><a href="#JUC锁" class="headerlink" title="JUC锁"></a>JUC锁</h1><p>JUC锁有一些比较重要的部分，包括LockSupport、AQS、ReentrantLock、ReentrantReadWriteLock。</p><hr><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport是一个提供锁机制的工具类，可以说是JUC锁实现的基础。</p><p>其一般用来支持线程的阻塞和唤醒操作，比传统的<code>wait()</code>和<code>notify()</code>更加灵活和强大。</p><div class="note info flat"><p>核心函数分析</p></div><p>LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>park()</code>：阻塞线程，直到出现以下几类情况：<ul><li>调用<code>unpark()</code>函数，释放该线程的许可</li><li>该线程被中断</li><li>设置的时间到了（依据参数time）</li></ul></li><li><code>unpark()</code>：释放线程的许可，这个函数是不安全的，因为不确定目标线程是否仍是存活的</li></ul><div class="note warning flat"><p>一些问题</p></div><p>关于常用的线程阻塞&#x2F;唤醒方法，有一些比较问题。</p><div class="note default flat"><p>Thread.sleep()和Object.wait()的区别</p></div><ul><li><p>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</p></li><li><p>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</p></li><li><p>Thread.sleep()到时间了会自动唤醒，然后继续执行；</p><p>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分为两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁</p></li></ul><div class="note default flat"><p>Object.wait()和Condition.await()的区别</p></div><p>Object.wait()和Condition.await()的原理基本一致，不同的是Condition.await()底层是调用LockSupport.park()来阻塞当前线程的。</p><div class="note default flat"><p>Thread.sleep()和LockSupport.park()的区别</p></div><ul><li><p>都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</p></li><li><p>Thread.sleep()只能自己醒过来；LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</p></li><li><p>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；LockSupport.park()方法不需要捕获中断异常；</p></li><li><p>Thread.sleep()本身就是一个native方法；LockSupport.park()底层是调用的Unsafe类的native方法</p></li></ul><div class="note default flat"><p>Object.wait()和LockSupport.park()的区别</p></div><ul><li><p>Object.wait()方法需要在synchronized块中执行；LockSupport.park()可以在任意地方执行；</p></li><li><p>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；LockSupport.park()不需要捕获中断异常；</p></li><li><p>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</p></li></ul><div class="note default flat"><p>如果在wait()之前执行了notify()会怎样</p></div><p>如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；</p><p>如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。</p><div class="note default flat"><p>如果在park()之前执行了unpark()会怎样</p></div><p>线程不会被阻塞，直接跳过park()，继续执行后续内容</p><hr><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS（AbstractQueuedSynchronizer）是JUC锁的核心部分，提供了一个基于FIFO的队列，可用于构建锁或其他同步器的基础框架。</p><p>例如ReentrantLock、Semaphore、ReentrantReadWriteLock、SynchronousQueue、FutureTask等都是基于AQS实现的。</p><div class="note info flat"><p>设计理念</p></div><p><strong>核心思想：</strong></p><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态；</strong></p><p><strong>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中</strong></p><blockquote><p>CLH队列是一个虚拟的双向队列（不存在队列实例，仅存在结点之间的关联关系）。AQS将每条请求共享资源的线程封装成一个CLH队列的一个结点来实现锁的分配。</p></blockquote><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。使用CAS对这个状态变量进行维护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//使用volatile保证可见性</span></span><br></pre></td></tr></table></figure><p>这个状态信息可通过protected类型的getState、setState、compareAndSetState来进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AQS对资源的共享方式</strong></p><p>AQS定义了两种资源共享的方式：</p><ul><li>独占Exclusive：只有一个线程可以得到资源，比如ReentrantLock。又可分为公平锁与非公平锁。<ul><li>公平锁：按照线程在队列中的顺序，先到者先得到锁</li><li>非公平锁：当线程获取锁时，无视队列顺序，竞争获取</li></ul></li><li>共享Share：多个线程同时执行，如Semaphore等</li></ul><p>ReentrantReadWriteLock可看作是组合式锁。</p><div class="note info flat"><p>数据结构</p></div><p>AQS将每条线程封装成一个CLH队列的结点。其中Sync Queue是同步队列，用双向链表实现；Condition Queue不是必须的，用单向链表实现，只有当使用Condition时，才会存在，且有可能有多个。</p><p>AQS的实现原理如图所示：</p><img src="https://i.ibb.co/QXRMg03/CLH.png" alt="CLH" style="zoom:60%;" /><p>以可重入的互斥锁 <code>ReentrantLock</code> 为例，它的内部维护了一个 <code>state</code> 变量，用来表示锁的占用状态。</p><p><code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。</p><ul><li>如果成功了，那么线程 A 就获取到了锁。</li><li>如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。</li></ul><p>假设线程 A 获取锁成功了，释放锁之前，线程A是可以重复获取此锁的（<code>state</code> 会累加）。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p><div class="note info flat"><p>基于AQS的常见同步工具类</p></div><p>基于AQS实现的同步工具类一般有：Semaphore信号量、CountDownLatch倒计时器、CyclicBarrier循环栅栏。</p><div class="note default flat"><p>Semaphore 信号量</p></div><p>Semaphore可以用来控制同时访问特定资源的线程数量。例如，下面的代码表示同一时刻只有5个线程可以获取到共享资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);<span class="comment">//初始化共享资源份数</span></span><br><span class="line">semaphore.acquire();<span class="comment">//获取1个许可</span></span><br><span class="line">semaphore.release();<span class="comment">//释放1个许可</span></span><br></pre></td></tr></table></figure><p>Semaphore有公平式和非公平式两种模式。</p><div class="note default flat"><p>CountDownLatch 倒计时器</p></div><p>CountDownLatch允许<code>count</code>个线程阻塞在一个地方，直到所有线程都执行完毕。这里面的<code>count</code>实际上就是对应AQS中的<code>state</code>值。</p><p>两种常见用法：</p><ul><li><p>某一线程在开始运行前等待n个线程执行完毕 : </p><p>将<code>CountDownLatch</code>的计数器初始化为n，每当一个任务线程执行完毕，就将计数器减1；</p><p>当计数器的值变为 0 时，在<code>CountDownLatch</code>上<code> await()</code>的线程就会被唤醒。</p><p>一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p></li><li><p>实现多个线程开始执行任务的最大并行性：</p><p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行</p><p>做法是初始化一个共享的<code>CountDownLatch</code>对象，将其计数器初始化为1</p><p>多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p></li></ul><div class="note default flat"><p>CyclicBarrier 循环栅栏</p></div><p>CyclicBarrier 循环栅栏实际上是基于ReentrantLock和Condition来实现的。</p><p>用来让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><p>与CountDownLatch的区别主要在于：</p><ul><li>CyclicBarrier是可重用的，CountDownLatch用过一次之后就无法重用了</li><li>线程“苏醒”的点不同，CyclicBarrier是所有线程到达屏障时，CountDownLatch是计数器归零</li></ul><hr><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock基于AQS，实现了Lock接口，是一个<strong>可重入</strong>且<strong>独占</strong>的锁。</p><p>ReentrantLock一共有三个内部类，分别是Sync、NonfairSync、FairSync；其中，Sync继承了AbstractQueuedSynchronizer抽象类，NonfairSync和FairSync继承了Sync。</p><div class="note info flat"><p>ReentrantLock和synchronized的区别</p></div><p>相同点：两者都是可重入锁、都是独占式的</p><p>不同点：</p><ul><li>synchronized是JVM层面实现的，ReentrantLock是JDK层面实现的</li><li>ReentrantLock功能比synchronized更加丰富：<ul><li>等待可中断：<code>lock.lockInterruptibly()</code>可让正在等待资源的线程放弃等待，改为处理其他事情</li><li>实现公平锁：通过构造函数中的<code>fair</code>参数决定是否公平，synchronized只能非公平</li></ul></li></ul><hr><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock是基于ReentrantLock和AQS实现的。</p><p>包含五个内部类：Sync、NonfairSync、FairSync、ReadLock、WriteLock。其中，ReadLock、WriteLock实现了Lock接口。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java原子类</title>
      <link href="/2023/08/12/Java%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>/2023/08/12/Java%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java原子类"><a href="#Java原子类" class="headerlink" title="Java原子类"></a>Java原子类</h1><p>关于线程安全问题，有三种解决方法，其中原子类是一种无锁的非阻塞方法。</p><p>Java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类来实现的。</p><hr><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS指的是Compare and Swap，即比较并交换。这是CPU的一条原子指令，依靠硬件来实现。</p><p>CAS涉及了三个操作数：V（要更新的目标变量）、E（预期值）、N（准备写入的新值）。</p><p><strong>原理：当且仅当V值为E时，CAS才会通过原子方式用N来更新V的值；如果前提不成立，则说明已有其他线程更新了V，但允许再次尝试。</strong></p><p>CAS方式为乐观锁，synchronized为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。</p><p>但是CAS（乐观锁）存在如下几个问题：</p><div class="note info flat"><p>ABA问题</p></div><p>因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>例如，场景是用链表来实现一个栈，初始化向栈中压入B、A两个元素，栈顶指向A元素。</p><p>在某个时刻，线程1试图将栈顶换成B，但它获取栈顶的oldValue（为A）后，被线程2中断了。线程2依次将A、B弹出，然后压入C、D、A。然后换线程1继续运行，线程1执行compareAndSet发现head指向的元素确实与oldValue一致，都是A，所以就将head指向B了。但是线程2在弹出B的时候，将B的next置为null了，因此在线程1将head指向B后，栈中只剩了一个元素B。</p><p>解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A -&gt; B -&gt; A就会变成1A -&gt; 2B -&gt; 3A。</p><div class="note info flat"><p>循环时间长</p></div><p>CAS经常会用到自旋操作来进行重试，也就是失败后一直循环执行直到成功。如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：</p><p>第一，它可以延迟流水线执行命令，使CPU不会消耗过多的执行资源；</p><p>第二，它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。</p><div class="note info flat"><p>只能保证一个共享变量的原子操作</p></div><p>CAS只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</p><p>但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，因此可以把多个变量放在一个对象里来进行CAS操作</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="/2023/08/10/Java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/08/10/Java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h1><p>Java中有一些比较常见且重要的关键字：synchronzied、volatile、final、static。</p><hr><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在Java早期版本中，synchronized属于重量级锁，效率不高，因为底层是操作系统的mutex lock来实现的。在Java 6之后，synchronized引入了大量优化手段，如自旋锁等，极大减少了开销。</p><div class="note info flat"><p>synchronized能修饰哪些东西？</p></div><ul><li><p>代码块</p><p>给括号里指定的对象&#x2F;类加锁：<code>synchronized(object)</code>或者<code>synchronized(类.class)</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//进入同步代码块前要获得指定对象的锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Terminated: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedDemo</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedDemo</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;<span class="comment">//进入同步代码块前要获得对应类的锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Terminated: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例方法</p><p>给当前对象实例加锁，进入同步代码块前要获得当前对象实例的锁。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Terminated: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态方法</p><p>修饰静态方法，默认的锁就是当前的类。因为静态成员是归整个类所有，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedDemo</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedDemo</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Terminated: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>PS：构造方法不能用synchronzied，因为其本身就是线程安全的。</p></blockquote><div class="note info flat"><p>synchronized底层原理</p></div><p>创建如下一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javac命令进行编译生成.class文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac SynchronizedDemo.java</span><br></pre></td></tr></table></figure><p>使用javap命令反编译查看.class文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose SynchronizedDemo.class</span><br></pre></td></tr></table></figure><p>可以得到详细的字节码信息：</p><img src="https://i.ibb.co/Cssz8sd/2023-08-11-9-44-28.png" alt="bytecode" style="zoom:75%;" /><p>其中，第6行的<code>monitorenter</code>和第8行以及第14行的<code>monitorexit</code>是关键。</p><p><code>monitorenter</code>指向同步代码块的开始位置，<code>monitorexit</code>指向同步代码块的结束位置。</p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常这两种情况下都能被正确释放。</p><p><code>monitorenter</code>：每一个对象在同一时间只会和一个monitor相关联，一个monitor在同一时间只能被一个线程所获取。因此，一个对象在尝试获得其关联的monitor锁的时候，会发生三种情况：</p><ul><li>monitor计数器为0，表示锁尚未被任何对象获取，那么这个线程就会获得锁，并且计数器+1</li><li>若已获得了该锁，则会重入，且计数器随着重入次数的增加而增加</li><li>monitor计数器不为0，则已被其他线程获取，等待锁释放</li></ul><p><code>monitorexit</code>：释放对于monitor的所有权，过程就是将monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p><img src="https://i.ibb.co/yNKKNGv/monitor.png" alt="monitor" style="zoom:70%;" /><div class="note info flat"><p>Java 6后的优化手段</p></div><p>前面提到了synchronized在早期Java中的开销很大，主要是因为实现依赖于底层操作系统的Mutex Lock，需要将当前线程挂起并从用户态切换到内核态来执行。后期引入了大量的优化手段：</p><ul><li>锁粗化</li><li>锁消除</li><li>轻量级锁</li><li>偏向锁</li><li>适应性自旋</li></ul><hr><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><div class="note info flat"><p>volatile的常见用途</p></div><ul><li><p>保证可见性</p></li><li><p>防止重排序</p><p>例如，并发环境下实现单例模式，通常采用双重检查加锁DCL的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​       通常来说，实例化一个对象可以分为三个步骤：分配内存空间、初始化对象、将内存空间的地址赋值给相应的引用。</p><p>​       但是由于操作系统可能会对指令进行重排序，导致未初始化的对象引用暴露在外。因此，用volatile加以修饰防止这种情况发生。</p><div class="note info flat"><p>volatile底层原理</p></div><ul><li><p>volatile可见性实现原理</p><p>一是通过插入内存屏障来禁止指令重排序。在写操作之后插入一个写屏障，读操作之前插入一个读屏障，确保写操作不会被重排序到读操作之前；</p><p>二是强制刷新主存。强制线程将修改后的新值立即刷新到主存，保证其他线程读到的是新值。</p></li><li><p>volatile有序性实现原理</p><p>依靠happens-before的规则。</p></li></ul><hr><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final可用来修饰<strong>类、方法和变量</strong>。</p><ul><li>final修饰的类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法</li><li>final修饰的方法不能被重写</li><li>final修饰的变量是常量，即：数据类型的变量不能被修改，引用类型的变量不能修改指向</li></ul><hr><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static应用场景一般为：</p><ul><li><p>修饰成员变量和成员方法</p><p>static修饰的成员隶属于这个类，被类中所有对象共享，可以通过类名进行调用。</p></li><li><p>静态代码块</p><p>静态代码块定义在类中的方法外，在非静态代码块之前执行（静态代码块 -&gt; 非静态代码块 -&gt; 构造方法）。无论类创建多少个对象，静态代码块只执行一次。</p></li><li><p>静态内部类</p><p>静态内部类不能使用任何外围类的非static成员变量和方法。</p></li></ul><blockquote><p>PS：this和super不能用在static方法中。</p><p>因为this代表对本类对象的引用，super代表对父类对象的引用；二者属于对象范畴，而静态方法属于类范畴。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2023/08/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/08/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><strong>Java内存模型（JMM）</strong>抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</p><p>在 JDK1.2 之前，Java 的内存模型实现总是从 <strong>主存</strong> （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。</p><p>这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p><img src="https://i.ibb.co/mFtMKzM/JMM.png" alt="JMM" style="zoom:70%;" /><ul><li>主内存：所有线程创建的实例对象都存放在主内存中，无论该实例对象是成员变量还是方法中的局部变量。</li><li>本地内存：每个线程都有一个私有的本地内存来存放共享变量的副本，并且只能访问自己的本地内存。</li></ul><p>线程之间若想进行通信，则必须：</p><ul><li>线程A把本地内存中修改过的共享变量副本的值同步到主内存中；</li><li>线程B到主内存中去读取相应的共享变量</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题：ACM数组构造二叉树</title>
      <link href="/2023/08/08/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9AACM%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/08/08/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9AACM%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="算法题：ACM数组构造二叉树"><a href="#算法题：ACM数组构造二叉树" class="headerlink" title="算法题：ACM数组构造二叉树"></a>算法题：ACM数组构造二叉树</h1><p>算法题里面，有很多以「树」为背景的题，输入用例一般都是一个数组。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br></pre></td></tr></table></figure><p>假设其表示一棵二叉树，那么该树是这样的：</p><img src="https://i.ibb.co/xFk1hrF/binary-Tree.png" alt="binaryTree" style="zoom:70%;" /><p>在二叉树构造中，只有<strong>「中序和后序&#x2F;先序」</strong>才能唯一地确定一棵二叉树。</p><p>观察所给的数组，不难发现，节点是按照<strong>层序遍历</strong>的方式排列的。</p><p>另外，树的存储方式有两种：</p><ul><li>链式存储，即最常见的指针连接各个父子节点</li><li>顺序存储，即用一个数组来存树的结构</li></ul><p>第二种方式，若父节点在数组中的下标为i，那么其左子节点的下标就是2i+1，右子节点的下标就是2i+2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildBinaryTree</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">       <span class="type">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.val = val;</span><br><span class="line">           <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">           <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       List&lt;TreeNode&gt; treeNodes = arr.length &gt; <span class="number">0</span> ? <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr.length) : <span class="literal">null</span>;</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">               node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           treeNodes.add(node);</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">               root = node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; <span class="number">2</span>*i+<span class="number">1</span>&lt;arr.length; i++)&#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> treeNodes.get(i);</span><br><span class="line">           <span class="keyword">if</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">               node.left = treeNodes.get(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span> (<span class="number">2</span>*i+<span class="number">2</span> &lt; arr.length) node.right = treeNodes.get(<span class="number">2</span>*i+<span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> construct(arr);</span><br><span class="line">       List&lt;List&lt;TreeNode&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">           ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               list.add(node);</span><br><span class="line">               <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res.add(list);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (List&lt;TreeNode&gt; level : res)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;level.size(); i++)&#123;</span><br><span class="line">               System.out.println(level.get(i).val);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志</title>
      <link href="/2023/08/04/MySQL%E6%97%A5%E5%BF%97/"/>
      <url>/2023/08/04/MySQL%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><p>在<a href="https://www.brokenmind.top/2023/07/09/MySQL%E6%9E%B6%E6%9E%84/">MySQL架构</a>这篇文章中，提到了执行一条SQL查询语句的运行过程。当执行一条SQL更新语句时，其运行过程如下：</p><ul><li>客户端首先通过连接器建立连接，连接器自动判断用户身份</li><li>解析器通过词法分析识别出关键字update、表名等，构建出语法树，然后做语法分析，判断该语句是否符合MySQL语法</li><li>预处理器判断表和字段是否存在</li><li>优化器确定执行计划，决定要走哪些索引</li><li>执行器负责具体执行，找到目标行，然后做更新</li></ul><p><strong>与执行查询语句不同的是，更新语句的流程会涉及到回滚日志undo log、重做日志redo log、归档日志binlog。</strong></p><ul><li>undo log：InnoDB存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于<strong>事务回滚和MVCC</strong></li><li>redo log：InnoDB存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要用于掉电等<strong>故障恢复</strong></li><li>binlog：Server层生成的日志，主要用于<strong>数据备份和主从复制</strong></li></ul><hr><div class="note info flat"><p><strong>undo log详解</strong></p></div><p>在执行一条增删改语句时，虽然没有输入begin开启事务和commit提交事务，但MySQL会隐式地开启事务来执行这条语句，执行完就自动提交事务，这样就可以保证用户能够及时地看到相应的结果。</p><p>因此，执行update语句时，也是会隐式地使用事务的。那么，事务在提交之前如果发生了崩溃，想要回滚到事务之前的数据则需要依靠undo log来实现，其保证了事务执行的原子性。</p><p>在事务没提交之前，MySQL会先将更新前的数据记录到undo log日志文件里，当事务回滚时，可以利用undo log来进行回滚。</p><p><img src="https://i.ibb.co/VDLj8D4/undolog.png" alt="undolog"></p><p>每当InnoDB对一条记录进行增删改时，都要把回滚时需要的信息记录到undo log中，例如：</p><ul><li>新增一条记录时，记下这条记录的主键值，回滚时只需要将该主键值对应的记录删除即可</li><li>删除一条记录时，记下这条记录的所有内容，回滚时将这些内容组成的记录插入到表中</li><li>更新一条记录时，记下被更新列的旧值，回滚时将该列更新为旧值</li></ul><p>一条记录的每一次更新操作产生的undo log格式都有一个<code>roll_pointer</code>指针和一个<code>trx_id</code>事务ID：</p><ul><li>通过<code>roll_pointer</code>指针可以将这些undo log串成一个链表（版本链）</li><li>通过<code>trx_id</code>可知该记录是被哪个事务修改的</li></ul><p><img src="https://i.ibb.co/PZcqLmv/rollpointer.png" alt="roll_pointer"></p><p>除此之外，undo log还有一个作用，即<strong>通过Read View + undo log实现MVCC</strong>。</p><p>对于「读提交」RC和「可重复读」RR两种隔离级别的事务，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同：</p><ul><li>RC级别是在每个select都会生成一个新的Read View，那么，在事务期间多次读取同一条数据，前后读到的数据可能会不一致（因为期间另外一个事务修改该数据并提交了）</li><li>RR级别是在启动事务时生成一个Read View，整个事务期间都用这个Read View，这样就保证了在事务执行期间读到的数据都是事务开始前的值，不会产生不一致</li></ul><p>这两个隔离级别的实现是通过「事务的Read View里的字段」和「记录中的两个隐藏列<code>trx_id</code>和<code> roll_pointer</code>」的比对，如果不满足可见性，就会顺着undo log版本链里找到满足可见性的记录，从而控制并发事务访问同一个记录，这就叫MVCC（多版本并发控制）</p><p>综上，undo log起着两个作用：</p><ul><li>实现事务的回滚，保证事务的原子性。</li><li>实现MVCC的必要组件。</li></ul><blockquote><p>PS：undo log的刷盘（持久化到硬盘）和数据页是一样的，都需要通过redo log来保证。</p><p>Buffer Pool中有undo页，对undo页的修改也都会记录到redo log中。redo log每秒刷盘，提交事务也会刷盘。</p></blockquote><hr><div class="note info flat"><p><strong>Buffer Pool详解</strong></p></div><p>InnoDB存储引擎中有Buffer Pool，用来提高数据库的读写性能。</p><ul><li>当读取数据时，若数据存在于Buffer Pool中，客户端就会直接读取Buffer Pool中的数据，否则再去磁盘中读取</li><li>当修改数据时，若数据存在于Buffer Pool中，则直接修改Buffer Pool中该数据所在的页，然后将其设置为脏页（内存数据与磁盘数据不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，而是后续由后台线程完成写入</li></ul><hr><div class="note info flat"><p><strong>redo log详解</strong></p></div><p>尽管Buffer Pool可以提高数据库的读写效率，但其是基于内存的，可靠性无法保证，断电重启时还未落盘的脏页数据就会丢失。</p><p>为了防止这种情况，当有一条记录需要更新时，InnoDB会先更新内存，同时标记为脏页，然后将本次对该页的修改以redo log的形式保存下来，此时算作更新完成。</p><p>后续，InnoDB会在恰当时机，用后台线程将脏页刷盘，即<strong>预写日志（Write-Ahead Logging，WAL）</strong>。</p><p>WAL是指MySQL的写操作并不是立即写入磁盘，而是先写日志，再在合适的时间刷盘。整个过程如下：</p><p><img src="https://i.ibb.co/crGks3m/redolog.png" alt="redolog"></p><p>那么，在事务提交时，只要先将redo log持久化到磁盘即可，这样即使系统崩溃，脏页尚未持久化，但redo log已经持久化，因此重启MySQL时根据redo log即可将数据恢复到最新状态。</p><div class="note warning flat"><p>redo log和undo log有什么区别？</p></div><p>两者都是InnoDB层的日志，区别在于：</p><ul><li>redo log记录此次事务<strong>完成后</strong>的数据状态，记录的是<strong>更新后的值</strong></li><li>undo log记录此次事务<strong>开始前</strong>的数据状态，记录的是<strong>更新前的值</strong></li></ul><p>事务提交前发生崩溃，重启后通过undo log回滚；事务提交后发生崩溃，重启后通过redo log恢复。</p><p><img src="https://i.ibb.co/Mh5fZQr/Redo-And-Undo.png" alt="redo&amp;undo"></p><div class="note warning flat"><p>redo log要刷盘，数据本身也要刷盘，为何多此一举？</p></div><p>redo log的写入是追加方式，所以磁盘是<strong>顺序写</strong>，而写入数据要先找到写入位置，所以是<strong>随机写</strong>。</p><p>顺序写比随机写的效率高很多，因此写入redo log的开销很小。</p><div class="note warning flat"><p>redo log何时写入磁盘？</p></div><p>redo log不会直接写入磁盘（防止产生大量I&#x2F;O），而是写入到自己的缓存<strong>redo log buffer</strong>，后续再持久化到磁盘。</p><img src="https://i.ibb.co/7xDHRbZ/redobuffer.png" alt="redobuffer" style="zoom:87%;" /><p>那么，何时刷盘呢？</p><p>主要有下面几个时机：</p><ul><li>MySQL正常关闭时</li><li>当redo log buffer中记录的写入量大于redo log buffer内存空间的一半时，会触发落盘</li><li>InnoDB的后台线程每隔1秒，将redo log buffer持久化到磁盘</li><li>每次事务提交时都将缓存在redo log buffer里的redo log直接持久化到磁盘（由参数<code>innodb_flush_log_at_trx_commit</code>控制）</li></ul><div class="note warning flat"><p>redo log文件写满了怎么办？</p></div><p>默认情况下，InnoDB有一个重做日志文件组redo log Group，该组由两个redo log文件组成，分别是<code>ib_logfile0</code>和<code>ib_logfile1</code>。</p><p>两个redo log file的大小是固定且一致的，以<strong>循环写</strong>的方式来工作，相当于构成了一个环形日志。</p><p>redo log是为了防止Buffer Pool中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool的脏页刷新到了磁盘中，那么redo log对应的记录也就没用了，这时候就擦除这些旧记录，以腾出空间记录新的更新操作。</p><p>因此，InnoDB用<code>write pos</code>表示redo log当前记录写到的位置，用<code>checkpoint</code>表示当前要擦除的位置。</p><img src="https://i.ibb.co/G7nd5ZR/checkpoint.webp" alt="checkpoint" style="zoom:40%;" /><p>如果<code>write pos</code>追上了<code>checkpoint</code>，就意味着<strong>redo log文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p><hr><div class="note info flat"><p><strong>binlog详解</strong></p></div><p>MySQL在完成一条更新操作后，<strong>Server层会生成一条binlog</strong>，等事务提交的时候，会将该事务执行过程中产生的所有binlog统一写入binlog文件。</p><p>binlog文件包含所有数据库表结构变更和表数据修改的记录，但不会记录查询类的操作，例如select和show操作。</p><div class="note warning flat"><p>redo log和binlog有什么区别？</p></div><ol><li><strong>适用对象不同</strong></li></ol><ul><li>binlog是Server层实现的日志，所有存储引擎都可以用</li><li>redo log是InnoDB实现的日志</li></ul><ol start="2"><li><strong>文件格式不同</strong></li></ol><ul><li>binlog有3种格式类型，分别是STATEMENT（默认）、ROW、MIXED</li><li>redo log是物理日志，格式一般为「对XXX表空间中的YYY数据页ZZZ偏移量的地方做了AAA更新」</li></ul><ol start="3"><li><strong>写入方式不同</strong></li></ol><ul><li>binlog是追加写，写满了就创建一个新文件继续写，不会覆盖以前的日志</li><li>redo log是循环写，文件大小固定，写满就从头覆盖继续写</li></ul><ol start="4"><li><strong>用途不同</strong></li></ol><ul><li>binlog用于备份恢复、主从复制</li><li>redo log用于掉电等故障恢复</li></ul><div class="note warning flat"><p>删库了如何恢复？</p></div><p>用binlog而不是redo log，因为binlog保存的是全量日志。</p><div class="note warning flat"><p>如何通过binlog实现主从复制？</p></div><p>binlog会把MySQL上的所有变化以二进制形式记录并保存在磁盘上。复制的过程就是将binlog中的数据从主库传输到从库上。</p><p>这个过程一般是<strong>异步</strong>完成的。</p><img src="https://i.ibb.co/WWsqzkS/binlog.png" alt="binlog" style="zoom:80%;" /><p>整个主从复制过程可归纳为三个阶段：</p><ul><li>写入binlog：主库写binlog日志，提交事务，并更新本地存储数据</li><li>同步binlog：主库将binlog复制到所有从库，各从库将binlog写到中继日志relay log</li><li>回放binlog：从库回放binlog，并更新自身存储引擎中的数据</li></ul><div class="note warning flat"><p>binlog何时刷盘？</p></div><p>事务执行过程中，先把日志写到binlog cache（Server层的cache）中，事务提交的时候，再把binlog cache写入到binlog文件中。</p><img src="https://i.ibb.co/fx53H7Y/binlog-Cache.png" alt="binlogCache" style="zoom:70%;" /><hr><div class="note info flat"><p><strong>两阶段提交详解</strong></p></div><p>事务提交后，redo log和binlog都需要持久化到磁盘，但可能会出现<strong>半成功</strong>的状态，导致两份日志之间的逻辑不一致。</p><p>例如，假设id&#x3D;1这行记录对应的name为Hisashi，执行<code>update user SET name = &#39;Mitsui&#39; WHERE id = 1;</code>；如果在持久化环节出现了半成功状态，则可能有两种情况：</p><ul><li>redo log写入，MySQL宕机，binlog未写入。MySQL重启之后，通过redo log将Buffer Pool中对应的name恢复到新值Mitsui，但由于binlog中没有记录这条更新语句，复制给从库后，从库中对应的name值仍然为Hisashi，与主库不一致</li><li>binlog写入，MySQL宕机，redo log未写入。MySQL重启之后，由于redo log没写，因此这个事务无效，name值仍为Hisashi，但binlog中记录了这条更新语句，因此从库中对应的name值会变为Mitsui，与主库不一致</li></ul><p>由此可见，因为redo log影响主库，binlog影响从库，两者必须在逻辑上保持同步才能保证主从数据一致。</p><p>MySQL为了避免上述问题，使用了「两阶段提交」的方案。其本质上就是一个分布式事务一致性协议，保证多个逻辑操作要么全部成功，要么全部失败，不会出现半成功的状态。</p><p>两阶段提交方案会把单个事务的提交拆分为两个阶段：<strong>「准备Prepare」</strong>和<strong>「提交Commit」</strong>，每个阶段都由协调者Coordinator和参与者Participant共同完成。</p><div class="note warning flat"><p>两阶段提交的具体过程</p></div><p>如前文所述，为了维护redo log和binlog的逻辑一致性，MySQL使用了<strong>内部XA事务</strong>，其中binlog作为协调者，存储引擎作为参与者。</p><p>当客户端执行commit语句或者MySQL自动提交时，MySQL内部会开启一个XA事务，分两阶段来完成XA事务的提交：</p><img src="https://i.ibb.co/7bsQGhT/2pc.png" alt="2pc" style="zoom:60%;" /><p>由图可知，所谓的两阶段就是将redo log的写入分为了两个步骤，中间穿插写入binlog。</p><ul><li>prepare阶段：将内部XA事务的ID写入到redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化到磁盘</li><li>commit阶段：将内部XA事务的ID写入到binlog，然后将binlog持久化到磁盘，接着调用InnoDB的提交事务接口，把redo log的状态设置为commit，该状态不需要持久化到磁盘，写到page cache就可以了。因为只要binlog写磁盘成功，即使redo log的状态仍是prepare也没关系，事务执行一样会被视作成功。</li></ul><div class="note warning flat"><p>异常重启会怎样？</p></div><p>图中的时刻A和时刻B，MySQL都有可能发生崩溃。</p><img src="https://i.ibb.co/bF6hYC5/crash.png" alt="crash" style="zoom:60%;" /><p>无论是时刻A还是时刻B系统崩溃，redo log都处于prepare状态。</p><p>MySQL重启后，会按顺序扫描redo log文件，碰到处于prepare状态的redo log，就携带XA事务ID去binlog查看是否存在此ID：</p><ul><li>若binlog中不存在该XID，说明redo log已经完成刷盘，但binlog尚未刷盘，则回滚事务。对应时刻A崩溃恢复的情况</li><li>若binlog中存在该XID，说明redo log和binlog都已完成刷盘，则提交事务。对应时刻B崩溃恢复的情况</li></ul><p>因此，<strong>两阶段提交是以binlog刷盘成功为事务提交成功的标识</strong>。</p><div class="note warning flat"><p>两阶段提交有什么问题？</p></div><p>性能很差，主要体现在两个方面：</p><ul><li>磁盘I&#x2F;O次数多：由于redo log和binlog都需要刷盘，在某些刷盘策略下，I&#x2F;O次数会很多</li><li>锁竞争激烈：两阶段提交能在「单事务」环境下保证两个日志的逻辑一致，但「多事务」环境下需要锁来保证提交的原子性，从而确保两个日志的提交顺序一致</li></ul><div class="note default flat"><p>binlog组提交</p></div><p>MySQl引入了binlog组提交机制，当有多个事务提交时，会将多个binlog刷盘操作合并成一个，从而减少磁盘I&#x2F;O次数。</p><p>引入binlog组提交机制后，prepare阶段不变，commit阶段会被拆分为三个部分：</p><ul><li>flush阶段：多个事务按照进入的顺序将binlog从cache写入文件（不刷盘）</li><li>sync阶段：对binlog文件做fsync操作（多个事务的binlog合并一次刷盘）</li><li>commit阶段：各个事务按顺序做InnoDB的commit操作</li></ul><p>三个阶段都各有自己的队列，且每个阶段都用锁来保证事务写入的顺序，第一个进入队列的事务会成为leader，leader领导所在队列的所有事务，整队的操作完成后通知队内其他事务操作已经结束。</p><p>这样的话，锁只需要对每个队列进行保护，不需要锁住提交事务的整个过程，粒度变小了，多个阶段可以并发执行。</p><div class="note default flat"><p>redo log组提交</p></div><p>MySQL 5.7及以后的版本引入了redo log的组提交机制。</p><p>在prepare阶段不再让事务各自执行redo log刷盘操作，而是推迟到组提交的flush阶段。</p><p>这个优化是将redo log的刷盘延迟到了flush阶段之中，sync阶段之前。通过延迟写redo log的方式，为redo log做了一次组写入。</p><div class="note warning flat"><p>优化MySQL磁盘高I&#x2F;O的方法有哪些？</p></div><ul><li>设置组提交的两个参数：<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>参数，延迟binlog刷盘的时机，从而减少binlog的刷盘次数。这个方法是基于「额外的故意等待」来实现的，因此可能会增加语句的响应时间，但即使MySQL进程中途挂了，也没有丢失数据的风险，因为binlog早被写入到page cache了，只要系统没有宕机，缓存在page cache里的binlog就会被持久化到磁盘。</li><li>将<code>sync_binlog</code>设置为大于 1 的值（常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li><li>将<code>innodb_flush_log_at_trx_commit</code>设置为 2。表示每次事务提交时，都只是将缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li></ul><hr><div class="note primary flat"><p><strong>总结update完整执行过程</strong></p></div><p>假设一条update语句为<code>update user SET name = &#39;Mitsui&#39; WHERE id = 1;</code>，其完整的执行过程如下：</p><ul><li>执行器调用存储引擎的接口，通过主键索引在B+树中获取id&#x3D;1这一行记录<ul><li>若该行记录所在的数据页已经在Buffer Pool中，则返回记录给执行器</li><li>否则，将对应的数据页从磁盘读入到Buffer Pool中，并返回记录给执行器</li></ul></li><li>执行器查看更新前的记录和更新后的记录是否一致<ul><li>若一致，则不进行后续的更新操作</li><li>否则，将更新前的记录和更新后的记录作为参数传给InnoDB，InnoDB会执行更新记录的操作</li></ul></li><li>事务开启，InnoDB更新记录前，首先记录对应的undo log，将旧值保存</li><li>InnoDB开始更新记录，先更新内存，同时标记为脏页，然后将记录写入redo log，完成更新</li><li>开始记录该语句对应的binlog，并保存到binlog cache；等事务提交时将事务期间所有的binlog写入到磁盘</li><li>提交事务<ul><li>prepare阶段：将redo log对应的事务状态设置为prepare，然后将redo log刷盘</li><li>commit阶段：将binlog刷盘，接着调用InnoDB的提交事务接口，将redo log状态设置为commit</li></ul></li><li>完整流程结束</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab6</title>
      <link href="/2023/08/03/MIT%206.830%20Lab6/"/>
      <url>/2023/08/03/MIT%206.830%20Lab6/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab6"><a href="#MIT-6-830-Lab6" class="headerlink" title="MIT 6.830 Lab6"></a>MIT 6.830 Lab6</h1><div class="note info flat"><p><strong>Project Intro</strong></p></div><p>这个Lab要求实现SimpleDB的日志系统，能够支持回滚和崩溃恢复。</p><div class="note default flat"><p>steal和force策略</p></div><p>在Lab 4实现事务的时候，是在假设不发生故障的情况下完成的，BufferPool采用的是no-steal&#x2F;force的策略，现在考虑到可能会发生的故障或者数据丢失情况，要将策略换成steal&#x2F;no-force。两者的区别如下：</p><ul><li><p>(no) steal：是否允许一个uncommitted的事务将修改更新到磁盘中。</p><p>若是steal策略，则磁盘上可能就包含uncommitted的数据，因此系统需要记录undo log，当事务发生abort时进行rollback；</p><p>若是no-steal策略，则磁盘上不可能存在uncommitted的数据，因此无需记录undo log。</p></li><li><p>(no) force：是否在事务committed之后立即持久化到磁盘。</p><p>若是force策略，事务在committed后会将所有更新立即持久化到磁盘，这样会导致磁盘发生很多小的写操作；</p><p>若是no-force策略，事务在committed后不会立即将更新持久化到磁盘，这样可以降低磁盘的写次数，但如果发生crash，那么未能持久化到磁盘的committed数据就会丢失，因此需要记录undo log，在系统重启时进行前滚roll forward。</p></li></ul><div class="note default flat"><p>undo log和redo log</p></div><p>为了支持steal&#x2F;no-force策略，需要维护一个日志系统。</p><p>在SimpleDB中，undo log和redo log是合在一起的，都是update类型的日志。</p><p>对于redo log，其会记录事务操作的变化，在每次将数据页写入磁盘前用<code>logWrite()</code>方法来记录变化。这样，对于这些脏页，即使故障丢失了，也可以通过事务ID来判断其是否已经提交。若已提交，则重启时根据日志的内容即可恢复。</p><p>对于undo log，采用的方法是在Heap Page中保存一份旧数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] oldData;</span><br></pre></td></tr></table></figure><p>事务提交时，对旧数据进行更新。当新事务回滚时，由于采用的是steal策略，脏页可能在页面淘汰时就已经写入磁盘了，因此可利用before image，即oldData（上一次成功事务的数据），就可以恢复到此次事务开始前的状态，实现事务的回滚。</p><div class="note default flat"><p>日志格式和checkpoint</p></div><p>根据Lab文档，可知SimpleDB的日志共有5种：ABORT、COMMIT、UPDATE、BEGIN、CHECKPOINT，分别用来记录事务失败、事务提交、写入磁盘前的脏页、事务开始、检测点五类事件，这些格式的日志都记在一个文件中，通用格式如下：</p><p><img src="https://i.ibb.co/bRVKL0N/DBlog.png" alt="log"></p><p>ABORT、COMMIT、BEGIN这三种日志中间的content部分是空的；</p><p>UPDATE的日志由两部分组成，即before image和after image，分别记录修改前和修改后的日志。事务提交失败进行回滚时会用before image，事务提交成功但数据丢失会用after image；</p><p>CHECKPOINT日志主要记录在检测点处活跃的事务数，以及每个活跃事务的ID和第一条日志记录的偏移量；在崩溃恢复时，checkpoint前的修改是已经写入磁盘的，因此只需要从checkpoint往后读，根据日志记录进行数据恢复即可。</p><div class="note success flat"><p><strong>roll back</strong></p></div><p>roll back是undo log完成的事，即提供上一个版本的快照，在回滚时将上一个版本的数据写回磁盘，思路如下：</p><ul><li>根据<code>tidToFirstLogRecord</code>获取该事务第一条记录的位置</li><li>移动到日志开始的地方</li><li>根据日志格式读取记录，读到update格式的记录时根据事务ID判断是否为要修改的日志，若是，则写before image</li><li>若是checkpoint日志，则直接跳过</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionId tid)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchElementException, IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Database.getBufferPool()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            preAppend();</span><br><span class="line">            <span class="comment">// some code goes here</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">tidId</span> <span class="operator">=</span> tid.getId();</span><br><span class="line">            rollback(tidId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(Long tidId)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">begin</span> <span class="operator">=</span> tidToFirstLogRecord.get(tidId);</span><br><span class="line">    raf.seek(begin);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">            <span class="type">long</span> <span class="variable">curId</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">            <span class="keyword">if</span> (curId != tidId)&#123;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">3</span>)&#123;</span><br><span class="line">                    readPageData(raf);</span><br><span class="line">                    readPageData(raf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> readPageData(raf);</span><br><span class="line">                    <span class="type">Page</span> <span class="variable">after</span> <span class="operator">=</span> readPageData(raf);</span><br><span class="line">                    <span class="type">DbFile</span> <span class="variable">dbFile</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(before.getId().getTableId());</span><br><span class="line">                    dbFile.writePage(before);</span><br><span class="line">                    Database.getBufferPool().removePage(after.getId());</span><br><span class="line">                    raf.seek(raf.getFilePointer() + <span class="number">8</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            raf.seek(raf.getFilePointer() + <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>recovery</strong></p></div><p>recovery是redo log要完成的任务。实现思路如下：</p><p>从日志文件中，可以获取到checkpoint所在的位置。然后对checkpoint后面的日志记录进行读取并恢复数据。</p><ul><li>对于未提交的事务，使用before image进行恢复</li><li>对于已提交的事务，使用after image进行恢复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Database.getBufferPool()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// some code goes here</span></span><br><span class="line">            Map&lt;Long, List&lt;Page[]&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            raf.seek(<span class="number">0</span>);</span><br><span class="line">            print();</span><br><span class="line">            <span class="type">long</span> <span class="variable">checkPoint</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">            <span class="keyword">if</span> (checkPoint != -<span class="number">1</span>)&#123;</span><br><span class="line">                Map&lt;Long, Long&gt; pos = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                raf.seek(checkPoint);</span><br><span class="line">                raf.seek(raf.getFilePointer() + <span class="number">12</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">curId</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">                    <span class="type">long</span> <span class="variable">off</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">                    pos.put(curId, off);</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Long i : pos.keySet())&#123;</span><br><span class="line">                    raf.seek(pos.get(i));</span><br><span class="line">                    recoverSearch(raf, map);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(raf.getFilePointer() + <span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">                recoverSearch(raf, map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Long tid : map.keySet())&#123;</span><br><span class="line">                Page[] pages = map.get(tid).get(<span class="number">0</span>);</span><br><span class="line">                <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> pages[<span class="number">0</span>];</span><br><span class="line">                <span class="type">DbFile</span> <span class="variable">dbFile</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(before.getId().getTableId());</span><br><span class="line">                dbFile.writePage(before);</span><br><span class="line">            &#125;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverSearch</span><span class="params">(RandomAccessFile raf, Map&lt;Long, List&lt;Page[]&gt;&gt; map)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">            <span class="type">long</span> <span class="variable">curId</span> <span class="operator">=</span> raf.readLong();</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(curId))&#123;</span><br><span class="line">                    map.put(curId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> readPageData(raf);</span><br><span class="line">                <span class="type">Page</span> <span class="variable">after</span> <span class="operator">=</span> readPageData(raf);</span><br><span class="line">                Page[] pages = <span class="keyword">new</span> <span class="title class_">Page</span>[<span class="number">2</span>];</span><br><span class="line">                pages[<span class="number">0</span>] = before;</span><br><span class="line">                pages[<span class="number">1</span>] = after;</span><br><span class="line">                map.get(curId).add(pages);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span> &amp;&amp; map.containsKey(curId))&#123;</span><br><span class="line">                Page[] pages = map.get(curId).get(map.get(curId).size() - <span class="number">1</span>);</span><br><span class="line">                <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> pages[<span class="number">0</span>];</span><br><span class="line">                <span class="type">Page</span> <span class="variable">after</span> <span class="operator">=</span> pages[<span class="number">1</span>];</span><br><span class="line">                <span class="type">DbFile</span> <span class="variable">dbFile</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(before.getId().getTableId());</span><br><span class="line">                dbFile.writePage(after);</span><br><span class="line">                map.remove(curId);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span> &amp;&amp; map.containsKey(curId))&#123;</span><br><span class="line">                Page[] pages = map.get(curId).get(<span class="number">0</span>);</span><br><span class="line">                <span class="type">Page</span> <span class="variable">before</span> <span class="operator">=</span> pages[<span class="number">0</span>];</span><br><span class="line">                <span class="type">Page</span> <span class="variable">after</span> <span class="operator">=</span> pages[<span class="number">1</span>];</span><br><span class="line">                <span class="type">DbFile</span> <span class="variable">dbFile</span> <span class="operator">=</span> Database.getCatalog().getDatabaseFile(before.getId().getTableId());</span><br><span class="line">                dbFile.writePage(before);</span><br><span class="line">                map.remove(curId);</span><br><span class="line">            &#125;</span><br><span class="line">            raf.seek(raf.getFilePointer() + <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab5</title>
      <link href="/2023/08/03/MIT%206.830%20Lab5/"/>
      <url>/2023/08/03/MIT%206.830%20Lab5/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab5"><a href="#MIT-6-830-Lab5" class="headerlink" title="MIT 6.830 Lab5"></a>MIT 6.830 Lab5</h1><div class="note info flat"><p><strong>Project Intro</strong></p></div><p>这个Lab要求实现SimpleDB所用的B+树索引结构，包括对B+树的增删查操作。</p><div class="note success flat"><p><strong>Search</strong></p></div><p>给定一个field和一个page，要从这个page向下递归找到tuple所在的叶子节点。</p><p>具体的实现思路为：</p><ul><li>获取数据页的类型</li><li>判断该数据页是否为叶子节点，若是则结束递归，返回结果</li><li>若不是则说明该页为非叶子节点，将页面进行类型转换</li><li>获取非叶子节点索引的迭代器</li><li>对非叶子节点的entry进行迭代，若field为空，则直接找到最左的叶子节点即可</li><li>找到第一个大于等于field的entry，然后递归其左子节点</li><li>若到了最后一个页面，则递归其右子节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BTreeLeafPage <span class="title function_">findLeafPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages, BTreePageId pid, Permissions perm,Field f)</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="keyword">if</span> (pid.pgcateg() == BTreePageId.LEAF)&#123;</span><br><span class="line">        <span class="type">BTreeLeafPage</span> <span class="variable">page</span> <span class="operator">=</span> (BTreeLeafPage) getPage(tid, dirtypages, pid, perm);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">page</span> <span class="operator">=</span> (BTreeInternalPage) getPage(tid, dirtypages, pid, perm);</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; iterator = page.iterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext())&#123;</span><br><span class="line">            next = iterator.next();</span><br><span class="line">            <span class="keyword">return</span> findLeafPage(tid, dirtypages, next.getLeftChild(), perm, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        next = iterator.next();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">        <span class="keyword">if</span> (f.compare(Op.LESS_THAN_OR_EQ, key))&#123;</span><br><span class="line">            <span class="keyword">return</span> findLeafPage(tid, dirtypages, next.getLeftChild(), perm, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> findLeafPage(tid, dirtypages, next.getRightChild(), perm, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTreeLeafPage <span class="title function_">findLeafPage</span><span class="params">(TransactionId tid, BTreePageId pid,</span></span><br><span class="line"><span class="params">                           Field f)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="keyword">return</span> findLeafPage(tid, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), pid, Permissions.READ_ONLY, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>Insert</strong></p></div><p>在对B+树作插入节点的操作时，需要考虑slot是否已满。若已满，则要分裂当前slot中的节点，具体地，可分为分裂非叶子节点和分裂叶子节点两种情况。</p><div class="note default flat"><p>分裂叶子节点</p></div><p>思路为：</p><ul><li>新建一个leaf Page，作为新的页面</li><li>将满页面的entry复制到新页面中，边复制边删除</li><li>检查之前的满页面是否有右兄弟，若有则更新指针</li><li>更新脏页</li><li>更新兄弟指针</li><li>找出父节点并创建entry进行插入，最后更新脏页</li><li>根据field找出要插入的页面并返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BTreeLeafPage <span class="title function_">splitLeafPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages, BTreeLeafPage page, Field field)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> page.getNumTuples()/<span class="number">2</span>;</span><br><span class="line">    <span class="type">BTreeLeafPage</span> <span class="variable">newPage</span> <span class="operator">=</span> (BTreeLeafPage) getEmptyPage(tid, dirtypages, BTreePageId.LEAF);</span><br><span class="line">    Iterator&lt;Tuple&gt; iterator = page.reverseIterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext() &amp;&amp; mid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        page.deleteTuple(next);</span><br><span class="line">        newPage.insertTuple(next);</span><br><span class="line">        mid--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">parentPage</span> <span class="operator">=</span> getParentWithEmptySlots(tid, dirtypages, page.getParentId(), field);</span><br><span class="line">    <span class="keyword">assert</span> tuple != <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">insertEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(tuple.getField(keyField), page.getId(), newPage.getId());</span><br><span class="line">    parentPage.insertEntry(insertEntry);</span><br><span class="line">    <span class="keyword">if</span> (page.getRightSiblingId() != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">BTreeLeafPage</span> <span class="variable">right</span> <span class="operator">=</span> (BTreeLeafPage) getPage(tid, dirtypages, page.getRightSiblingId(), Permissions.READ_WRITE);</span><br><span class="line">        right.setLeftSiblingId(newPage.getId());</span><br><span class="line">        dirtypages.put(right.getId(), right);</span><br><span class="line">    &#125;</span><br><span class="line">    newPage.setRightSiblingId(page.getRightSiblingId());</span><br><span class="line">    newPage.setLeftSiblingId(page.getId());</span><br><span class="line">    page.setRightSiblingId(newPage.getId());</span><br><span class="line">    page.setParentId(parentPage.getId());</span><br><span class="line">    newPage.setParentId(parentPage.getId());</span><br><span class="line">    dirtypages.put(parentPage.getId(), parentPage);</span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    <span class="keyword">if</span> (tuple.getField(keyField).compare(Op.GREATER_THAN_OR_EQ, field))&#123;</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>分裂非叶子节点</p></div><p>思路为：</p><ul><li>新建一个internal Page，作为新页面</li><li>将满页面的entry复制到新页面，边复制边删除</li><li>将中间节点挤出去</li><li>更新脏页</li><li>更新左右孩子指针</li><li>更新左右页面的孩子指针</li><li>根据中间节点获取父节点，将tuple插入到父节点中，并更新脏页和指针</li><li>根据field找到要插入的页面并返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BTreeInternalPage <span class="title function_">splitInternalPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                                           BTreeInternalPage page, Field field)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> page.getNumEntries()/<span class="number">2</span>;</span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">newPage</span> <span class="operator">=</span> (BTreeInternalPage) getEmptyPage(tid, dirtypages, BTreePageId.INTERNAL);</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; iterator = page.reverseIterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext() &amp;&amp; mid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">BTreeEntry</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        page.deleteKeyAndRightChild(next);</span><br><span class="line">        newPage.insertEntry(next);</span><br><span class="line">        mid--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">tuple</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    page.deleteKeyAndRightChild(tuple);</span><br><span class="line">    tuple.setLeftChild(page.getId());</span><br><span class="line">    tuple.setRightChild(newPage.getId());</span><br><span class="line">    updateParentPointers(tid, dirtypages, newPage);</span><br><span class="line">    <span class="type">BTreeInternalPage</span> <span class="variable">parentPage</span> <span class="operator">=</span> getParentWithEmptySlots(tid, dirtypages, page.getParentId(), field);</span><br><span class="line">    parentPage.insertEntry(tuple);</span><br><span class="line">    page.setParentId(parentPage.getId());</span><br><span class="line">    newPage.setParentId(parentPage.getId());</span><br><span class="line">    dirtypages.put(parentPage.getId(), parentPage);</span><br><span class="line">    dirtypages.put(newPage.getId(), newPage);</span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    <span class="keyword">if</span> (tuple.getKey().compare(Op.GREATER_THAN_OR_EQ, field))&#123;</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>Delete</strong></p></div><p>删除操作涉及到后续slot中的节点分配，最好是让所有slot的空间分配较为合理，既不会太空也不会很快达到分裂的程度。</p><p>因此有两种重新分配的策略，一种是两个页面的元组数量求平均，另一种是一个页面留下总容量的一半，这里采用前者来实现。</p><div class="note default flat"><p>leaf Page的steal</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stealFromLeafPage</span><span class="params">(BTreeLeafPage page, BTreeLeafPage sibling,</span></span><br><span class="line"><span class="params">                              BTreeInternalPage parent, BTreeEntry entry, <span class="type">boolean</span> isRightSibling)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (page.getNumTuples() + sibling.getNumTuples()) / <span class="number">2</span> - page.getNumTuples();</span><br><span class="line">    Iterator&lt;Tuple&gt; iterator = isRightSibling ? sibling.iterator() : sibling.reverseIterator();</span><br><span class="line">    <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        next = iterator.next();</span><br><span class="line">        sibling.deleteTuple(next);</span><br><span class="line">        page.insertTuple(next);</span><br><span class="line">        mid--;</span><br><span class="line">    &#125;</span><br><span class="line">    entry.setKey(next.getField(keyField));</span><br><span class="line">    parent.updateEntry(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>internal Page的steal</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stealFromLeftInternalPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                                      BTreeInternalPage page, BTreeInternalPage leftSibling, BTreeInternalPage parent, BTreeEntry parentEntry)</span> </span><br><span class="line">   <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (page.getNumEntries() + leftSibling.getNumEntries()) / <span class="number">2</span> - page.getNumEntries();</span><br><span class="line">    <span class="keyword">if</span> (mid &lt;= <span class="number">0</span>)   <span class="keyword">return</span>;</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; entryIterator = leftSibling.reverseIterator();</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; iterator = page.iterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">last</span> <span class="operator">=</span> entryIterator.next();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">first</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">leftChild</span> <span class="operator">=</span> last.getRightChild();</span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">rightChild</span> <span class="operator">=</span> first.getLeftChild();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">insertEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(parentEntry.getKey(), leftChild, rightChild);</span><br><span class="line">    page.insertEntry(insertEntry);</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">1</span>)&#123;</span><br><span class="line">        leftSibling.deleteKeyAndRightChild(last);</span><br><span class="line">        parentEntry.setKey(last.getKey());</span><br><span class="line">        parent.updateEntry(parentEntry);</span><br><span class="line">        updateParentPointers(tid, dirtypages, page);</span><br><span class="line">        dirtypages.put(parent.getId(), parent);</span><br><span class="line">        dirtypages.put(page.getId(), page);</span><br><span class="line">        dirtypages.put(leftSibling.getId(), leftSibling);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        leftSibling.deleteKeyAndRightChild(last);</span><br><span class="line">        page.insertEntry(last);</span><br><span class="line">        mid -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (mid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">BTreeEntry</span> <span class="variable">next</span> <span class="operator">=</span> entryIterator.next();</span><br><span class="line">        leftSibling.deleteKeyAndRightChild(next);</span><br><span class="line">        page.insertEntry(next);</span><br><span class="line">        mid--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">tuple</span> <span class="operator">=</span> entryIterator.next();</span><br><span class="line">    leftSibling.deleteKeyAndRightChild(tuple);</span><br><span class="line">    parentEntry.setKey(tuple.getKey());</span><br><span class="line">    parent.updateEntry(parentEntry);</span><br><span class="line">    updateParentPointers(tid, dirtypages, page);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    dirtypages.put(leftSibling.getId(), leftSibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stealFromRightInternalPage</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                                       BTreeInternalPage page, BTreeInternalPage rightSibling, BTreeInternalPage parent, BTreeEntry parentEntry)</span> </span><br><span class="line">  <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (page.getNumEntries() + rightSibling.getNumEntries()) / <span class="number">2</span> - page.getNumEntries();</span><br><span class="line">    <span class="keyword">if</span> (mid &lt;= <span class="number">0</span>)   <span class="keyword">return</span>;</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; entryIterator = rightSibling.iterator();</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; iterator = page.reverseIterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">first</span> <span class="operator">=</span> entryIterator.next();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">last</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">rightChild</span> <span class="operator">=</span> first.getLeftChild();</span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">leftChild</span> <span class="operator">=</span> last.getRightChild();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">insertEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(parentEntry.getKey(), leftChild, rightChild);</span><br><span class="line">    page.insertEntry(insertEntry);</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">1</span>)&#123;</span><br><span class="line">        rightSibling.deleteKeyAndLeftChild(first);</span><br><span class="line">        parentEntry.setKey(first.getKey());</span><br><span class="line">        parent.updateEntry(parentEntry);</span><br><span class="line">        updateParentPointers(tid, dirtypages, page);</span><br><span class="line">        dirtypages.put(parent.getId(), parent);</span><br><span class="line">        dirtypages.put(page.getId(), page);</span><br><span class="line">        dirtypages.put(rightSibling.getId(), rightSibling);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rightSibling.deleteKeyAndRightChild(first);</span><br><span class="line">        page.insertEntry(first);</span><br><span class="line">        mid -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (mid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">BTreeEntry</span> <span class="variable">next</span> <span class="operator">=</span> entryIterator.next();</span><br><span class="line">        rightSibling.deleteKeyAndLeftChild(next);</span><br><span class="line">        page.insertEntry(next);</span><br><span class="line">        mid--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">tuple</span> <span class="operator">=</span> entryIterator.next();</span><br><span class="line">    rightSibling.deleteKeyAndLeftChild(tuple);</span><br><span class="line">    parentEntry.setKey(tuple.getKey());</span><br><span class="line">    parent.updateEntry(parentEntry);</span><br><span class="line">    updateParentPointers(tid, dirtypages, page);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">    dirtypages.put(page.getId(), page);</span><br><span class="line">    dirtypages.put(rightSibling.getId(), rightSibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>Merge Pages</strong></p></div><p>页面的合并需要注意指针的更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeLeafPages</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                           BTreeLeafPage leftPage, BTreeLeafPage rightPage, BTreeInternalPage parent, BTreeEntry parentEntry)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    Iterator&lt;Tuple&gt; iterator = rightPage.iterator();</span><br><span class="line">    leftPage.setRightSiblingId(rightPage.getRightSiblingId());</span><br><span class="line">    <span class="keyword">if</span> (rightPage.getRightSiblingId() != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">BTreeLeafPage</span> <span class="variable">leafPage</span> <span class="operator">=</span> (BTreeLeafPage) getPage(tid, dirtypages, rightPage.getRightSiblingId(), Permissions.READ_WRITE);</span><br><span class="line">        leafPage.setLeftSiblingId(leafPage.getId());</span><br><span class="line">        dirtypages.put(leafPage.getId(), leafPage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        rightPage.deleteTuple(next);</span><br><span class="line">        leftPage.insertTuple(next);</span><br><span class="line">    &#125;</span><br><span class="line">    setEmptyPage(tid, dirtypages, rightPage.getId().getPageNumber());</span><br><span class="line">    deleteParentEntry(tid, dirtypages, leftPage, parent, parentEntry);</span><br><span class="line">    dirtypages.remove(rightPage.getId());</span><br><span class="line">    dirtypages.put(leftPage.getId(), leftPage);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeInternalPages</span><span class="params">(TransactionId tid, Map&lt;PageId, Page&gt; dirtypages,</span></span><br><span class="line"><span class="params">                               BTreeInternalPage leftPage, BTreeInternalPage rightPage, BTreeInternalPage  parent, BTreeEntry parentEntry)</span></span><br><span class="line">        <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; rightIterator = rightPage.iterator();</span><br><span class="line">    Iterator&lt;BTreeEntry&gt; leftIterator = leftPage.reverseIterator();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">first</span> <span class="operator">=</span> rightIterator.next();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">last</span> <span class="operator">=</span>leftIterator.next();</span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">rightChild</span> <span class="operator">=</span> first.getLeftChild();</span><br><span class="line">    <span class="type">BTreePageId</span> <span class="variable">leftChild</span> <span class="operator">=</span> last.getRightChild();</span><br><span class="line">    <span class="type">BTreeEntry</span> <span class="variable">insertEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BTreeEntry</span>(parentEntry.getKey(), leftChild, rightChild);</span><br><span class="line">    leftPage.insertEntry(insertEntry);</span><br><span class="line">    rightPage.deleteKeyAndLeftChild(first);</span><br><span class="line">    leftPage.insertEntry(first);</span><br><span class="line">    <span class="keyword">while</span> (rightIterator.hasNext())&#123;</span><br><span class="line">        <span class="type">BTreeEntry</span> <span class="variable">next</span> <span class="operator">=</span> rightIterator.next();</span><br><span class="line">        rightPage.deleteKeyAndLeftChild(next);</span><br><span class="line">        leftPage.insertEntry(next);</span><br><span class="line">    &#125;</span><br><span class="line">    updateParentPointers(tid, dirtypages, leftPage);</span><br><span class="line">    setEmptyPage(tid, dirtypages, rightPage.getId().getPageNumber());</span><br><span class="line">    deleteParentEntry(tid, dirtypages, leftPage, parent, parentEntry);</span><br><span class="line">    dirtypages.remove(rightPage.getId());</span><br><span class="line">    dirtypages.put(leftPage.getId(), leftPage);</span><br><span class="line">    dirtypages.put(parent.getId(), parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab4</title>
      <link href="/2023/08/03/MIT%206.830%20Lab4/"/>
      <url>/2023/08/03/MIT%206.830%20Lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab4"><a href="#MIT-6-830-Lab4" class="headerlink" title="MIT 6.830 Lab4"></a>MIT 6.830 Lab4</h1><div class="note info flat"><p><strong>Project Intro</strong></p></div><p>这个Lab需要实现数据库的事务处理和并发相关的功能。</p><p>事务是数据库中一组原子操作的集合，具有<strong>ACID</strong>四个特性。</p><p>数据库一般采用锁来实现事务的这些特性，具体可分为共享锁和互斥锁：</p><ul><li>若一个事务要对一个对象进行读操作，则必须持有其的共享锁</li><li>若一个事务要对一个对象进行写操作，则必须持有其的互斥锁</li><li>多个事务可以同时持有一个对象的共享锁，而同一时间只有一个事务可以持有某对象的互斥锁</li><li>若只有一个事务拥有某对象的共享锁，则该锁自动升级为互斥锁</li></ul><p>上面的对象根据粒度的不同而不同，可以是一个表，一个页，一个元组；在这个Lab中，只考虑页级锁。</p><p>同时在申请锁的时候，如果一个事务需要的锁不能立即获得，那么它就需要进入阻塞状态，直到被分配到所需要的锁，数据库系统中一般会有一个专门管理锁的分配和释放的组件，可以称之为<code>LockManager</code>。</p><p>另外，要实现ACID，必须遵循两阶段锁协议（Two Phase Locking，2PL）。</p><blockquote><p>增长阶段：事务可以获得锁，但不能释放锁；</p><p>缩减阶段：事务可以释放锁，但不能获得新锁。</p><p>相对地，<strong>严格两阶段锁协议</strong>（S2PL）对于锁的封锁要求不仅只在两个阶段，还要求事务持有的所有互斥锁必须在事务commit后才可释放。这样能保证执行过程中不出现死锁的情况。</p><p>另外，增长阶段共享锁可以升级为互斥锁，缩减阶段互斥锁可以降级为共享锁。</p></blockquote><div class="note success flat"><p><strong>LockManager</strong></p></div><p>LockManager的详细实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Lock&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LockManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">acquireLock</span><span class="params">(TransactionId tid, PageId pageId, Permissions permissions)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pid</span> <span class="operator">=</span> pageId.getPageNumber();</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(permissions, tid);</span><br><span class="line">        List&lt;Lock&gt; lockList = map.get(pid);</span><br><span class="line">        <span class="keyword">if</span>(lockList == <span class="literal">null</span>)&#123;</span><br><span class="line">            lockList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            lockList.add(lock);</span><br><span class="line">            map.put(pid, lockList);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个事务占用锁</span></span><br><span class="line">        <span class="keyword">if</span>(lockList.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">firstLock</span> <span class="operator">=</span> lockList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(firstLock.getTransactionId().equals(tid))&#123;</span><br><span class="line">                <span class="keyword">if</span>(firstLock.getPermissions().equals(Permissions.READ_ONLY) &amp;&amp; lock.getPermissions().equals(Permissions.READ_WRITE))&#123;</span><br><span class="line">                    <span class="comment">// 升级锁</span></span><br><span class="line">                    firstLock.setPermissions(Permissions.READ_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(firstLock.getPermissions().equals(Permissions.READ_ONLY) &amp;&amp; lock.getPermissions().equals(Permissions.READ_ONLY))&#123;</span><br><span class="line">                    lockList.add(lock);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个事务则说明lockList中均为共享锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock.getPermissions().equals(Permissions.READ_WRITE))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同一个事务重复获取读锁</span></span><br><span class="line">        <span class="keyword">for</span> (Lock lock1 : lockList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock1.getTransactionId().equals(tid))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lockList.add(lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(TransactionId tid, PageId pageId)</span>&#123;</span><br><span class="line">        List&lt;Lock&gt; lockList = map.get(pageId.getPageNumber());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;lockList.size(); i++)&#123;</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> lockList.get(i);</span><br><span class="line">            <span class="keyword">if</span>(lock.getTransactionId().equals(tid))&#123;</span><br><span class="line">                lockList.remove(lock);</span><br><span class="line">                <span class="keyword">if</span>(lockList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(pageId.getPageNumber());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseAllLock</span><span class="params">(TransactionId tid)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer k : map.keySet())&#123;</span><br><span class="line">            List&lt;Lock&gt; lockList = map.get(k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;lockList.size(); i++)&#123;</span><br><span class="line">                <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> lockList.get(i);</span><br><span class="line">                <span class="keyword">if</span>(lock.getTransactionId().equals(tid))&#123;</span><br><span class="line">                    lockList.remove(lock);</span><br><span class="line">                    <span class="keyword">if</span>(lockList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        map.remove(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">holdLock</span><span class="params">(TransactionId tid, PageId pageId)</span>&#123;</span><br><span class="line">        List&lt;Lock&gt; lockList = map.get(pageId.getPageNumber());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;lockList.size(); i++)&#123;</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> lockList.get(i);</span><br><span class="line">            <span class="keyword">if</span>(lock.getTransactionId().equals(tid))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在原来的BufferPool代码上稍作修改，完善各个函数对页操作的加锁开锁步骤。例如，在<code>getPage()</code>时先获取当前Page的锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lockAcquired = lockManager.acquireLock(tid, pid, perm);</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>锁的生命周期</strong></p></div><p>这一项主要是注意使用<code>getPage()</code>方法时，申请的锁类型是否正确，即<code>READ_WRITE</code>和<code>READ_ONLY</code>的选择。</p><div class="note success flat"><p><strong>实现No Steal</strong></p></div><p>No Steal指的是在rollback的情况下，不允许从脏页中「steal」数据，即在事务提交时才将脏页写入磁盘或者事务中断时将脏页恢复成磁盘文件原来的样子。</p><p>在之前的Lab中，实现了基于LRU的页置换算法，但并没有区分脏页。现在不能像之前一样淘汰这些脏页。</p><p>当BufferPool满时，会调用<code>evictPage()</code>。那么，就从现在LRU的缓存中倒序遍历，淘汰第一个「脏标记」为空的页即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">evictPage</span><span class="params">()</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">value</span> <span class="operator">=</span> lruCache.getTail().prev.value;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value.isDirty() != <span class="literal">null</span>)&#123;</span><br><span class="line">        findNotDirty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruCache.discard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findNotDirty</span><span class="params">()</span> <span class="keyword">throws</span> DbException&#123;</span><br><span class="line">    LRUCache&lt;PageId, Page&gt;.<span class="type">DLinkedNode</span> <span class="variable">head</span> <span class="operator">=</span> lruCache.getHead();</span><br><span class="line">    LRUCache&lt;PageId, Page&gt;.<span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> lruCache.getTail();</span><br><span class="line">    tail = tail.prev;</span><br><span class="line">    <span class="keyword">while</span> (head != tail)&#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">value</span> <span class="operator">=</span> tail.value;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value.isDirty() == <span class="literal">null</span>)&#123;</span><br><span class="line">            lruCache.remove(tail);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;All dirty pages&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>实现Transaction</strong></p></div><p>每个事务都有一个Transaction对象，SimpleDB用TransactionId来唯一标识一个事务。</p><p>事务开始之前，会创建一个Transaction对象，TransactionId此时也会自动获取。</p><p>当事务完成后，调用<code>transactionComplete</code>完成收尾处理工作。其会根据事务执行的成功与否分别进行处理，若事务执行成功，则将事务ID对应的脏页写入到磁盘中，若事务执行失败，则将事务ID对应的脏页淘汰出BufferPool并从磁盘中获取原来的数据页。</p><p>最后，释放该事务在所有数据页中加的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionComplete</span><span class="params">(TransactionId tid, <span class="type">boolean</span> commit)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1|lab2</span></span><br><span class="line">    <span class="keyword">if</span> (commit)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newFlushPages(tid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rollback(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    lockManager.releaseAllLock(tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>死锁</strong></p></div><p>死锁的产生情况：</p><ul><li>若有两个事务t0和t1，两个数据页p0和p1，t0有了p1的写锁后申请p0的写锁，t1有了p0的写锁后申请p1的写锁，发生死锁</li><li>若多个事务t0，t1，t2，t3都同时对数据页p0加了读锁，然后每个事务都要申请写锁，发生死锁</li></ul><p>解决方案：</p><ul><li>超时处理。对每个事务设置一个获取锁的时限，若超过该时限，事务仍未获得锁，则认为死锁，将该事务中断</li><li>循环等待图检测。建立事务等待的关系图，若该图中出现了环，则有死锁发生。在加锁前就进行检测，若此次申请会造成环，则终止该事务。</li></ul><p>实现时采用了较为简单的第一种方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!lockAcquired)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span>(now - start &gt; timeout)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionAbortedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lockAcquired = lockManager.acquireLock(tid, pid, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab3</title>
      <link href="/2023/08/03/MIT%206.830%20Lab3/"/>
      <url>/2023/08/03/MIT%206.830%20Lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab3"><a href="#MIT-6-830-Lab3" class="headerlink" title="MIT 6.830 Lab3"></a>MIT 6.830 Lab3</h1><div class="note info flat"><p><strong>Project Intro</strong></p></div><p>Lab 3需要实现一个基于cost的查询优化模块，其主要作用是在SimpleDB处理Join等SQL语句时可以对输入的SQL查询进行优化；这里的cost会根据SimpleDB数据表中的统计信息计算得出，统计信息则来源于之前Lab中实现的存储模块。</p><p>整个查询优化模块的架构如下：</p><img src="https://i.ibb.co/6P6p1pP/lab3-controlflow.png" alt="controlFlow" style="zoom:50%;" /><p>首先需要实现<code>TableStats</code>这个类来计算每个数据表的统计信息，然后进一步实现<strong>Join操作的查询估计</strong>和<strong>嵌套Join的优化</strong>这两个核心功能。</p><div class="note success flat"><p><strong>数据表统计信息计算（Exercise 1-2）</strong></p></div><p>首先要实现统计直方图类<code>IntHistogram</code>和<code>StringHistogram</code>，用来统计某一列的数据分布情况，然后用每个列的统计数据组成整个数据表的统计信息，即<code>TableStats</code>。</p><div class="note default flat"><p>直方图类的实现</p></div><p>实现思路比较直观，假设某个属性（Field）的值是离散分布的，统计出该Field的各值所对应的元组个数，并形成一张直方图，如下：</p><img src="https://i.ibb.co/VVNdpVK/lab3-hist.png" alt="hist" style="zoom:50%;" /><p>然后，在执行Join操作的时候，通常会用Filter对元组进行过滤，Filter本身又是可以两两分组的（大于和小于等于，小于和大于等于，等于和不等于），每一组的数据比例总和都为1。因此只需要实现一半的Filter统计即可。</p><p>每种Filter的占比对应的面积是不同的，比如大于是分界点右边的面积，小于则是左边的面积，而等于则是在分界点所在的这一块里面用平均值来估算，比如一段对应的值有3，4，5三个，而这一段区域对应的元组数是30，那么在估计该Field值为4的元组数量的时候，就是30&#x2F;3&#x3D;10个。</p><p>实现一下<code>estimateSelectivity(Predicate.Op op, int v)</code> 这个方法就可以了，对每种不同的Op算子都计算对应的结果。具体实现时仍然把6个op算子都写了一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateSelectivity</span><span class="params">(Predicate.Op op, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binarySearch(v);</span><br><span class="line">    Gram gram;</span><br><span class="line">    gram = i != -<span class="number">1</span> ? grams[i] : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (op == Predicate.Op.EQUALS)&#123;</span><br><span class="line">        <span class="keyword">if</span> (gram != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (gram.h / gram.w) / (<span class="type">double</span>) ntups;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Predicate.Op.GREATER_THAN)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; min)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gram != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">add</span> <span class="operator">=</span> ((<span class="type">double</span>) gram.h / (<span class="type">double</span>) ntups) * ((gram.right - v) / gram.w);</span><br><span class="line">            res += add;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i+<span class="number">1</span>; j&lt;buckets; j++)&#123;</span><br><span class="line">                res += (<span class="type">double</span>) grams[j].h / (<span class="type">double</span>) ntups;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Predicate.Op.LESS_THAN)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt;= min)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gram != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">add</span> <span class="operator">=</span> ((<span class="type">double</span>) gram.h / (<span class="type">double</span>) ntups * (v - gram.left) / gram.w);</span><br><span class="line">            res += add;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                res += (<span class="type">double</span>) grams[j].h / (<span class="type">double</span>) ntups;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Predicate.Op.NOT_EQUALS)&#123;</span><br><span class="line">        <span class="keyword">if</span> (gram != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - (gram.h / gram.w / (<span class="type">double</span>) ntups);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Predicate.Op.GREATER_THAN_OR_EQ)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt;= min)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gram != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">add</span> <span class="operator">=</span> ((<span class="type">double</span>) gram.h * ((gram.right - v + <span class="number">1</span>) / gram.w)) / (<span class="type">double</span>) ntups;</span><br><span class="line">            res += add;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i+<span class="number">1</span>; j&lt;buckets; j++)&#123;</span><br><span class="line">                res += (<span class="type">double</span>) grams[j].h / (<span class="type">double</span>) ntups;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Predicate.Op.LESS_THAN_OR_EQ)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; min)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gram != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">add</span> <span class="operator">=</span> ((<span class="type">double</span>) gram.h / (<span class="type">double</span>) ntups) * ((v - gram.left + <span class="number">1</span>) / gram.w);</span><br><span class="line">            res += add;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                res += (<span class="type">double</span>) grams[j].h / (<span class="type">double</span>) ntups;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>TableStats实现</p></div><p>接下来就需要实现整个数据表的统计信息类<code>TableStats</code>，即给每个Field都建立一个直方图，并维护这些统计信息。</p><p>具体实现时先根据TupleDesc初始化一系列直方图，然后调用Heap File的iterator对整个表进行遍历，往直方图里填充数据。</p><div class="note success flat"><p><strong>Join查询估计（Exercise 3）</strong></p></div><p>计算每次Join的Cost和Join产生的元组数量，实现的方法分别是<code>estimateJoinCost</code>和<code>estimateJoinCardinality</code></p><ul><li><p><code>estimateJoinCost</code>用来估计一次Join操作所需要的Cost，给定一个Join操作左右两边参与的元组数量以及每次操作的cost，来计算整个Join执行一次所需要的cost。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateJoinCost</span><span class="params">(LogicalJoinNode j, <span class="type">int</span> card1, <span class="type">int</span> card2,</span></span><br><span class="line"><span class="params">                               <span class="type">double</span> cost1, <span class="type">double</span> cost2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (j <span class="keyword">instanceof</span> LogicalSubplanJoinNode) &#123;</span><br><span class="line">        <span class="comment">// A LogicalSubplanJoinNode represents a subquery.</span></span><br><span class="line">        <span class="comment">// You do not need to implement proper support for these for Lab 3.</span></span><br><span class="line">        <span class="keyword">return</span> card1 + cost1 + cost2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert your code here.</span></span><br><span class="line">        <span class="comment">// HINT: You may need to use the variable &quot;j&quot; if you implemented</span></span><br><span class="line">        <span class="comment">// a join algorithm that&#x27;s more complicated than a basic</span></span><br><span class="line">        <span class="comment">// nested-loops join.</span></span><br><span class="line">        <span class="keyword">return</span> cost1 + card1 * cost2 + card1 * card2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>estimateJoinCardinality</code> 则被用来估计Join操作产生的元组数量，这个方法实际上和前面实现的数据表统计信息有关，但是相关的调用已经给出了，因此也不需要过多写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">estimateJoinCardinality</span><span class="params">(LogicalJoinNode j, <span class="type">int</span> card1, <span class="type">int</span> card2,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> t1pkey, <span class="type">boolean</span> t2pkey, Map&lt;String, TableStats&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (j <span class="keyword">instanceof</span> LogicalSubplanJoinNode) &#123;</span><br><span class="line">        <span class="comment">// A LogicalSubplanJoinNode represents a subquery.</span></span><br><span class="line">        <span class="comment">// You do not need to implement proper support for these for Lab 3.</span></span><br><span class="line">        <span class="keyword">return</span> card1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> estimateTableJoinCardinality(j.p, j.t1Alias, j.t2Alias,</span><br><span class="line">                j.f1PureName, j.f2PureName, card1, card2, t1pkey, t2pkey,</span><br><span class="line">                stats, p.getTableAliasToIdMapping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note success flat"><p><strong>嵌套Join优化（Exercise 4）</strong></p></div><p>最后要实现Join的优化，实现的想法为：</p><p>暴力遍历所有可能的Join排列，然后分别估计它们的总Cost，然后选出总Cost最小的一组作为查询优化的结果。SimpleDB已经提供了一个方法<code>enumerateSubsets</code>来实现子集的搜索，因此只要调用这个方法，不需要再写一个对Join进行搜索的过程。</p><p>在搜索的过程中，使用一个SimpleDB提供的类<code>PlanCache</code>来存储搜索过程中的中间数据，<code>PlanCache</code>会自动排序找出最优的Join顺序，因此只需要在最后调用它的接口返回正确结果就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(</span></span><br><span class="line"><span class="params">        Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">        Map&lt;String, Double&gt; filterSelectivities, <span class="type">boolean</span> explain)</span></span><br><span class="line">        <span class="keyword">throws</span> ParsingException &#123;</span><br><span class="line">    <span class="comment">// Not necessary for labs 1 and 2.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> joins.size();</span><br><span class="line">    <span class="type">PlanCache</span> <span class="variable">planCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlanCache</span>();</span><br><span class="line">    <span class="type">CostCard</span> <span class="variable">bestCostCard</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=size; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;LogicalJoinNode&gt; s : enumerateSubsets(joins, i))&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">bestCost</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">            bestCostCard = <span class="keyword">new</span> <span class="title class_">CostCard</span>();</span><br><span class="line">            <span class="keyword">for</span> (LogicalJoinNode logicalJoinNode : s)&#123;</span><br><span class="line">                <span class="type">CostCard</span> <span class="variable">costCard1</span> <span class="operator">=</span> computeCostAndCardOfSubplan(stats, filterSelectivities, logicalJoinNode, s, bestCost, planCache);</span><br><span class="line">                <span class="keyword">if</span> (costCard1 == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (costCard1.cost &lt; bestCost)&#123;</span><br><span class="line">                    bestCost = costCard1.cost;</span><br><span class="line">                    bestCostCard = costCard1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            planCache.addPlan(s, bestCost, bestCostCard.card, bestCostCard.plan);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (explain)&#123;</span><br><span class="line">        <span class="keyword">assert</span> bestCostCard != <span class="literal">null</span>;</span><br><span class="line">        printJoins(bestCostCard.plan, planCache, stats, filterSelectivities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> bestCostCard != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> bestCostCard.plan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络系统模式</title>
      <link href="/2023/07/28/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/28/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="I-x2F-O的阻塞-x2F-同步"><a href="#I-x2F-O的阻塞-x2F-同步" class="headerlink" title="I&#x2F;O的阻塞&#x2F;同步"></a>I&#x2F;O的阻塞&#x2F;同步</h2><div class="note info flat"><p>阻塞I&#x2F;O</p></div><p>当用户程序执行<code>read</code>，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code>才会返回。</p><div class="note info flat"><p>非阻塞I&#x2F;O</p></div><p>非阻塞的<code>read</code>请求在数据未准备好的情况下立即返回，可以继续向下执行程序，应用程序会不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序的缓冲区，<code>read</code>调用才可以获得结果。</p><p><strong>但无论read和send是阻塞还是非阻塞，都是同步调用</strong>。因为在read调用时，内核将数据从内核空间拷贝到用户空间的过程都是需要等待的，即是一个同步过程，如果拷贝效率低，那么同步等待时间长。</p><p>异步调用是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都无需等待。发起<code>aio_read</code>后，立即返回。内核自动完成数据的拷贝和准备工作，并在完成后通知应用程序，不需要应用程序主动轮询。</p><h2 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><p>select&#x2F;poll&#x2F;epoll内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p><p>在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求。</p><div class="note info flat"><p>select&#x2F;poll</p></div><p><strong>select</strong></p><p>select实现多路复用的方式是，将已连接的Socket都放到一个<strong>文件描述符集合</strong>，然后调用select函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件发生。检查的方式就是通过<strong>遍历</strong>文件描述符集合，当检查到有事件产生后，将此Socket标记为可读或者可写，接着把整个文件描述符集合拷贝回用户态里，然后用户态还需要通过遍历的方式找到可读或可写的Socket，然后再对其处理。</p><p>因此，select这种方式，需要进行<strong>2次遍历文件描述符集合</strong>，一次是在内核态中，一次是在用户态中，另外还会发生<strong>2次拷贝文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select使用固定长度的BitsMap，表示文件描述符集合，且支持的文件描述符的个数是有限制的，在Linux系统中，由内核的<code>FD_SETSIZE</code>限制，默认最大值为1024，只能监听0-1023的文件描述符。</p><p><strong>poll</strong></p><p>poll不使用BitsMap来存储文件描述符集合，而是用动态数组，以链表形式来组织，突破了select的文件描述符的个数限制，虽然仍受到系统文件描述符的限制。</p><p>但是poll和select并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的Socket集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><div class="note info flat"><p>epoll</p></div><p>如下是epoll的基础用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll通过两个方面，解决了select&#x2F;poll的问题。</p><ul><li>epoll在内核中使用<strong>红黑树来跟踪进程中所有待检测的文件描述符</strong>，把需要监控的Socket通过<code>epoll_ctl()</code>函数加入到内核中的红黑树里（红黑树的增删改时间复杂度为<code>O(logn)</code>）。而select&#x2F;poll内核里没有类似epoll红黑树这种能保存所有待检测Socket的数据结构，因此每次操作时select&#x2F;poll都需要传入整个Socket集合到内核中。epoll依靠红黑树，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll使用事件驱动机制，内核里维护了一个链表来记录就绪事件，当某个Socket有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用<code>epoll_wait()</code>函数时，只会返回有事件发生的文件描述符个数，不需要像select&#x2F;poll那样轮询扫描整个Socket集合，提高了检测效率。</li></ul><p>epoll相关的接口如下图：</p><p><img src="https://i.ibb.co/vHCdLT7/epoll.png" alt="epollInterface"></p><p>当<code>epoll_wait()</code>返回时，对于就绪事件，epoll并不是使用共享内存的方式，而是调用<code>_put_user</code>函数，将数据从内核拷贝到用户空间。</p><div class="note info flat"><p>边缘触发和水平触发</p></div><p><strong>epoll支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）。</strong></p><ul><li>边缘触发模式下，当被监控的Socket描述符上有可读事件发生时，<strong>服务器端只会从<code>epoll_wait</code>中苏醒一次</strong>，即使进程没有调用read函数从内核读取数据，也依然只苏醒一次，因此程序要保证一次性将内核缓冲区的数据读取完；</li><li>水平触发模式下，当被监控的Socket描述符上有可读事件发生时，<strong>服务器端会不断地从<code>epoll_wait</code>中苏醒，直到内核缓冲区数据被read函数读完才结束</strong>，目的是告诉我们有数据需要读取。</li></ul><p>select&#x2F;poll只有水平触发模式，epoll默认是水平触发模式，可设置为边缘触发模式。</p><h2 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>为了方便基于I&#x2F;O多路复用进行编程开发，部分开发者基于面向对象的思想，对I&#x2F;O多路复用作了一层封装，使得使用者可以不必考虑底层网络API的细节，只需要关注应用代码的编写，即Reactor模式，也叫Dispatcher模式。</p><p>I&#x2F;O多路复用监听事件，收到事件后，根据事件类型分配给某个进程&#x2F;线程。</p><p>Reactor模式主要由Reactor和处理资源池这两个核心部分组成：</p><ul><li>Reactor负责监听和分发事件，事件类型包含连接事件、读写事件</li><li>处理资源池负责处理事件，如：read-&gt;业务逻辑-&gt;send</li></ul><p>由此，理论上就有四种方案可选择：</p><ul><li>单Reactor单进程&#x2F;线程</li><li>单Reactor多进程&#x2F;线程</li><li>多Reactor单进程&#x2F;线程</li><li>多Reactor多进程&#x2F;线程</li></ul><p>其中，「多Reactor单进程&#x2F;线程」方案相比「单Reactor单进程&#x2F;线程」，既复杂又没有性能优势，没有实际应用。</p><div class="note info flat"><p>单Reactor单进程&#x2F;线程</p></div><p>在Java中，一般实现的是单Reactor单线程的方案，因为Java程序是跑在JVM这个进程上的，只是其中一个线程而已。而在C中，实现的是单Reactor单进程的方案。单Reactor单进程的方案如图所示：</p><p><img src="https://i.ibb.co/KWkvz7W/single-Reactor.png" alt="singleReactor"></p><p>进程中包含<strong>Reactor、Acceptor、Handler</strong>三个对象。</p><ul><li>Reactor对象的作用是监听和分发事件</li><li>Acceptor对象的作用是获取连接</li><li>Handler对象的作用是处理业务</li></ul><p>对象中的select、accept、read、send是系统调用函数，dispatch和业务处理是需要完成的操作。</p><p>方案详细过程为：</p><ul><li>Reactor对象通过select（I&#x2F;O多路复用接口）监听事件，收到事件后通过dispatch进行分发，具体分给Acceptor对象还是Handler对象取决于事件类型</li><li>若是建立连接的事件，则交由Acceptor对象。其通过accept方法获取连接，并创建一个Handler对象来处理后续的响应事件</li><li>若不是建立连接的事件，则交由当前连接对应的Handler对象进行响应</li><li>Handler对象通过read-&gt;业务处理-&gt;send的流程完成整个方案。</li></ul><p>由于全部工作都在同一个进程内完成，因此「单Reactor单进程」的方案不需要考虑进程间通信，也不用担心多进程竞争。</p><p>但是：</p><ul><li>因为只有一个进程，无法充分利用多核CPU的性能</li><li>Handler在处理业务时，整个进程是无法处理其他连接的事件的，若业务耗时较长，就会导致响应的延迟较大</li></ul><p>综上，「单Reactor单进程」的方案<strong>不适用于计算密集型的场景，只适用于业务处理较快速的场景</strong>。</p><div class="note info flat"><p>单Reactor多进程&#x2F;线程</p></div><p>为了解决「单Reactor单进程&#x2F;线程」的缺点，提出了「单Reactor多进程&#x2F;线程」的方案。</p><p>事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 &lt;-&gt; 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。因此实际应用也看不到单Reactor多进程的模式。</p><p><img src="https://i.ibb.co/gtP5gKb/multi-Reactor.png" alt="multiReactor"></p><p>方案详细过程为：</p><ul><li>Reactor对象通过select监听事件，收到事件后通过dispatch分发，具体分给Acceptor还是Handler取决于事件类型</li><li>若是建立连接的事件，则交给Acceptor处理，其会通过accept方法获取连接，并创建一个Handler对象处理后续响应事件</li><li>若不是建立连接的事件，则交给当前连接对应的Handler对象进行响应</li><li>Handler对象不再负责业务处理，只负责数据的收发，Handler通过read获取数据后，发给子线程里的Processor对象处理</li><li>Processor对象进行业务处理，将结果发送给Handler，由Handler通过send返回给client</li></ul><p>单Reator多线程的方案优势在于<strong>能够充分利用多核 CPU 的能</strong>，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。</p><p>例如，子线程完成业务处理后，要把结果传递给主线程的Handler进行发送，这里涉及共享数据的竞争。</p><p>要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。</p><p>「单 Reactor」的模式有个问题，<strong>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</strong>。</p><div class="note info flat"><p>多Reactor多进程&#x2F;线程</p></div><p>为了解决单Reactor的局限，提出了多Reactor多进程&#x2F;线程的方案。</p><p><img src="https://i.ibb.co/zSTndn8/multi-Reactors.png" alt="multiReactors"></p><p>方案详细过程为：</p><ul><li>主线程中的Main Reactor对象通过select监控建立连接事件，收到事件后通过Acceptor对象中的accept方法获取连接，将新的连接分配给某个子线程</li><li>子线程中的Sub Reactor对象将Main Reactor对象分配的连接加入select继续监听，并创建一个Handler用于处理连接的响应</li><li>若有新事件发生，Sub Reactor对象会调用当前连接对应的Handler对象来进行响应</li><li>Handler对象通过read-&gt;业务处理-&gt;send的流程来完成整个方案</li></ul><p>这样的话，好处在于：</p><ul><li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。</li><li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li></ul><p>Netty和Memcache都采用了该方案。</p><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p>Reactor是非阻塞同步网络模式，而<strong>Proactor是异步网络模式</strong>。</p><p>因此，<strong>Reactor可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些I&#x2F;O事件，这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p><p><img src="https://i.ibb.co/F0cMtgx/proactor.png" alt="proactor"></p><p>Proactor模式的工作流程为：</p><ul><li>Proactor Initiator负责创建Proactor和Handler对象，并将这两个对象都通过Asynchronous Operation Processor注册到内核</li><li>Asynchronous Operation Processor负责处理注册请求，并处理I&#x2F;O操作</li><li>Asynchronous Operation Processor完成I&#x2F;O操作后通知Proactor</li><li>Proactor根据不同的事件类型回调不同的Handler进行业务处理</li><li>Handler完成业务处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的锁</title>
      <link href="/2023/07/26/MySQL%E7%9A%84%E9%94%81/"/>
      <url>/2023/07/26/MySQL%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><p>MySQL中，根据加锁的范围，可以分为全局锁、表级锁和行锁三类。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><div class="note info flat"><p>全局锁如何使用？</p></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><p>执行后，整个数据库就处于只读状态了。其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，例如<code>insert</code>、<code>delete</code>、<code>update</code></li><li>对表结构的更改操作，例如<code>alter table</code>、<code>drop table</code></li></ul><p>执行这条命令来释放全局锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><div class="note info flat"><p>全局锁应用场景是什么？</p></div><p>全局锁主要用于<strong>全库逻辑备份</strong>，这样在备份期间，不会因为数据或者表结构的更新，而导致备份与原件不一致的情况。</p><p>但是加上全局锁后，整个数据库都是只读状态，那么这段时间内业务只能读数据，而不能更新数据，导致业务停滞。</p><div class="note warning flat"><p>那用什么方式可避免备份时全局锁影响业务？</p></div><p>如果数据库引擎支持的事务支持<strong>可重复读的隔离级别（RR）</strong>，那么在备份数据库之前先开启事务，会先创建Read View，然后整个事务执行期间都在用这个Read View，而且由于MVCC的支持，备份期间业务仍然可以对数据进行更新。</p><p>因为在RR的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的Read View，这样备份期间内备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。<strong>这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</strong></p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁包括：</p><ul><li>表锁</li><li>元数据锁MDL</li><li>意向锁</li><li>AUTO-INC锁</li></ul><div class="note default flat"><p>表锁</p></div><p>对某个表加锁，可以使用如下的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，即读锁</span><br><span class="line">lock tables mytable read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，即写锁</span><br><span class="line">lock tables mytable write;</span><br></pre></td></tr></table></figure><p><strong>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</strong></p><p>例如，本线程对mytable加了「共享锁」，那么不仅是其他线程，即便是本线程，接下来对于mytable的<strong>写操作</strong>都是会被阻塞的。</p><p>要释放表锁，使用下面的命令，会释放当前会话的所有表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><div class="note default flat"><p>元数据锁MDL</p></div><p>不需要显式地使用MDL，对数据库表进行操作时，会自动给这个表加上MDL：</p><ul><li>对一张表进行CRUD操作时，加的是MDL读锁</li><li>对一张表进行结构变更时，加的是MDL写锁</li></ul><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><div class="note info flat"><p>MDL不需要显式调用，那么何时释放？</p></div><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><p>之所以线程C阻塞会导致后续select线程均被阻塞，这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全地对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果有，可以考虑kill掉这个长事务，然后再做表结构的变更。</p><div class="note default flat"><p>意向锁</p></div><ul><li>在使用InnoDB引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」</li><li>在使用InnoDB引擎的表里对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li></ul><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<code>lock tables ... read</code>）和独占表锁（<code>lock tables ... write</code>）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><div class="note default flat"><p>AUTO-INC锁</p></div><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB引擎是支持行级锁的，MyISAM不支持行级锁。</p><p>行级锁分为三类：</p><ul><li>Record Lock，记录锁，仅将一条记录锁住</li><li>Gap Lock，间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock，前两者的组合，锁定一个范围的同时锁定记录本身</li></ul><h3 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h3><p>Record Lock是记录锁，记录锁有S锁和X锁之分：</p><ul><li>当一个事务对一条记录加了S锁后，其他事务也可继续对该记录加S锁（S锁与S锁兼容），但不可对该记录加X锁（S锁和X锁不兼容）</li><li>当一个事务对一条记录加了X锁后，其他事务不可对该记录加S锁（S锁和X锁不兼容），也不可对该记录加X锁（X锁和X锁不兼容）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>例如，以上就是对mytable中id&#x3D;1的记录加上了X锁。</p><h3 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h3><p>Gap Lock只存在于可重复读的隔离级别，目的是为了解决RR隔离级别下幻读的问题。</p><p>假设，表中有一个范围id为(3, 5)的Gap Lock，则其他事务就无法插入id&#x3D;4的记录了。</p><h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><p>Next-Key Lock是临键锁，锁定一个范围的同时锁定记录本身。</p><p>假设，表中有一个范围id为(3, 5]的临键锁，那么其他事务不能插入id&#x3D;4的记录，也不能修改id&#x3D;5的记录。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实际应用</title>
      <link href="/2023/07/26/Redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/2023/07/26/Redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis实际应用"><a href="#Redis实际应用" class="headerlink" title="Redis实际应用"></a>Redis实际应用</h1><h2 id="Redis如何实现延迟队列"><a href="#Redis如何实现延迟队列" class="headerlink" title="Redis如何实现延迟队列"></a>Redis如何实现延迟队列</h2><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p><ul><li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li><li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li><li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li></ul><p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p><p>使用<code>ZADD &lt;score&gt; &lt;member&gt;</code>命令就可以一直往内存中生产消息。再利用<code>zrangebysocre</code>查询符合条件的所有待处理的到期任务， 通过循环执行队列任务即可。</p><h2 id="Redis的大key如何处理"><a href="#Redis的大key如何处理" class="headerlink" title="Redis的大key如何处理"></a>Redis的大key如何处理</h2><div class="note info flat"><p>Redis的大key是什么？</p></div><p>大key指的是key对应的value很大。一般地，下面两种情况被称为大key：</p><ul><li>String类型的值大于10KB</li><li>Hash、List、Set、ZSet类型的元素个数超过5000个</li></ul><div class="note waring flat"><p>大key会导致什么问题？</p></div><ul><li>客户端超时阻塞：由于Redis执行命令是单线程处理，那么在操作大key时会耗时很长，从客户端角度来看，就是很长时间无响应</li><li>引发网络阻塞：每次获取大key产生的网络流量较大，如果一个key大小为1MB，每秒访问量1000，则会产生1000MB&#x2F;s的流量，对于普通的千兆网卡的服务器是难以承受的</li><li>阻塞工作线程：如果使用del删除大key，会阻塞工作线程，无法处理后续命令</li><li>内存分布不均：集群模式在slot分片均匀情况下，会出现数据和查询倾斜的问题，部分有大key的Redis节点占用内存多，QPS也较大</li></ul><div class="note info flat"><p>如何定位大key？</p></div><p><strong>1. 通过<code>redis-cli --bigkeys</code>查找大key</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p6379 -a <span class="string">&quot;passwd&quot;</span> --bigkeys</span><br></pre></td></tr></table></figure><ul><li>最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；</li><li>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用<code>-i</code>参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。</li></ul><p>不足：</p><ul><li>这个方法只能返回每种类型中最大的那个大key，无法得到大小排在前 N 位的大key；</li><li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</li></ul><p><strong>2. 使用<code>SCAN</code>命令查找大key</strong></p><p>使用<code>SCAN</code>命令对数据库扫描，然后用<code>TYPE</code>命令获取返回的每一个 key 的类型。</p><p>对于 String 类型，可以直接使用<code>STRLEN</code>命令获取字符串的长度，也就是占用的内存空间字节数。</p><p>对于集合类型来说，有两种方法可以获得它占用的内存大小：</p><ul><li>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：<code>LLEN</code> 命令；Hash 类型：<code>HLEN</code> 命令；Set 类型：<code>SCARD</code> 命令；Sorted Set 类型：<code>ZCARD</code> 命令；</li><li>如果不能提前知道写入集合的元素大小，可以使用 <code>MEMORY USAGE</code> 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</li></ul><p><strong>3. 使用RDBTools工具查找大key</strong></p><p>使用RDBTools第三方开源工具，可以用来解析Redis快照（RDB）文件，找到其中的大key。</p><div class="note info flat"><p>如何删除大key？</p></div><p>删除操作的本质是要释放键值对占用的内存空间。</p><p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</p><p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p><p>有两种方法：</p><p><strong>1. 分批次删除</strong></p><p>对于<strong>删除大Hash</strong>，使用 <code>hscan</code> 命令，每次获取 100 个字段，再用 <code>hdel</code> 命令，每次删除 1 个字段。</p><p>对于<strong>删除大List</strong>，通过 <code>ltrim</code> 命令，每次删除少量元素。</p><p>对于<strong>删除大Set</strong>，使用 <code>sscan</code> 命令，每次扫描集合中 100 个元素，再用 <code>srem</code> 命令每次删除一个键。</p><p>对于<strong>删除大ZSet</strong>，使用 <code>zremrangebyrank</code> 命令，每次删除 top 100个元素。</p><p><strong>2. 异步删除（Redis 4.0以上）</strong></p><p>对于Redis 4.0版本以上，可以使用异步删除，通过<code>unlink</code>命令代替del来删除。这样Redis会将大key放入一个异步线程中来删除，避免阻塞主线程。</p><p>另外，还可以配置参数，达到某些条件时自动进行异步删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del</span><br><span class="line">noslave-lazy-flush no</span><br></pre></td></tr></table></figure><h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><p>使用<strong>管道技术可以解决多个命令执行时的网络等待</strong>，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p><p>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p><p>要注意的是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><h2 id="Redis事务是否支持回滚"><a href="#Redis事务是否支持回滚" class="headerlink" title="Redis事务是否支持回滚"></a>Redis事务是否支持回滚</h2><p>MySQL在执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态。</p><p><strong>Redis中并没有提供回滚机制</strong>，虽然 Redis 提供了<code>DISCARD</code>命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p><p>事务执行过程中，如果命令入队时没报错，而事务提交后，实际执行时报错了，正确的命令依然可以正常执行，所以这可以看出 <strong>Redis 并不一定保证原子性</strong>。</p><p>不支持回滚的原因在于：这种复杂的功能和Redis追求的简单高效的设计主旨不符合。</p><h2 id="如何用Redis实现分布式锁"><a href="#如何用Redis实现分布式锁" class="headerlink" title="如何用Redis实现分布式锁"></a>如何用Redis实现分布式锁</h2><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。</p><p>Redis本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p><p>Redis的<code>SET</code>命令有个NX参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果key不存在，则显示插入成功，可以用来表示加锁成功</li><li>如果key存在，则显示插入失败，可以用来表示加锁失败</li></ul><p>基于Redis节点实现分布式锁时，对于加锁操作，需要满足三个条件：</p><ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，使用<code>SET</code>命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，在<code>SET</code>命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，使用<code>SET</code>命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</li></ul><p>例如，有一条分布式命令如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX <span class="number">10000</span></span><br></pre></td></tr></table></figure><ul><li>lock_key 就是 key 键；</li><li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li></ul><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>综上，即通过<code>SET</code>命令和Lua脚本在Redis单节点上完成了分布式锁的加锁和解锁。</p><div class="note info flat"><p>基于Redis实现分布式锁有何优缺点？</p></div><p>优点：</p><ul><li><p>性能高效（这是选择缓存实现分布式锁最核心的出发点）</p></li><li><p>实现方便。因为 Redis 提供了 setnx 方法，实现分布式锁很方便</p></li><li><p>避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）</p></li></ul><p>缺点：</p><ul><li>超时时间不好设置。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。<ul><li><strong>那么如何合理设置超时时间呢？</strong> 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。</li></ul></li><li><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</li></ul><div class="note info flat"><p>Redis如何解决集群情况下分布式锁的可靠性？</p></div><p>为了保证集群环境下的分布式锁的可靠性，Redis设计了一个分布式锁算法Redlock。</p><p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署5个Redis节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p><p>Redlock算法的基本思路，<strong>是让客户端和多个独立的Redis节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p><p>Redlock 算法加锁三个过程：</p><ul><li>第一步，客户端获取当前时间（t1）。</li><li>第二步，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<ul><li>加锁操作使用 SET 命令，带上 NX，EX&#x2F;PX 选项，以及带上客户端的唯一标识。</li><li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li></ul></li><li>第三步，一旦客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li></ul><p>加锁成功要同时满足两个条件（简述：如果有超过半数的 Redis 节点成功获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功）：</p><ul><li>条件一：客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁；</li><li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li></ul><p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p><p>加锁失败后，客户端向<strong>所有Redis节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的Lua脚本就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存设计</title>
      <link href="/2023/07/24/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/07/24/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis缓存设计"><a href="#Redis缓存设计" class="headerlink" title="Redis缓存设计"></a>Redis缓存设计</h1><h2 id="如何避免缓存雪崩-x2F-击穿-x2F-穿透"><a href="#如何避免缓存雪崩-x2F-击穿-x2F-穿透" class="headerlink" title="如何避免缓存雪崩&#x2F;击穿&#x2F;穿透"></a>如何避免缓存雪崩&#x2F;击穿&#x2F;穿透</h2><div class="note info flat"><p>缓存雪崩是什么？</p></div><p>通常为了保证数据库和缓存的数据一致性，Redis里的数据一般都有过期时间。当缓存数据过期后，用户访问该过期数据，因此就会访问数据库获得数据，并重新生成缓存。</p><p>缓存雪崩：但如果<strong>大量缓存数据在同一时间过期&#x2F;失效或者Redis故障宕机</strong>时，此时若有大量的用户请求，则无法在Redis中处理，进而全部访问数据库，导致数据库压力骤增，可能导致系统崩溃。</p><p><img src="https://i.ibb.co/1zL06SH/cache-Avalanche.png" alt="avalanche"></p><div class="note success flat"><p>如何避免缓存雪崩？</p></div><p>由此，雪崩发生的原因有两种：大量缓存同时过期和Redis故障宕机。针对不同原因，有不同的解决方法。</p><div class="note default flat"><p>大量缓存同时过期</p></div><p>常见的解决方法有：</p><ul><li><p>均匀设置过期时间</p><p>给缓存数据的过期时间加上一个随机数，使得数据不会在同一个时间过期。</p></li><li><p>后台更新缓存</p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p></li><li><p>互斥锁</p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></li></ul><div class="note default flat"><p>Redis故障宕机</p></div><p>常见的解决方法有：</p><ul><li><p>服务熔断&#x2F;请求限流</p><p>因为Redis故障宕机而导致缓存雪崩问题时，可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不再继续访问数据库，从而降低数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服务系统，全部业务都无法正常工作。</p><p>为了减少对业务的影响，可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p></li><li><p>构建Redis集群</p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，在事前最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果Redis缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了Redis故障宕机而导致的缓存雪崩问题。</p></li></ul><hr><div class="note info flat"><p>缓存击穿是什么？</p></div><p>业务中有一些数据会被高频访问，例如秒杀活动。若<strong>某个热点数据过期</strong>了，大量请求又来访问该数据，只能去数据库获取，数据库就容易被高并发的请求冲垮</p><div class="note success flat"><p>如何避免缓存击穿？</p></div><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>热点数据不设置过期时间，由后台异步更新缓存，或者在热点数据要过期前，提前通知后台线程更新缓存以及重新设置过期时间。</li></ul><hr><div class="note info flat"><p>缓存穿透是什么？</p></div><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相应数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><div class="note success flat"><p>如何避免缓存穿透？</p></div><p>缓存穿透的原因主要有两个：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>外界恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透，常见的解决方法有：</p><ul><li>限制非法请求，在API入口处判断请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li><li>缓存空值或者默认值，发现缓存穿透的现象时，针对查询的数据，在缓存中设置一个空值&#x2F;默认值，后续请求就会读取到空值&#x2F;默认值，从而避免访问数据库。</li><li>使用布隆过滤器快速判断数据是否存在，避免查询数据库。</li></ul><div class="note default flat"><p>布隆过滤器工作原理</p></div><p>布隆过滤器由「初始值都为0的位图数组」和「N个哈希函数」两部分组成。当数据被写入数据库时，会在布隆过滤器里做个标记，下次查询该数据时，只需要查询布隆过滤器，如果数据没有被标记，则不在数据库中。</p><p>布隆过滤器会通过3个操作完成标记：</p><ul><li>第一步，使用N个哈希函数分别对数据做哈希计算，得到N个哈希值</li><li>第二步，将N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为1</li></ul><p>例如，有一个位图数组长度为8，哈希函数个数为3的布隆过滤器：</p><p><img src="https://i.ibb.co/d03dmzY/bloom.png" alt="bloom"></p><p>在数据库中写入数据<code>x</code>后，把<code>x</code>标记在布隆过滤器时，其会被3个哈希函数分别计算出3个哈希值，然后将3个哈希值分别对8取模，假设结果分别为1，4，6，然后将位图数组索引为1，4，6的值设为1。</p><p>当有应用查询数据<code>x</code>时，通过布隆过滤器只需查询位图数组的第1，4，6索引的值是否全为1，只要有一个为0，则认为<code>x</code>不在数据库中。</p><h2 id="动态缓存热点数据的策略"><a href="#动态缓存热点数据的策略" class="headerlink" title="动态缓存热点数据的策略"></a>动态缓存热点数据的策略</h2><p>系统不可能将所有数据都放入缓存，只是将一部分热点数据进行缓存，所以一般需要设计一个热点数据动态缓存的策略。</p><p>总体思路为：<strong>通过数据最新访问时间进行排序，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p><ul><li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li><li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li><li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li></ul><p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p><h2 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h2><p>常见的缓存更新策略有3种：</p><ul><li>Cache Aside 旁路缓存策略</li><li>Read&#x2F;Write Through 读穿&#x2F;写穿策略</li><li>Write Back 写回策略</li></ul><p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。</p><div class="note info flat"><p>Cache Aside 旁路缓存策略</p></div><p>应用程序直接与数据库、缓存交互，并负责对缓存的维护，该策略可细分为读策略和写策略。</p><p><img src="https://i.ibb.co/DghLbSL/cache-Aside.png" alt="cacheAside"></p><p><strong>写策略</strong></p><ul><li>先更新数据库中的数据，再删除缓存中的数据</li></ul><p><strong>读策略</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，再将其写入到缓存中，并返回给客户端</li></ul><p><strong>写策略的先更新后删除顺序不可颠倒，否则在读写并发的情况下，会出现缓存和数据库的数据不一致问题。</strong></p><p>例如，假设数据库和缓存中原本存放了一个值为20的数据X，请求A想将其更新为21，若先删除缓存，此时请求B想要读取这个数据，查询缓存未命中后，会从数据库中读到这个数据的值为20，并且将20写入到缓存中，此时请求A继续更新数据库，将该数据的值更新为21。这就导致缓存中存放了旧值20，数据库中存放了新值21。</p><p><img src="https://i.ibb.co/QKN7g3N/inconsistency.png" alt="inconsistency"></p><p><strong>但先更新数据库，后删除缓存是否就能避免数据不一致的情况呢？</strong></p><p>假设该数据起初并未存放在缓存中，请求A读取时从数据库获得该值为20，在其将20写入缓存的过程中，请求B更新了数据库中该数据的值为21，并且删除了对应的缓存，这时请求A将20写入到缓存的动作完成。最终，缓存中存放的是旧值20，数据库中存放的是新值21。</p><p><img src="https://i.ibb.co/pw2yqYf/fake-Inconsistency.png" alt="fake"></p><p><strong>但是，这种情况在实际中发生概率极低。因为缓存的写入速度远高于数据库的写入速度。</strong></p><p><strong>Cache Aside策略适合读多写少的场景，不适合写多的场景</strong>，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p><ul><li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li><li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li></ul><div class="note info flat"><p>Read&#x2F;Write Through 读穿&#x2F;写穿策略</p></div><p>应用程序只和缓存交互，不再与数据库交互，相当于更新数据库的操作由缓存代理了。</p><p><strong>Read Through策略</strong></p><p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p><p><strong>Write Through策略</strong></p><p>当有数据更新的时候，先查询要写入的数据是否已存入缓存中：</p><ul><li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li><li>如果缓存中数据不存在，直接更新数据库，然后返回；</li></ul><p>Read Through&#x2F;Write Through 策略的特点是由缓存节点而非应用程序来和数据库打交道，但经常使用的分布式缓存组件，无论是 Memcached还是Redis都不提供写入数据库和自动加载数据库中的数据的功能。在使用本地缓存的时候可以考虑使用这种策略。</p><div class="note info flat"><p>Write Back 写回策略</p></div><p>Write Back写回策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p><p>实际上，Write Back策略也不能应用到常用的数据库和缓存的场景中，因为Redis并没有异步更新数据库的功能。</p><p>Write Back是计算机体系结构中的设计，比如CPU的缓存、操作系统中文件系统的缓存都采用了Write Back策略。</p><p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p><p><strong>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险</strong>，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以系统在掉电之后，之前写入的文件会有部分丢失，就是因为Page Cache还没有来得及刷盘造成的。</p><h2 id="数据库和缓存如何保证数据一致性"><a href="#数据库和缓存如何保证数据一致性" class="headerlink" title="数据库和缓存如何保证数据一致性"></a>数据库和缓存如何保证数据一致性</h2><p>前文已述，不论是先更新数据库后更新缓存还是先更新缓存后更新数据库，都存在读写并发的问题，可能出现数据不一致的情况。</p><p>因此，考虑不更新缓存，而是直接删除缓存。即前文所述的<strong>Cache Aside策略</strong>。</p><p>但是，Cache Aside也并不能保证过程中不出现任何差错。例如，在先更新数据库后删除缓存的过程中，第二个操作，即删除缓存，在执行的时候失败了，最终导致缓存中是旧值，数据库中是新值。</p><p>例如，应用要将数据的值从1更新为2，第一步更新数据库的操作顺利执行，第二步删除缓存的操作执行失败，那么缓存中留存的就仍是旧值。</p><p><img src="https://i.ibb.co/Hts662h/del-Cache-Err.png" alt="delErr"></p><div class="note warning flat"><p>如何保证「更新数据库」和「删除缓存」两个操作都执行成功？</p></div><p>有两种解决方法：</p><ul><li>重试机制</li><li>订阅MySQL的binlog，再操作缓存</li></ul><div class="note default flat"><p>重试机制</p></div><p>引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列中，由消费者来操作数据。</p><ul><li>如果删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存；持续失败超过一定次数后，向业务层返回报错信息</li><li>如果删除缓存成功，将该数据从消息队列中移除，防止重复操作</li></ul><p><img src="https://i.ibb.co/qJqrbw7/retry.png" alt="retry"></p><div class="note default flat"><p>订阅MySQL binlog，再操作缓存</p></div><p>由于第一个操作是先更新数据库，所以更新成功的话会产生一条变更日志，记录在binlog里。</p><p>因此可以订阅binlog日志，获得具体的操作数据，然后再执行缓存删除，Canal中间件就是基于该原理实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 binlog 给 Canal，Canal 解析 binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis过期删除与内存淘汰</title>
      <link href="/2023/07/23/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
      <url>/2023/07/23/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis过期删除与内存淘汰"><a href="#Redis过期删除与内存淘汰" class="headerlink" title="Redis过期删除与内存淘汰"></a>Redis过期删除与内存淘汰</h1><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><p>Redis会根据过期键值对删除策略将已过期的键值对删除。每当一个key被设置了过期时间后，Redis会将这个key与其过期时间存储到一个「过期字典」中。</p><p>当查询一个key时，首先检查key是否在过期字典中：</p><ul><li>若不在，则正常读取</li><li>若在，则获取过期时间，并与当前系统时间对比，判断其是否过期</li></ul><p>Redis的过期删除策略是<strong>惰性删除+定期删除</strong>这两种策略配合使用。</p><div class="note info flat"><p>惰性删除策略是什么？</p></div><p><strong>惰性删除策略：不主动删除过期的key，每次从数据库访问key时，检测key是否过期，若过期则删除该key，返回<code>null</code>给客户端。</strong></p><p>优点：只有访问key时才检查过期与否，因此这个策略占用系统资源较少，对CPU时间最友好</p><p>缺点：若一个key已过期，那么只要这个key一直不被访问，它就会一直保留在数据库中，造成了内存空间浪费</p><div class="note info flat"><p>定期删除策略是什么？</p></div><p><strong>定期删除策略：每隔一段时间「随机」从数据库中取出一定数量的key进行检查，并删除其中过期的key。</strong></p><p>具体的流程为：</p><ul><li>从过期字典中随机抽20个key</li><li>检查这些key并删除其中过期的key</li><li>若本轮的过期key数量，超过了抽检总数的25%（即5个），则继续重复步骤1；否则，停止继续删除过期key，等待下一轮再检查</li></ul><p>同时，为了防止删除进入过度循环阻塞线程，Redis为该循环设置了时间上限，默认为25毫秒。</p><p>优点：删除一部分过期的key，减少了无效的内存占用</p><p>缺点：定期删除的频率难以把控</p><p>综上，Redis选择了两者配合使用的删除策略，以在减少CPU时耗和避免内存浪费之间取得较好的平衡。</p><div class="note success flat"><p>Redis持久化时，对于过期key如何处理？</p></div><p>Redis持久化文件有两种格式：RDB和AOF。下面是过期键分别在这两种格式中的呈现状态：</p><ul><li>RDB文件分为两个阶段：RDB文件生成阶段和加载阶段<ul><li>生成阶段：从内存状态持久化成RDB文件的时候，会对key做过期检查，过期key不会被保存到新的RDB文件中</li><li>加载阶段：RDB文件加载阶段时，处理方式要看服务器是主还是从，分别有以下两种情况：<ul><li>主服务器，在载入RDB时，程序会对文件中保存的key检查，过期key不会被载入到数据库中</li><li>从服务器，在载入RDB时，无论key是否过期均会载入到数据库中；但主从同步时，从服务器的数据会被清空，因此也不会造成影响</li></ul></li></ul></li><li>AOF文件分为两个阶段：AOF文件写入阶段和重写阶段<ul><li>写入阶段：若数据库中某过期key尚未被删除，AOF文件会保留此过期key，当该key被删除后，Redis会向AOF文件追加一条DEL命令来显式删除该key</li><li>重写阶段：AOF重写时，会检查key，过期key不会被保存到重写后的AOF文件</li></ul></li></ul><div class="note success flat"><p>Redis主从模式中，对于过期key如何处理？</p></div><p>从库不会进行过期扫描，即使从库中的某个key过期了，客户端访问从库时，依旧可以得到该key；主服务器会控制从库的过期处理，当某个key过期后，主库会在AOF文件中追加一条DEL命令，同步到所有从库，从库执行该命令删除过期的key</p><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当Redis的运行内存达到了阈值，就会触发内存淘汰机制，该阈值为Redis配置文件中的<code>maxmemory</code>。</p><p>Redis的内存淘汰策略共有八种，根据「进行数据淘汰」与否可分为两大类。</p><div class="note info flat"><p>不进行数据淘汰的策略</p></div><p><code>noeviction</code>：Redis 3.0后默认的内存淘汰策略，当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误</p><div class="note info flat"><p>进行数据淘汰的策略</p></div><ul><li><p>在设置了过期时间的数据中进行淘汰</p><ul><li><code>volatile-random</code>：随机淘汰设置了过期时间的任意键值</li><li><code>volatile-ttl</code>：优先淘汰更早过期的键值</li><li><code>volatile-lru</code>：Redis 3.0前默认的内存淘汰策略，淘汰所有设置了过期时间的键值中最久未使用的键值</li><li><code>volatile-lfu</code>：Redis 4.0后新增，淘汰所有设置了过期时间的键值中最少使用的键值</li></ul></li><li><p>在所有数据范围内进行淘汰</p><ul><li><code>allkeys-random</code>：随机淘汰任意键值</li><li><code>allkeys-lru</code>：淘汰所有键值中最久未使用的键值</li><li><code>allkeys-lfu</code>：Redis 4.0后新增，淘汰所有键值中最少使用的键值</li></ul></li></ul><h2 id="LRU算法和LFU算法"><a href="#LRU算法和LFU算法" class="headerlink" title="LRU算法和LFU算法"></a>LRU算法和LFU算法</h2><p>LRU是最近最少使用的意思，传统的LRU算法依靠链表来进行实现，链表中的元素按照操作顺序从前往后排列，最新操作的键会移动到链表头，当需要内存淘汰时，只需要删除链表尾的键即可。</p><p>Redis并未采用这样的方式来实现LRU，因为：</p><ul><li>需要开辟链表来管理数据，带来额外的空间开销</li><li>若大量数据被访问，则链表移动操作会很多，影响性能</li></ul><div class="note info flat"><p>Redis如何实现LRU算法？</p></div><p>为了节约内存，Redis使用的是一种近似LRU算法，其实现方式是在Redis的对象结构体中添加一个额外的字段，用来记录此数据的最后一次访问时间。</p><p>当Redis进行内存淘汰时，会使用<strong>随机采样</strong>的方式来淘汰数据，随机选取5个值（可配置），然后淘汰最久没有使用的那一个。</p><p>优缺点如下：</p><ul><li>优点：不用维护大链表，节省了内存；数据访问不需要移动链表项，提升性能</li><li>缺点：无法解决缓存污染问题，例如应用一次读取了大量数据，而这些数据只会被读取这一次，那么就会留存在缓存中很长时间</li></ul><p>因此，Redis 4.0之后引入了LFU算法来解决这个问题。</p><p>LFU是最近最不常用的意思，将数据的访问次数作为参考依据，如果数据过去被访问多次，那么将来被访问的频率也会很高。</p><div class="note info flat"><p>Redis如何实现LFU算法？</p></div><p>Redis对象的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>其中，<code>lru</code>字段在LRU算法和LFU算法下的使用方式并不相同。</p><p>在LRU算法中，这24个bit是用来记录key的访问时间戳，从而淘汰最久未被使用的key</p><p>在LFU算法中，这24个bit被分为两段，高16bit存储LDT（Last Decrement Time），用来记录key的访问时间戳；低8bit存储LOGC（Logistic Counter），用来记录key的访问频次。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式</title>
      <link href="/2023/07/22/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/22/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h1><p>在Redis主从架构中，如果主节点挂了，那么客户端的写请求将无法完成，从节点也无法进行数据同步。</p><p>此时，若想恢复服务，则需要人工介入，选择一个从节点成为新的主节点，然后让其他从节点「服从」新的主节点，同时还要通知连接主节点的客户端，将其配置中的主节点IP地址更新为新的主节点地址。</p><p>因此，Redis 2.8后提供了哨兵机制，通过「哨兵」这一特殊节点，监控主节点的存活情况，并在主节点挂掉时，完成主从节点的切换。</p><p>哨兵实际上是一个运行在特殊模式下的Redis进程，一个特殊的节点。哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p><h2 id="如何判断主节点故障"><a href="#如何判断主节点故障" class="headerlink" title="如何判断主节点故障"></a>如何判断主节点故障</h2><p>哨兵会每隔1秒给所有主从节点发送PING命令，当主从节点收到PING后，会发送一个响应命令给哨兵，即可判断节点是否正常。</p><p><img src="https://i.ibb.co/dW3nYwk/sentinel.png" alt="sentinel"></p><p>如果节点没有在规定的时间内响应PING命令，则哨兵会将其标记为<strong>主观下线</strong>。这个规定时间由配置项<code>down-after-milliseconds</code>参数设定，单位为毫秒。</p><div class="note info flat"><p>除了主观下线，还有客观下线</p></div><p><strong>客观下线只适用于主节点</strong>。</p><p>由于主节点可能只是因为系统压力较大或者网络发生拥塞，而不是故障，导致了其没有在规定时间内响应哨兵的PING命令，因此为其设定了「主观下线」和「客观下线」两种状态。</p><p>所以，为了减少出现误判的情况，哨兵在部署时会用多个节点形成哨兵集群（至少三台），通过多个哨兵一起判断，就可以避免单个哨兵因为网络状况不好，而误判主节点下线的情况。</p><p>当一个哨兵判断主节点「主观下线」后，会向其他哨兵发起命令；其余哨兵收到该命令后，根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p><p><img src="https://i.ibb.co/GxxnrY4/Sentinel-Judge.png" alt="sentinelJudge"></p><p>当赞同票数达到哨兵配置文件中的<code>quorom</code>值时，主节点就会被标记为「客观下线」。</p><blockquote><p><code>quorom</code>值一般设置为哨兵个数的二分之一（向上取整），即半数赞同机制</p></blockquote><p>当主节点客观下线后，哨兵就会执行主从切换的操作。</p><h2 id="哪个哨兵进行主从故障转移"><a href="#哪个哨兵进行主从故障转移" class="headerlink" title="哪个哨兵进行主从故障转移"></a>哪个哨兵进行主从故障转移</h2><p>在进行主从切换之前，需要在哨兵集群中选出一个leader，令其来执行主从切换。</p><p>选举leader的过程是一个投票的过程，在投票开始前，会有「候选者」。</p><div class="note info flat"><p>判断主节点为客观下线的那个哨兵就作为候选者</p></div><p>例如，在上节的例子中，如果哨兵B收到的赞同票达到2，那么主节点就会被标记为客观下线，哨兵B成为一个leader候选者。</p><div class="note info flat"><p>候选者如何选举成为leader</p></div><p>候选者会向其他哨兵发送命令，表明希望成为leader来执行主从切换，并让所有其他哨兵对它进行投票。</p><p>每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。</p><p>任何一个候选者，如果达到如下的全部条件：</p><ul><li>拿到半数以上的赞成票</li><li>拿到的赞成票数大于等于<code>quorom</code>值</li></ul><div class="note warning flat"><p>如果有多个候选者怎么办？</p></div><p>首先，每个候选者会先给自己投一票，然后向其他哨兵发起投票请求。如果投票者先收到候选者A的请求，则对其进行投票，同时该投票者的投票机会就用完了，之后则会拒绝候选者B的投票请求。哪个候选者率先满足上述条件，其就会成为leader。</p><h2 id="主从故障转移的过程"><a href="#主从故障转移的过程" class="headerlink" title="主从故障转移的过程"></a>主从故障转移的过程</h2><p><img src="https://i.ibb.co/tDQcCsv/Switch.png" alt="Switch"></p><p>主从故障转移包含四个步骤：</p><ul><li>在旧主节点属下的所有从节点里面，选出一个从节点，并将其转换为主节点</li><li>让旧主节点属下的所有从节点修改复制目标为新的主节点</li><li>将新主节点的IP地址和信息，通过「发布&#x2F;订阅」机制通知客户端</li><li>继续监视旧主节点，当其上线时，将其设置为新主节点的从节点</li></ul><div class="note info flat"><p>Step 1 选出新主节点</p></div><p>新主节点的挑选需要经过多轮考察。首先，要把已经下线的从节点过滤掉，然后把以往网络连接状况不好的从节点过滤掉。以往网络连接状况根据该从节点与主节点的断连次数决定，如果断连次数超过10次，就说明该从节点的以往网络连接状况不好。</p><p>初步过滤之后，接下来需要对所有从节点进行三轮考察：<strong>优先级、复制进度、ID号</strong>，最终优先胜出的从节点被选为新的主节点。</p><ul><li>第一轮：leader哨兵首先根据从节点优先级进行排序，优先级越小排序越靠前</li><li>第二轮：如果优先级相同，则查看复制的下标，接收的复制数据越多的从节点，排序越靠前</li><li>第三轮：最终选出排序最靠前且ID号最小的从节点</li></ul><p>然后，leader哨兵向被选中的从节点发送<code>SLAVEOF no one</code>命令，使其解除从节点身份；</p><p>在发送 <code>SLAVEOF no one</code> 命令之后，leader哨兵会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令（没进行故障转移之前，<code>INFO</code> 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的slave变为master时，leader哨兵就知道被选中的从节点已经顺利升级为主节点了。</p><div class="note info flat"><p>Step 2 修改从节点同步指向</p></div><p>当新的主节点诞生后，leader哨兵会将旧主节点属下的所有从节点指向新的主节点，通过<code>SLAVEOF</code>实现。</p><div class="note info flat"><p>Step 3 通知客户端</p></div><p>通知客户端主从切换的操作主要通过Redis的「发布&#x2F;订阅」机制来实现。每个哨兵节点提供发布者&#x2F;订阅者机制，客户端可以从哨兵订阅消息。</p><p>哨兵的消息订阅频道中几个常见的事件如下：</p><p><img src="https://i.ibb.co/Wn0vWMY/event-Subsribe.png" alt="eventSub"></p><p>主从切换完成后，哨兵会向<code>+switch-master</code>频道发布新主节点的IP地址和端口，客户端即可得知并与新主节点进行通信。</p><div class="note info flat"><p>Step 4 将旧主节点变为从节点</p></div><p>leader哨兵继续监视旧主节点，当其上线时，哨兵集群向其发送<code>SLAVEOF</code>命令，使其成为新主节点的从节点。</p><p>至此，主从故障转移的整个过程完成。</p><h2 id="哨兵集群如何组成"><a href="#哨兵集群如何组成" class="headerlink" title="哨兵集群如何组成"></a>哨兵集群如何组成</h2><p>在主从集群中，主节点上有一个<code>_sentinel_:hello</code>频道，不同哨兵就是通过该频道来相互发现的。</p><p><img src="https://i.ibb.co/rZyzVrc/channel.png" alt="channel"></p><p>哨兵A将自己的IP地址和端口发布到频道<code>_sentinel_:hello</code>上，由于哨兵B和C订阅了该频道，因此B和C会从这个频道获取到A的地址和端口，继而与A分别建立连接；同理，B和C之间也可建立连接，最终形成哨兵集群。</p><div class="note info flat"><p>为了监控从节点，哨兵集群如何获得从节点信息？</p></div><p>主节点处存有从节点的信息，因此哨兵会每隔10秒向主节点发送INFO命令来获取所有从节点的信息，然后与各个从节点建立连接，进而持续地监控各个从节点的状态。</p><p><img src="https://i.ibb.co/8gsVBcC/slave-Monitor.png" alt="slaveMonitor"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2023/07/19/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/19/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>Redis在持久化方面采用RDB和AOF两个技术保证了即使在服务器重启的情况下也不会丢失数据。</p><p>但由于数据都是存储在一台服务器上，也有可能产生如下问题：</p><ul><li>如果服务器宕机，在数据恢复的这段时间内是无法提供服务的</li><li>如果服务器的硬盘出现故障，数据就可能全部丢失</li></ul><p>因此，可以将数据备份到其他服务器上，让这些服务器也对外提供服务，这样即使有一台出现了故障，其他服务器仍可以继续提供服务。 </p><p><img src="https://i.ibb.co/MydzG6Z/redis-Duplicate.png" alt="redisDuplicate"></p><p>为了保证这些服务器之间的数据一致性，Redis提供了主从复制机制。主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p><h2 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h2><div class="note info flat"><p>多台服务器如何确定主服务器和从服务器？</p></div><p>可以使用<code>replicaof</code>命令形成主从关系。例如，现有服务器A和服务器B，在服务器B上执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># on Server B:</span><br><span class="line">replicaof &lt;IP addr of Server A&gt; &lt;Redis Port of Server A&gt;</span><br></pre></td></tr></table></figure><p>这样，服务器B就会成为服务器A的从服务器，并与主服务器进行第一次同步。</p><p>主从之间第一次同步分为三个阶段：</p><ul><li>第一阶段，建立链接、协商同步</li><li>第二阶段，主服务器同步数据给从服务器</li><li>第三阶段，主服务器发送新的写命令给从服务器</li></ul><p><img src="https://i.ibb.co/9GRXpt4/Redis-Sync.png" alt="redisSync"></p><div class="note success flat"><p>第一阶段：建立链接，协商同步</p></div><p>执行了<code>replicaof</code>命令后，从服务器就会给主服务器发送<code>psync</code>命令，表示要进行数据同步的请求。</p><p><code>psync</code>命令包含两个参数，分别是主服务器的<code>runID</code>和复制进度<code>offset</code>。</p><ul><li><code>runID</code>：每个Redis服务器在启动时都会自动产生一个随机ID作为自己的唯一标识。由于第一次同步时，从服务器并不知道主服务器的<code>runID</code>，因而设置为<code>?</code></li><li><code>offset</code>：表示复制的进度，第一次同步时，设置为<code>-1</code></li></ul><p>主服务器收到<code>psync</code>命令后，会用<code>FULLRESYNC</code>命令作为响应返回给从服务器。同样地，也会带有上述的两个参数，从服务器收到响应后，会记录下这两个值。</p><p><code>FULLRESYNC</code>是采用全量复制的方式，也就是主服务器会把所有数据都同步给从服务器。</p><p>全量同步见第二阶段：</p><div class="note success flat"><p>第二阶段：主服务器同步数据给从服务器</p></div><p>主服务器执行<code>bgsave</code>命令生产RDB文件，然后将RDB文件发送给从服务器。</p><p>从服务器收到RDB文件后，先清空当前的数据，再载入RDB文件。</p><p>但是，这期间若有新的写命令在主服务器执行，则不会写入RDB文件，因此主从服务器之间的数据就产生了不一致。</p><p>为了保证一致性，主服务器会在三个时间间隙中将收到的写命令，写入到replication buffer中：</p><ul><li>主服务器生成RDB期间</li><li>主服务器发送RDB给从服务器期间</li><li>从服务器加载RDB期间</li></ul><div class="note success flat"><p>第三阶段：主服务器发送新的写命令给从服务器</p></div><p>在主服务器生成的RDB文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。完成 RDB 的载入后，会回复一个确认消息给主服务器。</p><p>接着，主服务器将replication buffer里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器replication buffer里发来的命令，这时主从服务器的数据就一致了。</p><p>至此，主从服务器的第一次同步的工作就完成了。</p><h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>主从服务器在完成第一次同步后，双方之间会维护一个TCP连接。</p><p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p><p>而且这个连接是长连接的，目的是避免频繁的TCP连接和断开带来的性能开销。</p><p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p><h2 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h2><p>在第一次同步的过程中，主服务器会做两件耗时的操作：生成RDB和传输RDB。</p><p>如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会产生两个问题：</p><ul><li>主服务器会忙于使用<code>fork()</code>创建用于<code>bgsave</code>的子进程，大量的<code>fork()</code>函数调用会阻塞主进程</li><li>传输RDB会占用大量的主服务器带宽</li></ul><p><img src="https://i.ibb.co/kD352rW/slave.png" alt="redisSlave"></p><p>通过上图这种分级的方式，主服务器生成RDB和传输RDB的压力可以分摊到充当「经理」角色的从服务器。</p><h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><p>当主从服务器完成第一次同步后，就会基于长连接进行命令传播。</p><p>但如果主从服务器间的网络断开了，从服务器的数据就无法与主服务器继续保持一致，客户端就可能从从服务器处读到旧数据。</p><p>那么当网络恢复时，应如何继续保证主从服务器之间的数据一致性呢？</p><p>在Redis 2.8之前，会做一次主从之间的全量复制，但这样存在很多重复的不必要的开销；Redis 2.8之后，只做增量复制，即传播断开网络之后的写操作命令。</p><p>具体步骤为：</p><ul><li>网络恢复后，从服务器发送<code>psync</code>命令给主服务器，此时的<code>offset</code>不是-1</li><li>主服务器收到该命令后，用<code>CONTINUE</code>响应告诉从服务器接下来用增量复制的方式同步数据</li><li>主服务器将断线期间的写命令发送给从服务器，从服务器执行这些命令</li></ul><div class="note info flat"><p>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</p></div><ul><li><code>repl_backlog_buffer</code>：这是一个环形缓冲区，用于主从服务器断连后，从中找到差异的数据</li><li><code>replication offset</code>：标记上面缓冲区的同步进度，主从服务器都有自己的偏移量，主服务器用<code>master_repl_offset</code>记录自己<strong>写</strong>到的位置，从服务器用<code>slave_repl_offset</code>记录自己<strong>读</strong>到的位置</li></ul><p>那么<code>repl_backlog_buffer</code>是什么时候写入的呢？</p><p>在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将命令写入到<code>repl_backlog_buffer</code>中。</p><p>网络恢复后，从服务器会通过<code>psync</code>命令将自己的复制偏移量<code>slave_repl_offset</code>发送给主服务器，主服务器会根据自己的<code>master_repl_offset</code>和<code>slave_repl_offset</code>之间的差距，来决定对从服务器执行哪种同步操作：</p><ul><li>如果判断出从服务器要读取的数据还在<code>repl_backlog_buffer</code>里，那么主服务器将采用增量同步的方式</li><li>如果判断出从服务器要读取的数据不在<code>repl_backlog_buffer</code>里，那么主服务器将采用全量同步的方式</li></ul><p>增量数据会被写入到之前提到的<code>replication buffer</code>中，然后发送给从服务器。</p><p><img src="https://i.ibb.co/YPCfdF4/Incremental-Repl.png" alt="IncrementalRepl"></p><p><code>repl_backlog_buffer</code>缓冲区的默认大小是1M，并且是环形的，因此当缓冲区写满后，继续写入的话会覆盖之前的数据。因此，如果从服务器要读的数据已经被覆盖了，那么主服务器就会采用全量复制的方式进行同步。</p><p>因此，为了避免在网络恢复时，主服务器频繁使用全量同步的方式，应该调整<code>repl_backlog_buffer</code>的大小：<br>$$<br>size(repl_backlog_buffer) \geq second\ *\ write_size_per_sercond<br>$$<br>其中，<code>second</code>指的是断网后从服务器重新连接上主服务器所需的平均时间；<code>write_size_per_second</code>指的是主服务器每秒产生的平均写命令数据量大小。例如，如果主服务器平均每秒产生1MB的写命令，从服务器重连主服务器平均需要5秒，则<code>repl_backlog_buffer</code>最小大小为5MB。最后，考虑到保险起见，一般将其设置为此基础上的两倍。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>如何判断某个Redis节点是否正常工作？</p></div><p>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心跳检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p><p>Redis 主从节点发送心跳的间隔是不一样的，而且作用也有一点区别：</p><ul><li>Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数<code>repl-ping-slave-period</code>控制发送频率</li><li>Redis 从节点每隔 1 秒发送<code>replconf ack &#123;offset&#125;</code>命令，给主节点上报自身当前的复制偏移量，目的是为了：<ul><li>实时监测主从节点网络状态；</li><li>上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。</li></ul></li></ul><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>主从复制模式中，过期的key如何处理？</p></div><p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，则模拟一条del命令发送给从节点，从节点据此进行删除key的操作。</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>主从复制模式中，两个Buffer区（<code>replication buffer</code>和<code>repl_backlog_buffer</code>）有什么区别？</p></div><ul><li>出现阶段不同：<ul><li><code>replication buffer</code>在全量复制阶段和增量复制阶段均会出现，主节点会给每个新连接的从节点分配一个<code>replication buffer</code></li><li><code>repl_backlog_buffer</code>只在增量复制阶段出现，一个主节点只分配一个<code>repl_backlog_buffer</code></li></ul></li><li>缓冲区满了之后不同：<ul><li><code>replication buffer</code>满了之后会导致连接断开，删除缓存，从节点重新连接，重新开始全量复制</li><li><code>repl_backlog_buffer</code>满了之后会覆盖起始位置的数据（环形结构）</li></ul></li></ul><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>如何解决主从之间数据不一致？</p></div><p><strong>主从数据不一致的原因：</strong></p><p>主从节点间的命令复制是异步进行的，所以无法实现强一致性保证（时时刻刻保持一致）</p><p><strong>解决方法：</strong></p><ul><li>尽量保证主从节点间的网络状况良好</li><li>通过一个外部程序监控主从节点间的复制进度，具体为：<ul><li>监控程序通过Redis的<code>INFO replication</code>命令查到主、从节点的进度信息，然后用<code>master_repl_offset</code>减去<code>slave_repl_offset</code>，得到主从节点之间的复制进度差值</li><li>如果某个从节点与主节点的进度差值超出了预设的阈值，则可以让客户端不再和该从节点进行数据读取</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2023/07/18/Redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2023/07/18/Redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="Redis实现服务高可用"><a href="#Redis实现服务高可用" class="headerlink" title="Redis实现服务高可用"></a>Redis实现服务高可用</h2><p>要设计一个高可用的Redis服务，要从Redis的多服务节点考虑，比如Redis的主从复制、哨兵模式、切片集群。</p><div class="note info flat"><p>主从复制</p></div><p>主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将一台主Redis服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p><p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来的写操作命令，然后执行这条命令。</p><p><img src="https://i.ibb.co/NL9ZBf5/redis-Group.png" alt="redisGroup"></p><p>注意，主从服务器之间的命令复制是<strong>异步</strong>进行的。</p><p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。</p><p>所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p><blockquote><p>主从复制的详细原理和具体实现，可见这篇文章：<a href="https://www.brokenmind.top/2023/07/19/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">Redis主从复制</a></p></blockquote><div class="note info flat"><p>哨兵模式</p></div><p>在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。</p><p>为了解决这个问题，Redis 增加了哨兵模式（<strong>Redis Sentinel</strong>），因为哨兵模式做到了可以监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p><p><img src="https://i.ibb.co/dW3nYwk/sentinel.png" alt="sentinel"></p><blockquote><p>哨兵模式的详细原理和具体实现，可见这篇文章：<a href="https://www.brokenmind.top/2023/07/22/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/">Redis哨兵模式</a></p></blockquote><div class="note info flat"><p>切片集群模式</p></div><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><p>切片集群方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。一个切片集群共有16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的key，映射到一个哈希槽中，具体分为两步：</p><ul><li>根据键值对的key，按照CRC16算法计算一个16bit的值</li><li>再用16bit值对16384取模，得到0～16383范围内的模数，每个模数代表一个相应编号的哈希槽</li></ul><p>接下来的问题就是，如何将这些哈希槽映射到具体的 Redis 节点上，有两种方案：</p><ul><li><strong>平均分配：</strong> 在使用<code>cluster create</code>命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384&#x2F;9 个。</li><li><strong>手动分配：</strong> 可以使用<code>cluster meet</code>命令手动建立节点间的连接，组成集群，再使用<code>cluster addslots</code>命令，指定每个节点上的哈希槽个数。</li></ul><p><img src="https://i.ibb.co/2ZZCj6Q/redis-Slot.png" alt="redisSlot"></p><p>上图中的切片集群共有2个Redis节点，假设有4个哈希槽，可以通过命令手动分配哈希槽，例如节点1保存哈希槽0和1，节点2保存哈希槽2和3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> -p <span class="number">6379</span> cluster addslots <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">redis-cli -h <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span> -p <span class="number">6379</span> cluster addslots <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><p>在集群运行的过程中，key1和key2计算完CRC16的值后，对哈希槽总个数4进行取模，再根据模数映射到对应的哈希槽中。</p><hr><h2 id="集群脑裂问题"><a href="#集群脑裂问题" class="headerlink" title="集群脑裂问题"></a>集群脑裂问题</h2><div class="note info flat"><p>脑裂是什么？</p></div><p>Redis主从架构一般是一主多从，如果主节点发生网络问题和所有从节点失联了，但主节点和客户端之间的连接仍是正常的；客户端并不知道Redis内部发生了问题，仍在向主节点写数据（过程A），主节点将这些数据缓存到缓冲区内，而从节点无法同步这些数据。</p><p>这时，哨兵发现主节点失联，它会认为主节点挂了，于是它会在从节点中选举出一个leader作为新的主节点，这样集群就产生了两个主节点，即为脑裂。</p><p>然后，网络恢复正常，由于已经选举出了新的主节点，因此哨兵会将旧的主节点降级为从节点X，从节点X会向新的主节点请求数据同步。因为第一次同步是全量同步，此时的节点X会先清空自己本地的所有数据，然后再做同步，那么，在失联时期内，客户端在节点X写入的数据就会丢失，即集群脑裂产生数据丢失问题。</p><p><strong>概括为：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主节点。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</strong></p><div class="note warning flat"><p>解决方案</p></div><p>当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接将错误返回给客户端。</p><p>在Redis的配置文件中有两个参数：</p><ul><li><code>min-slaves-to-write x</code>：主节点必须要有<code>x</code>个从节点连接，如果小于这个数，主节点会禁止写数据</li><li><code>min-slaves-max-lag x</code>：主从数据复制和同步的延迟不能超过<code>x</code>秒，若超过，主节点会禁止写数据</li></ul><p>利用这两个参数，可以使得旧的主节点被限制接收客户端的写请求，也无法写入新数据；等到新的主节点上线后，就只有新的主节点能接收和处理客户端请求，新写的数据会直接写入到新的主节点内，旧的主节点降为从节点，由于之前禁止写入数据，因此也不会发生数据丢失的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2023/07/17/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/07/17/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis的读写操作均是在内存中，当Redis重启后，内存中的数据就会丢失；为了防止数据丢失，Redis实现了数据持久化的机制，该机制会将数据存储到磁盘中，这样Redis重启时就能够从磁盘中恢复原有的数据。</p><div class="note info flat"><p>Redis共有三种实现数据持久化的方式：</p></div><ul><li><strong>AOF日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到日志文件里；</li><li><strong>RDB快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化</strong>：Redis 4.0新增的方式，集成了AOF和RDB的优点</li></ul><h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令来进行数据恢复。</p><img src="https://i.ibb.co/9q9LNqj/AOF.png" alt="AOF" style="zoom:67%;" /><p>例如，发送命令为<code>set name Mitsui</code>，AOF记录日志如图：</p><img src="https://i.ibb.co/xS8f925/AOFLog.png" alt="AOFLog" style="zoom:67%;" /><p>其中，<code>*3</code>表示命令有三个部分，每个部分都是<code>$</code>+数字开头，后面紧跟具体的命令、键、值；该数字表示紧跟的命令、键或者值长度为多少字节，例如<code>$3 set</code>表示set命令的字符串长度。</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>为什么先执行命令，再写入日志呢？</p></div><p>这样做有两个好处：</p><ul><li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>但也会有若干风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><p>Redis写入AOF日志的过程如图所示：</p><img src="https://i.ibb.co/c1DLsCq/RedisAOF.png" alt="RedisAOF" style="zoom:67%;" /><ul><li>Redis执行完写操作命令后，会将命令追加到<code>server.aof_buf</code>缓冲区内；</li><li>然后通过<code>write()</code>系统调用，将<code>aof_buf</code>缓冲区的数据写入到AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区<code>page cache</code>，等待内核将数据写入硬盘；</li><li>内核缓冲区的数据具体什么时候写入到硬盘，由内核决定。</li></ul><div class="note info flat"><p>上述第三步中的写回操作，AOF有三种写回策略，具体参数可在Redis.conf中的appendfsync配置：</p></div><ul><li><code>Always</code>：每次写操作后，同步将AOF日志数据写回到硬盘</li><li><code>Everysec</code>：每次写操作后，内核缓冲区每隔一秒将数据写回到硬盘</li><li><code>No</code>：写回时机不由Redis控制，交由操作系统来决定</li></ul><img src="https://i.ibb.co/YDWxcRN/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="writeback" style="zoom:60%;" /><div class="note warning flat"><p>AOF日志过大，会触发什么机制？</p></div><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p><p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p><p>例如：在没有重写之前，分别执行了<code>set name Mitsui</code>和<code>set name Mitsui21</code>两条命令，那么AOF日志中就会保存这两条命令；在使用重写之后，读取内存中的键值对（即<code>name:Mitsui21</code>），并转化成命令保存到新的AOF文件，最终覆盖掉旧的AOF文件。如此，减少了历史命令的占据空间。</p><div class="note info flat"><p>AOF日志重写的过程如下：</p></div><p>Redis的AOF重写过程是由**后台子进程<code>bgrewriteaof</code>**来完成的，这样有两个好处：</p><ul><li>子进程进行AOF重写期间，主进程可以继续处理命令请求，避免阻塞主进程</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全</li></ul><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）</p><div class="note warning flat"><p>如果主进程修改了共享内存中的数据，发生写时复制，如何解决父子进程中该数据的不一致性</p></div><p>Redis为此设置了一个<strong>AOF重写缓冲区</strong>，这个缓冲区在<code>bgrewriteaof</code>子进程创建时启用。</p><img src="https://i.ibb.co/D5ZRPnD/AOFrewrite.png" alt="AOFrewrite" style="zoom:67%;" /><p>在重写AOF期间，当Redis执行完一个命令后，它会同时将这个写命令写入到AOF缓冲区和AOF重写缓冲区。</p><p>在<code>bgrewriteaof</code>子进程执行AOF重写期间，主进程需完成以下工作：</p><ul><li>执行客户端发来的命令</li><li>将执行后的写命令追加到AOF缓冲区</li><li>将执行后的写命令追加到AOF重写缓冲区</li></ul><p>当子进程完成重写后，向主进程发送一条信号（信号是进程间通信的一种方式，且异步）</p><p>主进程收到该信号后，调用一个信号处理函数，该函数完成以下工作：</p><ul><li>将AOF重写缓冲区中的所有内容追加到新的AOF文件中，使得新旧两个AOF文件所保存的数据库状态一致</li><li>新的AOF文件改名，覆盖现有的AOF文件</li></ul><hr><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p><p>为了解决这个问题，Redis 增加了 RDB 快照。RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>RDB做快照会阻塞线程吗？</p></div><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 <code>save</code> 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 <code>bgsave</code> 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>RDB在做快照时，数据能修改吗？</p></div><p>可以。执行<code>bgsave</code>过程中，Redis依然可以继续处理操作命令，也就是数据是可以修改的。关键技术就在于<strong>写时复制</strong>（Copy-On-Write)。</p><p>执行<code>bgsave</code>命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行<strong>读操作</strong>，则主线程和 <code>bgsave</code> 子进程互相不影响。</p><img src="https://i.ibb.co/cQ75WsV/bgsave.png" alt="bgsave" style="zoom:67%;" /><p>如果主进程执行<strong>写操作</strong>，则被修改的数据会复制一份副本，然后<code>bgsave</code>子进程会把该副本数据写入RDB文件，在这个过程中，主进程仍然可以直接修改原来的数据。</p><img src="https://i.ibb.co/rpgSDcD/cow.png" alt="cow" style="zoom:67%;" /><div class="note warning flat"><p>RDB快照过程存在如下问题：</p></div><ul><li>在主进程执行写操作修改数据时，RDB快照保存的是原本的内存数据，而刚刚修改的数据，只能交由下一次的快照</li><li>如果在主进程写操作修改数据后，且下一次快照执行前，发生了崩溃，那么此次修改将会丢失</li><li>极端情况下，主进程每一个操作均是写操作，那么占用的内存将是原来的2倍</li></ul><hr><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>因此，Redis 4.0提出了<strong>混合持久化</strong>，即混合使用AOF日志和内存快照，既保证了Redis重启速度，又降低了数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>使用了混合持久化后，AOF文件的前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据。</p><p>好处在于：</p><ul><li><p>重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载速度会很快</strong>。</p></li><li><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少丢失</strong>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型</title>
      <link href="/2023/07/17/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/07/17/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><div class="note info flat"><p>Redis单线程指的是<strong>接收客户端请求-&gt;解析请求-&gt;进行数据读写等操作-&gt;发送数据给客户端</strong>这个过程是由一个线程来完成的。</p></div><p>但是，Redis程序并不是单线程的，Redis启动时会产生后台线程（BIO）：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理<strong>关闭文件、AOF 刷盘</strong>这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来<strong>异步释放 Redis 内存</strong>，也就是 lazyfree 线程。例如执行<code>unlink key</code> &#x2F; <code>flushdb async</code> &#x2F; <code>flushall async</code> 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 <code>del</code> 命令删除，因为 <code>del</code> 是在主线程处理的，这样会导致 Redis 主线程卡顿，应该使用 <code>unlink</code> 命令来异步删除大key。</li></ul><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务去执行对应的方法即可。</p><img src="https://i.ibb.co/mBNRbGH/image.png" alt="Task Queue" style="zoom:47%;" /><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p><ul><li><code>BIO_CLOSE_FILE</code>，关闭文件任务队列：当队列有任务后，后台线程会调用 <code>close(fd)</code> ，将文件关闭；</li><li><code>BIO_AOF_FSYNC</code>，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 <code>fsync(fd)</code>，将 AOF 文件刷盘，</li><li><code>BIO_LAZY_FREE</code>，lazy free 任务队列：当队列有任务后，后台线程会 <code>free(obj)</code> 释放对象 &#x2F; <code>free(dict)</code> 删除数据库所有对象 &#x2F; <code>free(skiplist)</code> 释放跳表对象；</li></ul><div class="note success flat"><p>Redis单线程高效的原因如下：</p></div><ul><li>Redis 的大部分操作都<strong>在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题；</li><li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><h2 id="Redis-6-0前"><a href="#Redis-6-0前" class="headerlink" title="Redis 6.0前"></a>Redis 6.0前</h2><p>Redis 6.0版本之前的单线程模式如图：</p><img src="https://i.ibb.co/CQwNvSX/redis-drawio.png" alt="redis6.0" style="zoom:40%;" /><p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I&#x2F;O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：</p><ul><li>首先，调用<code>epoll_create()</code>创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li><li>然后，调用 <code>bind()</code> 绑定端口和调用 <code>listen()</code>监听该 socket；</li><li>然后，调用 <code>epoll_ctl()</code> 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li></ul><p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要做以下事情：</p><ul><li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 <code>write</code> 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 <code>epoll_wait</code> 发现可写后再处理 。</li><li>接着，调用 <code>epoll_wait</code> 函数等待事件的到来：<ul><li>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li><li>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li><li>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li></ul></li></ul><div class="note orange icon-padding flat"><i class="note-icon fas fa-question-circle"></i><p>Redis 6.0之前采用单线程的原因：</p></div><ul><li><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I&#x2F;O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题；如果想要使用服务器的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式；</li><li>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，<strong>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</strong>。</li></ul><h2 id="Redis-6-0后"><a href="#Redis-6-0后" class="headerlink" title="Redis 6.0后"></a>Redis 6.0后</h2><p>虽然 Redis 的主要工作（网络 I&#x2F;O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</strong>。</p><p>所以为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理</strong>。</p><p>Redis 6.0 版本之后，在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>：</p><ul><li><code>Redis-server</code> ： Redis的主线程，主要负责执行命令；</li><li><code>bio_close_file</code>、<code>bio_aof_fsync</code>、<code>bio_lazy_free</code>：三个后台线程，分别异步处理关闭文件、AOF刷盘、释放内存的任务；</li><li><code>io_thd_1</code>、<code>io_thd_2</code>、<code>io_thd_3</code>：三个 I&#x2F;O 线程，io-threads 默认是 4 ，所以会启动 4-1&#x3D;3个 I&#x2F;O 多线程，用来分担 Redis 网络 I&#x2F;O 的压力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog配置</title>
      <link href="/2023/07/16/Blog%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/07/16/Blog%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Blog配置"><a href="#Blog配置" class="headerlink" title="Blog配置"></a>Blog配置</h1><h2 id="分栏tabs"><a href="#分栏tabs" class="headerlink" title="分栏tabs"></a>分栏tabs</h2><div class="tabs" id="usage"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#usage-1">标签语法</button></li><li class="tab"><button type="button" data-href="#usage-2">配置参数</button></li><li class="tab"><button type="button" data-href="#usage-3">示例代码</button></li><li class="tab"><button type="button" data-href="#usage-4">效果预览</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="usage-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="usage-2"><ul><li><code>Unique name</code><ul><li>选项卡块的唯一名称，不带逗号</li><li>将在<code>#id</code>中用作每个标签及其索引号的前缀</li><li>如果名称中包含空格，则对于生成的<code>#id</code>，所有空格将由破折号代替</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的</li></ul></li><li><code>index</code><ul><li>分栏选项卡的索引号</li><li>如果未指定，将选择第一个标签：1</li><li>如果index为-1，则不会选择任何选项卡</li><li>可选参数</li></ul></li><li><code>Tab caption</code><ul><li>当前选项卡的标题</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题</li><li>如果未指定标题，但指定了图标，则标题将为空</li><li>可选参数</li></ul></li><li><code>@icon</code><ul><li>FontAwesome图标名称，例如<code>fas fa-font</code></li><li>可以指定带空格或不带空格，例如<code>Tab caption @icon</code>和<code>Tab caption@icon</code></li><li>可选参数</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="usage-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="usage-4"><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h2><h3 id="Default-Note"><a href="#Default-Note" class="headerlink" title="Default Note"></a>Default Note</h3><div class="tabs" id="note"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#note-1">Simple</button></li><li class="tab"><button type="button" data-href="#note-2">Modern</button></li><li class="tab"><button type="button" data-href="#note-3">Flat</button></li><li class="tab"><button type="button" data-href="#note-4">Disable</button></li><li class="tab"><button type="button" data-href="#note-5">No-icon</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="note-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="note-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="note-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="note-4"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="note-5"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Note-with-icons"><a href="#Note-with-icons" class="headerlink" title="Note with icons"></a>Note with icons</h3><div class="tabs" id="notewithicon"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#notewithicon-1">icon-simple</button></li><li class="tab"><button type="button" data-href="#notewithicon-2">icon-modern</button></li><li class="tab"><button type="button" data-href="#notewithicon-3">icon-flat</button></li><li class="tab"><button type="button" data-href="#notewithicon-4">icon-disable</button></li><li class="tab"><button type="button" data-href="#notewithicon-5">icon-no-icons</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="notewithicon-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line">2024年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是是 UnionPay</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2024年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="notewithicon-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-bullhorn&#x27; modern %&#125;</span><br><span class="line">2024年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是是 UnionPay</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2024年快到了….</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="notewithicon-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note green &#x27;fas fa-fan&#x27; flat%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;</span><br><span class="line">该充电了哦！</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note green icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>该充电了哦！</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="notewithicon-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled  %&#125;</span><br><span class="line">该充电了哦！</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled  %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fab fa-internet-explorer&#x27; disabled  %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>该充电了哦！</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note blue icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="notewithicon-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note blue no-icon %&#125;</span><br><span class="line">2024年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink no-icon %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red no-icon %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note blue no-icon flat"><p>2024年快到了….</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础与数据结构</title>
      <link href="/2023/07/15/Redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/15/Redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis基础与数据结构"><a href="#Redis基础与数据结构" class="headerlink" title="Redis基础与数据结构"></a>Redis基础与数据结构</h1><p>认识一下Redis的基本使用场景和数据结构类型。</p><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一种基于内存的非关系型数据库，对数据的读写操作均是在内存中完成的，因此读写速度非常快，常用于<strong>缓存、消息队列、分布式锁</strong>等场景。此外，Redis还支持<strong>事务、持久化、Lua脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式、内存淘汰机制、过期删除机制</strong>等。</p><h3 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h3><p>两者的共同点是：</p><ul><li>都是基于内存的数据库，一般都用来当缓存用</li><li>都有过期策略</li><li>性能都较高</li></ul><p>区别在于：</p><ul><li>Redis支持的数据类型更丰富，而Memcached只支持最简单的k-v类型</li><li>Redis支持持久化，而Memcached不支持</li><li>Redis支持原生的集群模式，而Memcached需要依靠客户端来实现集群</li><li>Redis还支持发布&#x2F;订阅模型、Lua脚本、事务等功能，Memcached不支持。</li></ul><h3 id="为什么用Redis作缓存"><a href="#为什么用Redis作缓存" class="headerlink" title="为什么用Redis作缓存"></a>为什么用Redis作缓存</h3><ol><li>Redis具备高性能</li><li>Redis支持高并发</li></ol><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis的五种基础数据类型：</p><ul><li>String：缓存对象、常规计数、分布式锁、共享session信息等</li><li>List：消息队列（但是有两个问题：生产者需要自行实现全局唯一；不能以消费组形式消费数据）</li><li>Hash：缓存对象、购物车等</li><li>Set：聚合计算（并集、交集、差集）等，比如点赞、共同关注、抽奖活动</li><li>Zset：排序场景，比如排行榜、电话和姓名排序等</li></ul><p>后续版本Redis又支持四种新的数据类型：</p><ul><li>BitMap：状态统计，比如签到、判断用户登陆状态、连续签到用户总数等</li><li>HyperLogLog：海量数据基数统计，比如百万级网页UV统计</li><li>GEO：存储地理位置信息，比如打车</li><li>Stream：消息队列，相比于List实现的消息队列多了自动生成全局唯一消息ID和支持以消费组形式消费数据这两个特性</li></ul><h2 id="Redis数据类型详解"><a href="#Redis数据类型详解" class="headerlink" title="Redis数据类型详解"></a>Redis数据类型详解</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类型的底层数据结构实现主要是<code>int</code>和<code>SDS</code>（简单动态字符串）。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab2</title>
      <link href="/2023/07/14/MIT%206.830%20Lab2/"/>
      <url>/2023/07/14/MIT%206.830%20Lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab2"><a href="#MIT-6-830-Lab2" class="headerlink" title="MIT 6.830 Lab2"></a>MIT 6.830 Lab2</h1><div class="note info flat"><p><strong>Project Intro</strong></p></div><p>Lab 2需要实现SQL中常见的几种算子逻辑：</p><ul><li>Filter，条件查询过滤器</li><li>Join，两表连接查询（本Lab只实现内连接）</li><li>Aggregate，聚合运算（求平均值&#x2F;最值等等）</li><li>Insert&#x2F;Delete，增删元组</li></ul><p>另外，对于需要修改文件内容的操作，需要在Buffer&#x2F;File&#x2F;Page这三个层面同时实现对应的修改，保证数据库的一致性。最后，由于Buffer Pool的容量是有限的，因此还需要实现一个页置换算法。</p><div class="note success flat"><p><strong>基本算子的实现</strong></p></div><p>这一小节的内容对应Lab 2的Exercise 1-4。</p><div class="note default flat"><p>Filter</p></div><p>Filter的判读过滤操作被抽象成了<code>Predicate</code>类，这个类在实现的时候，需要对三个对象进行初始化：</p><ul><li>需要判断的属性值的列号<code>field</code></li><li>判断的类型（大于&#x2F;小于&#x2F;等于&#x2F;不等于），用一个枚举类型<code>op</code>表示</li><li>判断的基准值，用Field类型的值<code>operand</code>表示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Predicate</span><span class="params">(<span class="type">int</span> field, Op op, Field operand)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.field = field;</span><br><span class="line">    <span class="built_in">this</span>.op = op;</span><br><span class="line">    <span class="built_in">this</span>.operand = operand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Predicate</code>类会通过<code>filter(Tuple t)</code>方法判断给定的属性值是否满足判断条件，然后在<code>Filter</code>类中调用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> t.getField(<span class="built_in">this</span>.field);</span><br><span class="line">    <span class="keyword">return</span> field.compare(op, operand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Filter</code>类中继承了<code>Operator</code>并需要实现一个<code>fetchNext()</code>方法，该方法遍历child中的tuple，直到找到一个满足条件的元组，否则就在遍历结束后返回<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Filter</span><span class="params">(Predicate p, OpIterator child)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.p = p;</span><br><span class="line">    <span class="built_in">this</span>.child = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>Join</p></div><p>这里实现的<code>Join</code>是内连接，就是将分别来自于两个表的，满足一定条件的元组a和b合成一个新的元组c，并且c的所有属性是a和b汇总得到的；例如：元组a是$(a_1,\ a_2,\ a_3)$，元组b是$(b_1,\ b_2)$，且a和b满足Join的判断条件，则生成的c是$(a_1,\ a_2,\ a_3,\ b_1,\ b_2)$。</p><p>与<code>Filter</code>类似地，<code>Join</code>的条件判断也通过一个类<code>JoinPredicate</code>来实现，只不过参数变成了两个元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JoinPredicate</span><span class="params">(<span class="type">int</span> field1, Predicate.Op op, <span class="type">int</span> field2)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="built_in">this</span>.field1 = field1;</span><br><span class="line">    <span class="built_in">this</span>.op = op;</span><br><span class="line">    <span class="built_in">this</span>.field2 = field2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t1, Tuple t2)</span> &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> t1.getField(field1).compare(op, t2.getField(field2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>Aggregate</p></div><p>Aggregate操作是对数据表中的元组按照一定规则进行聚合运算，常见的Aggregate操作包括：</p><ul><li>计数类Count</li><li>求和类Sum &#x2F; Avg</li><li>最值类Max &#x2F; Min</li></ul><p>Aggregate通常会和<code>group by</code>搭配使用，<code>group by</code>提供聚合的参照和依据，当它指定了某个属性后，该属性相同的元组会被聚合成一个结果，这时候Aggregate操作返回的结果就是类似<code>(groupValue, aggregateValue)</code>的元组。</p><p>在这个Lab中，需要实现两种不同数据类型（Int和String）的聚合运算。</p><div class="note default flat"><p>Insert&#x2F;Delete</p></div><p>增删元组这两种操作与前面的区别在于，Insert和Delete会改变数据表的Page中存储的元组信息，例如Insert会找到一个空的slot插入元组，Delete会把对应slot的元组标记为invalid（Lab 1提到的标记位）。</p><p>为此要先实现每个Heap Page中的插入删除操作，然后实现每个Heap File中的插入删除，然后再实现BufferPool中的插入删除。</p><ul><li>在一个Page发生了修改之后，这个Page就变成了脏页，需要标记为dirty，并让BufferPool在适当的时机写回到磁盘存储的文件中</li><li>之后所有涉及到页修改的操作都需要通过BufferPool对外提供的方法进行，这其中执行的逻辑是BufferPool先判断要操作的页在不在Buffer中，如果不在就先去磁盘中把对应的Page读进来，然后在这个页上进行相关操作</li></ul><div class="note success flat"><p><strong>页置换算法的实现</strong></p></div><p>这一小节实现Lab 2的Exercise 5。</p><p>由于BufferPool容量有限，当读入的页超过容量后，需要将一部分页置换出去。常用的页置换算法有LRU、LFU等。这里实现了LRU的页置换算法。</p><div class="note default flat"><p>LRU页置换</p></div><p>定义一个LRU类，数据结构设计为一个双向链表+哈希表。</p><ul><li>双向链表<code>DLinkedNode</code>按照被访问的顺序存储这些键值对，靠近链表头的键值对是最近访问的，靠近链表尾的键值对是最久未访问的</li><li>哈希表<code>cache</code>通过缓存数据的键映射到其在双向链表中的位置</li></ul><p>首先使用哈希表进行定位，找到缓存页在双向链表中的位置，随后将其移动到链表头，并完成相应的put或者add操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(K _key, V _value)</span>&#123;</span><br><span class="line">            key = _key;</span><br><span class="line">            value = _value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2023/07/12/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/07/12/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>整理一些MySQL索引相关的常见问题和内容。</p><hr><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>按数据结构来分：B+树索引、Hash索引、Full-text索引</p><p>按物理存储来分：聚簇索引、二级索引</p><p>按字段特性来分：主键索引、唯一索引、普通索引、前缀索引</p><p>按字段个数来分：单列索引、联合索引</p><h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><img src="https://i.ibb.co/p01pZH1/drawio.png" alt="index-engine" style="zoom:60%;" /><p>在创建表时，InnoDB会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引，也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+树 索引</strong>。</p><h4 id="B-树索引demo"><a href="#B-树索引demo" class="headerlink" title="B+树索引demo"></a>B+树索引demo</h4><p>创建一个商品表，以id作为主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `product`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `product_no` <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure><img src="https://i.ibb.co/MssHGDr/2023-07-12-4-17-46.png" alt="product_table" style="zoom:50%;" /><p>B+树是一种多叉树，只有叶子节点存放数据，且每个叶子节点的数据按照主键排序，每个叶子节点有前驱指针和后继指针，所有叶子节点构成一个双向链表，非叶子节点只存放索引；商品表的数据用主键索引的B+树存储如图所示：</p><img src="https://i.ibb.co/5MN10rC/B-Tree.png" alt="B+Tree" style="zoom:57%;" /><h4 id="通过主键查询数据的过程"><a href="#通过主键查询数据的过程" class="headerlink" title="通过主键查询数据的过程"></a>通过主键查询数据的过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>查询过程是这样的，B+树会自顶向下逐层进行查找：</p><ul><li>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+树的搜索逻辑，找到第二层的索引数据 (1，4，7)；</li><li>在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</li><li>在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。</li></ul><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I&#x2F;O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I&#x2F;O 操作。</p><h4 id="通过二级索引查询数据的过程"><a href="#通过二级索引查询数据的过程" class="headerlink" title="通过二级索引查询数据的过程"></a>通过二级索引查询数据的过程</h4><p>主键索引的B+树和二级索引的B+树区别如下：</p><ul><li>主键索引的B+树的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+树的叶子节点里；</li><li>二级索引的B+树的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>若把product表中的<code>product_no</code>字段设置为二级索引，则对应的B+树如下：</p><img src="https://i.ibb.co/0D8h55q/secIndex.png" alt="secIndex" style="zoom:57%;" /><p>如果用二级索引查询数据，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure><p>则会优先检索二级索引对应的B+树，找到相应的叶子节点，获取到主键值，然后通过主键索引的B+树查询到相应的叶子节点并获取数据。这就是<strong>回表</strong>，即需要查两个B+树才能查到结果数据。</p><p>若查询的目标数据本来就存储在二级索引的B+树叶子节点里，则不需要进行回表操作，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>id</code>字段本身就存储在二级索引B+树的叶子节点中，因此不需要回表；这就是<strong>覆盖索引</strong>，即只需要查一个B+树就能获得数据。</p><h4 id="为什么InnoDB选择B-树作为索引的数据结构"><a href="#为什么InnoDB选择B-树作为索引的数据结构" class="headerlink" title="为什么InnoDB选择B+树作为索引的数据结构"></a>为什么InnoDB选择B+树作为索引的数据结构</h4><ul><li><p>B+树 vs B树</p><p>B+树只在叶子节点存储数据，而B树的非叶子节点也要存储数据，所以B+树的单个节点数据量更小，在相同的IO次数下，能查询更多的节点；并且，B+树的叶子节点构成一个双向链表，适合MySQL中的范围顺序查找，B树无法做到这一点。</p></li><li><p>B+树 vs 二叉树</p><p>对于有N个叶子节点的B+树，其搜索复杂度为<code>O(logdN)</code>，其中<code>d</code>表示节点允许的最大子节点个数，一般是大于100的；而二叉树的节点所能允许的最大子节点个数为2，其搜索复杂度为<code>O(logN)</code>，因此需要更多IO次数才能查到目标。</p></li><li><p>B+树 vs Hash</p><p>Hash做等值查询时，搜索复杂度为<code>O(1)</code>，但无法实现范围查询，因此适用场景有限。</p></li></ul><h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的B+树的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的B+树的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引就是建立在主键字段上的索引，通常在建表的时候一起创建，一张表最多有一个主键索引，索引列的值不允许有空值。</p><p>建表时，创建主键索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引是建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，允许有空值。</p><p>建表时，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>建表后，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引就是建立在普通字段上的索引，没有任何要求。</p><p>建表时和建表后创建普通索引的方式分别如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为<code>char</code>、<code>varchar</code>、<code>binary</code>、<code>varbinary</code>的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>建表时和建表后创建前缀索引的方式分别如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure><h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引</li></ul><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>比如，将product表中的<code>product_no</code>和<code>name</code>字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><p>其对应的B+树如图所示：</p><img src="https://i.ibb.co/0KcPnGS/union-Index.png" alt="unionIndex" style="zoom:57%;" /><p>联合索引查询的B+树是先按<code>product_no</code>进行排序，然后在<code>product_no</code>相同的情况再按<code>name</code>字段排序。因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个<code>(a, b, c)</code>联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li><p><code>where a = 1;</code></p></li><li><p><code>where a = 1 and b = 2 and c = 3;</code></p></li><li><p><code>where b = 2 and c = 3;</code></p></li></ul><p>因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效：</p><ul><li><p><code>where b = 2;</code></p></li><li><p><code>where c = 3;</code></p></li><li><p><code>where b = 2 and c = 3;</code></p></li></ul><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>例1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> a <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。因为在<code>a &gt; 2</code>的记录范围里，<code>b</code>是无序的，不能根据<code>b = 2</code>这个条件进一步减少扫描量。</p><p>例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。虽然在<code>a &gt;= 1</code>的二级索引记录范围内，<code>b</code>是无序的，<strong>但是对于符合<code>a = 1</code>的二级索引记录的范围里，<code>b</code>字段的值是「有序」的</strong>。</p><p>例3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">8</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>查询条件为<code>2 &lt;= a &lt;= 8</code>和<code>b = 2</code>。因此类似于例2，<strong>这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><p>例4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;j%&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>与例3和例2同理，<strong>这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>对于联合索引<code>(a, b)</code>，在B+树中找到第一个满足条件的a值后，对于b值，是在联合索引里判断，还是回主键索引去判断呢？</p><p>答案是会利用索引下推，减少回表次数。具体可阅读文章<a href="https://www.brokenmind.top/2023/07/09/MySQL%E6%9E%B6%E6%9E%84/">MySQL架构</a>中关于索引下推的部分。</p><h5 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h5><p>在实际开发中，建立联合索引时要将区分度大的字段排在前面，区分度指的是某个字段不同值的个数除以表的总行数：<br>$$<br>Index Selectivity &#x3D; \frac{disctinct(column)}{count(*)}<br>$$</p><h2 id="索引的适用情况"><a href="#索引的适用情况" class="headerlink" title="索引的适用情况"></a>索引的适用情况</h2><h3 id="适用索引的场景"><a href="#适用索引的场景" class="headerlink" title="适用索引的场景"></a>适用索引的场景</h3><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+树中的记录都是排序好的。</li></ul><h3 id="不需要索引的场景"><a href="#不需要索引的场景" class="headerlink" title="不需要索引的场景"></a>不需要索引的场景</h3><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护B+树的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h2><p>常见的优化索引的方法有：前缀索引优化、覆盖索引优化、主键索引最好是自增的、防止索引失效。</p><h3 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h3><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>局限性：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引。</li></ul><h3 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+树 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><h3 id="主键索引自增"><a href="#主键索引自增" class="headerlink" title="主键索引自增"></a>主键索引自增</h3><p>在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h3 id="索引最好非空"><a href="#索引最好非空" class="headerlink" title="索引最好非空"></a>索引最好非空</h3><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来存储空间的问题。</li></ul><h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p>以下情况会发生索引失效：</p><ul><li>当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据存储</title>
      <link href="/2023/07/12/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
      <url>/2023/07/12/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据存储"><a href="#MySQL数据存储" class="headerlink" title="MySQL数据存储"></a>MySQL数据存储</h1><div class="note info modern"><p>参考文档：<a href="https://xiaolincoding.com/mysql/">小林coding</a></p></div><p>这篇文章主要记录一下MySQL的数据存储和文件结构情况。</p><hr><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下：</p><img src="https://i.ibb.co/2YDzjyM/drawio.png" alt="TableSpace" style="zoom:60%;" /><ul><li>行：记录都是按行存放的，每行记录根据不同的行格式，有不同的存储结构</li><li>页：InnoDB的数据是按照页为单位进行读写的，默认每个页的大小为16KB</li><li>区：一个区的大小为1MB，可容纳64个16KB的页，这样的话这些页在内存中的物理地址也是相邻的，那么磁盘查询B+树时就可以顺序IO而不需要随机IO</li><li>段：段可分为数据段、索引段和回滚段<ul><li>索引段：存放B+树的非叶子节点的区的集合</li><li>数据段：存放B+树的叶子节点的区的集合</li><li>回滚段：存放的是回滚数据的区的集合</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构</title>
      <link href="/2023/07/09/MySQL%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/07/09/MySQL%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><blockquote><p>参考资料：</p><p><a href="https://xiaolincoding.com/mysql">小林coding</a></p></blockquote><p>开篇文章复习一下MySQL的架构组成部分。</p><hr><p>下图展示了MySQL执行一条SQL查询语句的流程，MySQL架构可分为<strong>Server层</strong>和<strong>存储引擎层</strong>。</p><img src="https://i.ibb.co/HDj5J5Y/MySQL.png" alt="MySQL架构" style="zoom:50%;" /><ul><li>Server层：负责建立连接、分析和执行SQL。除了上图中的<strong>核心功能模块</strong>以外，所有的<strong>内置函数</strong>（如日期、数学和加密函数等）和所有的<strong>跨存储引擎的功能</strong>（如存储过程、触发器、视图等）都在Server层实现。</li><li>存储引擎层：负责数据的存储和提取。不同的存储引擎共用一个Server层，但支持的索引类型不同。从MySQL 5.5版本开始，默认的存储引擎是InnoDB。</li></ul><p>下面就SQL查询语句执行流程进行深入解析。</p><h2 id="Step-1-连接器"><a href="#Step-1-连接器" class="headerlink" title="Step 1 连接器"></a>Step 1 连接器</h2><p>用户通过<code>mysql -u $username -p</code>发起连接请求，若MySQL正常运行且用户名密码验证成功，则连接建立完毕。连接器此时会获取该用户的权限并保存，后续该用户在此连接中所做的任何操作都是基于该权限进行逻辑判断，即便管理员中途修改了这个用户的权限，也不会影响该连接。</p><ul><li><p>如何查看MySQL服务被多少客户端连接</p><p>通过<code>show processlist</code>进行查看</p><img src="https://i.ibb.co/SshYC6s/image.png" alt="processlist" style="zoom:50%;" /><p>图中可看到id为6的root用户状态为<code>Sleep</code>，即该用户连接MySQL后没有再执行过任何命令，且空闲时长为736秒。</p></li><li><p>空闲连接持续多久</p><p><code>wait_timeout</code>参数规定了空闲连接的最大空闲时长，默认是8小时；也可以通过<code>kill connection +$id</code>手动断开。</p><p>当空闲连接被服务端断开后，客户端并不会立即得知，而是当客户端发起下一个请求时，收到报错</p></li><li><p>连接数有限制吗</p><p><code>max_connections</code>参数规定了MySQL服务支持的最大连接数</p></li><li><p>MySQL长连接占用内存问题如何解决</p><p>有两种解决方案：</p><ul><li>定期断开长连接</li><li>客户端主动重置连接：通过接口函数<code>mysql_reset_connection()</code>释放内存，重置连接，且不需要重连和校验权限</li></ul></li></ul><h2 id="Step-2-查询缓存"><a href="#Step-2-查询缓存" class="headerlink" title="Step 2 查询缓存"></a>Step 2 查询缓存</h2><p><strong>这一步仅存在于MySQL 8.0之前的版本，后期版本已将查询缓存的工序删除。</strong></p><p>当MySQL收到SQL语句后，就会解析SQL的第一个字段，判断是什么类型的SQL；</p><p>如果是select语句，MySQL就会先去查询缓存（Query Cache）中查找缓存数据，看之前是否执行过这一条命令；查询缓存是以key-value形式存储在内存中的，key是SQL查询语句，value是SQL查询的结果。</p><p>如果命中查询缓存，则返回value给客户端；如果没有命中，则继续执行，并将查询的结果存入查询缓存以便后续使用。</p><p>缺点：命中率很低，且每当一个表更新操作时，这个表的查询缓存就会清空。</p><h2 id="Step-3-解析SQL"><a href="#Step-3-解析SQL" class="headerlink" title="Step 3 解析SQL"></a>Step 3 解析SQL</h2><p>执行SQL之前，解析器会先对SQL语句做解析。</p><ul><li><p>词法分析</p><p>MySQL根据输入的字符串识别出关键字，构建出SQL语法树，以便后面模块获取SQL类型、表名、字段名、查询条件等。</p></li><li><p>语法分析</p><p>根据词法分析的结果，语法解析器会根据语法规则，判断该SQL语句是否符合MySQL语法。但是表或者字段是否存在的检查，并不是在解析器中完成的。</p></li></ul><h2 id="Step-4-执行SQL"><a href="#Step-4-执行SQL" class="headerlink" title="Step 4 执行SQL"></a>Step 4 执行SQL</h2><p>每条select语句的执行分为以下三个阶段：预处理、优化、执行</p><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将<code>select *</code>中的<code>*</code>扩展为表上的所有列</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><ul><li>主要负责确定SQL查询语句的执行方案，比如表里存在多个索引时，优化器会基于查询成本的考虑，来决定使用哪个索引。</li><li>可以在查询语句最前面加<code>explain</code>来查看优化器对这个SQL语句制定的执行计划，包括选用的索引等。</li></ul><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行过程执行器会与存储引擎以记录为单位进行交互，具体有三种执行方式</p><h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句用到了主键索引，而且是等值查询，因此优化器决定用主键索引执行该SQL。那么执行器与存储引擎的交互流程如下：</p><ul><li>执行器第一次查询，会调用<code>read_first_record</code>函数指针指向的函数，优化器选择的访问类型为const，这个函数指针被指向为InnoDB引擎索引查询的接口，把条件<code>id=1</code>交给存储引擎，让存储引擎定位符合条件的第一条记录；</li><li>存储引擎通过主键索引的B+树定位到<code>id=1</code>的第一条记录，若记录不存在，则向执行器报告错误，结束此次查询；若记录存在，则返回给执行器；</li><li>执行器从存储引擎读到记录后，判断记录是否符合查询条件，若符合则返回给客户端，否则跳过该记录；</li><li>执行器查询的过程是一个<code>while</code>循环，所以仍会继续查询，但由于不再是第一次查询，因此会调用<code>read_record</code>函数指针指向的函数，因为优化器选择的访问类型为const，所以该函数指针被指向为一个永远返回<code>-1</code>的函数，调用该函数后，执行器就会退出循环，结束此次查询。</li></ul><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure><p>这条查询语句没有用到索引，因此优化器会选择ALL的访问类型，即全表扫描。那么执行器与存储引擎的交互流程如下：</p><ul><li>执行器第一次查询，会调用<code>read_first_record</code>函数指针指向的函数，因为优化器选择的访问类型为all，这个函数指针被指向为InnoDB引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的是不是<code>aaa</code>，如果不是则跳过；如果是则将记录发给客户端（Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个<code>while</code>循环，所以还会再查一次，会调用<code>read_record</code>函数指针指向的函数，因为优化器选择的访问类型为all，该函数指针指向的还是InnoDB引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器，执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器返回读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><h4 id="索引下推（MySQL-gt-x3D-5-6）"><a href="#索引下推（MySQL-gt-x3D-5-6）" class="headerlink" title="索引下推（MySQL &gt;&#x3D; 5.6）"></a>索引下推（MySQL &gt;&#x3D; 5.6）</h4><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将Server层负责的事情，交给存储引擎层去处理了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>假设<code>mytable</code>表中，<code>age</code>和<code>reward</code>字段建立了联合索引<code>(age, reward)</code>。</p><p>当联合索引碰到范围查询时就会停止匹配，即<code>age</code>字段能走索引，但<code>reward</code>字段无法利用索引。</p><p>在MySQL 5.6之前，不使用索引下推，执行器与存储引擎的交互是这样的：</p><ul><li>Server层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到<code>age &gt; 20</code>的第一条记录；</li><li>存储引擎根据二级索引的B+树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给Server层；</li><li>Server层在判断该记录的<code>reward</code>是否等于10000，如果成立则将其发送给客户端；否则跳过该记录；</li><li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给Server层；</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给Server，接着Server再判断该记录的reward是否等于10000。</p><p>使用索引下推后，判断记录的reward是否等于10000的工作交给了存储引擎层，过程如下：</p><ul><li>Server层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到<code>age &gt; 20</code>的第一条记录；</li><li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward是否等于10000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给Server层。</li><li>Server层再判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>使用了索引下推后，虽然<code>reward</code>列无法使用到联合索引，但是因为它包含在联合索引<code>(age, reward)</code>里，所以直接在存储引擎过滤出满足 <code>reward = 10000</code>的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git的一些问题解决</title>
      <link href="/2023/07/04/%E8%A7%A3%E5%86%B3git%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/04/%E8%A7%A3%E5%86%B3git%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Git的一些问题解决"><a href="#关于Git的一些问题解决" class="headerlink" title="关于Git的一些问题解决"></a>关于Git的一些问题解决</h1><p>这篇文章记录一下自己在使用git的过程中碰到的一些问题及其解决方法。</p><hr><h2 id="网络超时"><a href="#网络超时" class="headerlink" title="网络超时"></a>网络超时</h2><p>在terminal里进行<code>git clone</code>和<code>git push</code>时经常无响应，或者连接超时，可用如下命令通过代理解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>这里的7890是我用的clash代理端口，可根据实际情况更换。</p><hr><h2 id="账号认证"><a href="#账号认证" class="headerlink" title="账号认证"></a>账号认证</h2><p>在2021年8月之后，Github不再支持账号+密码的认证方式，因此需要用到token来替代密码。</p><p>但每次做<code>push</code>都输入一遍token非常麻烦，因此可修改git的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper <span class="string">&#x27;cache --timeout=EXPIRE_TIME&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，<code>EXPIRE_TIME</code>是指定的token缓存过期时间，单位为秒。</p><hr><h2 id="Hexo博客更新"><a href="#Hexo博客更新" class="headerlink" title="Hexo博客更新"></a>Hexo博客更新</h2><p>更新博客时，发现<code>hexo d</code>一直卡住，最终超时。用代理的方法解决了这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discord Bot JavaScript</title>
      <link href="/2023/06/16/Discord%20Bot%20JavaScript/"/>
      <url>/2023/06/16/Discord%20Bot%20JavaScript/</url>
      
        <content type="html"><![CDATA[<h1 id="Discord-Bot-JavaScript"><a href="#Discord-Bot-JavaScript" class="headerlink" title="Discord Bot JavaScript"></a>Discord Bot JavaScript</h1><p>用JavaScript实现一个Discord Bot，实现生成艺术二维码的功能。</p><blockquote><p>参考文档：<a href="https://discordjs.guide/">Discord的JavaScript开发文档</a></p><p>代码仓库：<a href="https://github.com/Mitsui921/DiscordBot">https://github.com/Mitsui921/DiscordBot</a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>开启Discord群组的开发者模式</p></li><li><p>前往<a href="https://discord.com/developers/applications">Discord开发者网站</a>新建一个应用</p></li><li><p>配置好Bot的权限列表，留存Bot的token-key，注意打开这些权限</p><img src="https://i.ibb.co/8j9Xdty/iq-Edplg-PAh-ZLj78.png" alt="Bot权限" style="zoom:50%;" /></li><li><p>生成OAuth2的URL，选中相应的URL生成域，生成URL并打开即可将Bot加入到群组中</p><img src="https://i.ibb.co/f9nTr6n/9l-EAv4-Uy-Xk-Bzpw-M.png" alt="URL生成域" style="zoom: 67%;" /></li></ul><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>通过JS对Bot的功能进行开发，可采用在线开发和本地开发两种模式。为了图方便，就用了在线IDE：<a href="https://replit.com/">Replit</a>开发的方式。</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>BotCommand<br>├── commands<br>│   └── generate.js<br>├── index.js<br>├── deploy-commands.js<br>├── config.json<br>├── package.json<br>└── package-lock.json</p><p><code>index.js</code>为入口，终端运行<code>node index.js</code>启动项目</p><h3 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h3><p>在根目录下新建一个<code>config.json</code>文件，分别填入对应的三个字符串，完成与机器人端的连接</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_BOT_TOKEN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;clientId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_APPLICATION_ID&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;guildId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_SERVER_ID&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="SlashCommands部署"><a href="#SlashCommands部署" class="headerlink" title="SlashCommands部署"></a>SlashCommands部署</h3><p>为了实现在聊天框打出<code>/</code>即可唤醒命令的功能，需要先定义这些命令。</p><p>在根目录下新建一个<code>commands</code>文件夹，保存所有的命令（后期随着命令的增加，也可以再增设分类的子文件夹）；</p><p>在<code>commands</code>文件夹下，新建一个<code>generate.js</code>，在里面实现“generate”斜杠命令的逻辑。</p><p>从官方开发文档获取<code>deploy-commands.js</code>，执行<code>node deploy-commands.js</code>即可将定义的命令部署到机器人端。</p><h3 id="命令逻辑实现"><a href="#命令逻辑实现" class="headerlink" title="命令逻辑实现"></a>命令逻辑实现</h3><p>命令的逻辑实现主要是在<code>index.js</code>以及<code>generate.js</code>两个文件中编写。</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li><strong>Step 1</strong>: 群组用户能够发起<code>generate</code>命令，该命令需包含三个参数：<code>prompt</code>、<code>url</code>、<code>weight</code>，分别表示Stable Diffusion算法模型的关键字、原始的二维码链接、权重</li><li><strong>Step 2</strong>: Bot接收该命令后，在执行过程中显示“响应中”状态</li><li><strong>Step 3</strong>: SD算法生成图片完成后，Bot需在群组中回复以下内容：<ul><li>@发起该命令的用户</li><li>生成的艺术二维码图片</li><li>产品文本信息与提示</li><li>“重新生成”按钮</li></ul></li><li><strong>Step 4</strong>: “重新生成”按钮需完成如下功能：<ul><li>群组内任意用户均可点击</li><li>点击按钮后弹出一个窗口，该窗口有三个填写栏，分别对应上述的三个参数，初始显示为上一次生成图像的三个参数值</li><li>用户可更改这些参数，并提交给Bot</li><li>Bot接收后重复Step3的功能</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discord </tag>
            
            <tag> Tools </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记</title>
      <link href="/2023/06/12/Docker/"/>
      <url>/2023/06/12/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>开篇文章记录一下学习Docker的过程和实际使用中碰到的坑。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Docker作为容器技术的一种具体应用，和平时常用的虚拟机技术存在一些区别。</p><h3 id="容器vs虚拟机"><a href="#容器vs虚拟机" class="headerlink" title="容器vs虚拟机"></a>容器vs虚拟机</h3><p>容器和虚拟机都是常用的资源虚拟化技术。在虚拟化的过程中，RAM、CPU、磁盘或者网络等系统单一资源可以虚拟化成多个资源。容器和虚拟机之间的主要区别在于，虚拟机将整个计算机虚拟化到硬件层面，而容器只虚拟化到操作系统级别以上的软件层面。因此，容器技术的迭代速度更快、生态系统比较完善，但可能存在共享主机漏洞；虚拟机技术则能实现完全隔离安全，但在迭代速度和存储成本上代价更大。</p><img src="https://i.ibb.co/vXmcV2p/U3x-VMksbn2-AQj-TW.png" alt="容器vs虚拟机" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 运维 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity笔记</title>
      <link href="/2023/06/08/Solidity/"/>
      <url>/2023/06/08/Solidity/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h1><p>开篇文章记录实习期间学习Solidity编程的相关内容。</p><blockquote><p>参考页面：</p><p><a href="https://learnblockchain.cn/docs/solidity/index.html">Solidity中文文档</a>（v0.8.17）</p><p><a href="https://docs.soliditylang.org/en/v0.8.20/">Solidity官方文档</a>（v0.8.20）</p></blockquote><hr><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在学习Solidity语言之前，需要了解一些前置知识，包括：</p><ul><li>区块链基础</li><li>以太坊虚拟机</li></ul><p>另外，若想要深入理解智能合约以及虚拟机是如何运行的，可以参考这两篇文章：<a href="https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/">完全理解以太坊智能合约</a>和<a href="https://learnblockchain.cn/2019/04/09/easy-evm/">深入浅出以太坊虚拟机</a>。</p><h3 id="智能合约示例"><a href="#智能合约示例" class="headerlink" title="智能合约示例"></a>智能合约示例</h3><h4 id="存储合约示例"><a href="#存储合约示例" class="headerlink" title="存储合约示例"></a>存储合约示例</h4><p>将一个数据保存到链上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="货币合约示例"><a href="#货币合约示例" class="headerlink" title="货币合约示例"></a>货币合约示例</h4><p>一个最简单的加密货币</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    // 关键字“public”让这些变量可以从外部读取</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    // 轻客户端可以通过事件针对变化作出高效的反应</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    // 这是构造函数，只有当合约创建时运行</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address receiver, uint amount) public &#123;</span><br><span class="line">        require(msg.sender == minter);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Errors allow you to provide information about</span><br><span class="line">    // why an operation failed. They are returned</span><br><span class="line">    // to the caller of the function.</span><br><span class="line">    error InsufficientBalance(uint requested, uint available);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function send(address receiver, uint amount) public &#123;</span><br><span class="line">        if (amount &gt; balances[msg.sender])</span><br><span class="line">            revert InsufficientBalance(&#123;</span><br><span class="line">                requested: amount,</span><br><span class="line">                available: balances[msg.sender]</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码可以等学习完语法回头再看。</p><hr><h2 id="Solidity详解"><a href="#Solidity详解" class="headerlink" title="Solidity详解"></a>Solidity详解</h2><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>相当于OOP语言中的类，具有可继承性，可以包含状态变量、函数、事件、错误、结构体等声明</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永久存储在合约存储中的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract TinyStorage &#123;</span><br><span class="line">uint storedXlbData; // 状态变量</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是代码的可执行单元，可以在合约内部或者外部定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.1 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">// Mybid function defined inside of a contract</span><br><span class="line">    function Mybid() public payable &#123; </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Helper function defined outside of a contract</span><br><span class="line">function helper(uint x) pure returns (uint) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Topia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊研究</title>
      <link href="/2023/06/07/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
      <url>/2023/06/07/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="以太坊研究"><a href="#以太坊研究" class="headerlink" title="以太坊研究"></a>以太坊研究</h1><p>开篇文章记录实习期间对以太坊相关技术的研究与学习进展。</p><p>整个技术概念和背景比较多，因此在记录的时候以工作&#x2F;研究的来源作为分类依据，可能在部分内容上有所重复。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上的去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。以太坊是区块链，区块链不是以太坊。</p><hr><h2 id="区块链基础"><a href="#区块链基础" class="headerlink" title="区块链基础"></a>区块链基础</h2><blockquote><p>参考页面：</p><p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/index.html">FISCO BCOS 技术文档</a></p></blockquote><h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p>区块链作为一个分布式系统，可以由不同的节点共同参与计算、共同见证交易的执行过程，并确认最终计算结果。协同这些松散耦合、互不信任的参与者达成信任关系，并保障一致性，持续性协作的过程，可以抽象为“共识”过程，所牵涉的算法和策略统称为共识机制。</p><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>节点的标识采用公私钥机制，生成一串唯一的NodeID，以保证它在网络上的唯一性。</p><p>根据对计算的参与程度和数据的存量，节点可分为共识节点和观察节点。共识节点会参与到整个共识过程，作为记账者打包区块、作为验证者验证区块以完成共识过程。观察节点不参与共识，同步数据，进行验证并保存，但可以作为数据服务者提供服务。</p><h4 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h4><p>共识算法需要解决几个核心问题：</p><ol><li>选出在整个系统中具有记账权的角色，做为leader发起一次记账。</li><li>参与者采用不可否认和不能篡改的算法，进行多层面验证后，采纳leader给出的记账。</li><li>通过数据同步和分布式一致性协作，保证所有参与者最终收到的结果都是一致且无错的。</li></ol><p>区块链领域常见的共识算法有公链常用的工作量证明（Proof of Work）、权益证明（Proof of Stake）、委托权益证明（Delegated Proof of Stake），以及联盟链常用的实用性拜占庭容错共识PBFT（Practical Byzantine Fault Tolerance），Raft等</p><hr><h2 id="以太坊白皮书"><a href="#以太坊白皮书" class="headerlink" title="以太坊白皮书"></a>以太坊白皮书</h2><blockquote><p>参考页面：</p><p><a href="https://ethereum.org/zh/whitepaper/">官方白皮书</a></p></blockquote><h3 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h3><p>以太坊通过“账户”来组成系统的状态，每个账户有一个20字节的地址，状态转换是指账户之间价值和信息的直接转移。一个以太坊账户包含四个字段：</p><ul><li>nonce，用于确保每笔交易只能处理一次的计数器</li><li>账户当前的以太币余额</li><li>账户的合约代码（不一定有）</li><li>账户的存储（默认空）</li></ul><p>以太币是以太坊内部的主要加密燃料，用于支付交易费。 通常有两类账户：由<strong>私钥</strong>控制的<strong>外部账户</strong>以及由其<strong>合约代码</strong>控制的<strong>合约账户</strong>。 外部账户没有代码，持有者可以通过创建和签署交易从外部账户发送消息；在合约账户中，每次合约账户收到消息时，其代码都会激活，允许该账户读取和写入内部存储，继而发送其他消息或创建合约。</p><p>这里面的合约是存在于以太坊执行环境中的”自治代理“。当被交易或消息“触发”时，合约总是执行特定的代码段，并直接控制自已的以太币余额和键&#x2F;值存储，以跟踪永久变量。</p><h3 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h3><ol><li><p>在以太坊中，术语“交易”用来指代已签名的数据包，数据包存储着将要从外部账户发送的消息。 交易包含如下参数：</p><ul><li><p>消息接收者</p></li><li><p>用于识别发送者身份的签名</p></li><li><p>从发送者转账到接收者的以太币金额</p></li><li><p>一个可选数据字段</p></li><li><p><code>STARTGAS</code> 值，表示允许交易运行的最大计算步骤数</p></li><li><p><code>GASPRICE</code> 值，表示发送者每个计算步骤支付的费用</p></li></ul><p><code>STARTGAS</code> 和<code>GASPRICE</code> 字段对于以太坊的反拒绝服务模型很重要，前者可以防止代码中出现无意或者恶意的无限循环或其他计算浪费，后者则会要求攻击者支付其攻击所消耗的资源对应的费用。</p></li><li><p>合约能够向其他合约发送“消息”。 消息是从未序列化的虚拟对象，只存在于以太坊执行环境中。 消息包含如下参数：</p><ul><li>消息发送者（隐含的）</li><li>消息接收者</li><li>随消息一起转账的以太币金额</li><li>一个可选数据字段</li><li><code>STARTGAS</code> 值</li></ul></li></ol><h3 id="以太坊转换函数"><a href="#以太坊转换函数" class="headerlink" title="以太坊转换函数"></a>以太坊转换函数</h3><img src="https://i.ibb.co/PW2ktVS/Wpv92-GNxh-Fwtgu-B.png" alt="以太坊状态转换" /><p>以太坊状态转换函数<code>APPLY(S,TX) -&gt; S&#39;</code>可如下定义：</p><ol><li>检查交易格式是否正确、签名是否有效以及Nonce值是否与发送者账户的Nonce值匹配；若否，返回错误</li><li>通过<code>STARTGAS*GASPRICE</code>计算出交易费用，并从签名中确认发送地址。从发送者的账户余额中减去费用，并增加发送者的Nonce值；若账户余额不足，则返回错误</li><li>初始化<code>GAS=STARTGAS</code>，并根据交易中的字节数量为每个字节扣除相应数量的燃料</li><li>将交易数值从发送者账户转移至接收账户；若接收账户不存在，则创建该账户；若接收账户是合约，则运行该合约的代码，直到代码执行完毕或者燃料耗尽</li><li>若由于发送者余额不足或代码运行耗尽了燃料，而导致转账失败，则回滚支付费用之外的所有状态变化，并将费用支付给矿工账户</li><li>若一切正常，则将剩余燃料的费用退还给发送者，并将为所消耗燃料而支付的费用发送给矿工</li></ol><p>Example：</p><p>假设合约的存储一开始为空，发送了一个价值为10个以太币的交易，消耗2000份燃料，燃料单价为0.001个以太币，数据包含64个字节，字节0-31表示数字2，字节32-63表示字符串CHARLIE，则状态转换函数的执行过程如下：</p><ol><li>检查交易是否有效、格式是否正确</li><li>检查交易发起者是否至少有2000*0.001&#x3D;2个以太币，若有，则从发送者账户中扣除2个以太币</li><li>初始化燃料&#x3D;2000份，假设交易长度为170个字节，每个字节消耗5份燃料，减去850份燃料，剩余1150份燃料</li><li>从发送者账户减去10个以太币并增加到合约账户</li><li>运行合约代码，假设运行代码消耗187份燃料，则剩余燃料为963份</li><li>向发送者账户增加963*0.001&#x3D;0.963个以太币，并返回产生的状态</li></ol><hr><h2 id="相关技术文档"><a href="#相关技术文档" class="headerlink" title="相关技术文档"></a>相关技术文档</h2><blockquote><p>参考页面：</p><p><a href="https://ethereum.org/zh/developers/docs/">官方开发文档</a></p></blockquote><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>区块是一批交易的组合，多个区块连接在一起形成区块链，并且每个区块包含上一个区块的哈希，这样可以有效地防止欺诈行为，因为当某个区块被篡改后，其后面的所有区块都会无效。</p><p>区块的存在是为了确保以太坊网络中的所有参与者保持同步状态并就交易的确切历史达成共识。交易和哈希被存放在一个区块内，并通过间歇提交的方式给所有参与者足够的时间来达成共识。</p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>为了维护交易历史，每个区块都被严格排序（创建的每个新区块都包含一个其父块的引用），区块内部保存的交易也严格排序；某位验证者在网络上构建完区块后，区块将传播到整个网络，所有的节点都会将该区块添加到其区块链的末尾，然后挑选新的验证者来创建下一个区块。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>一个区块分为区块头和区块体两个部分。</p><p>区块头包含的字段信息如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot：区块所属的时隙</span><br><span class="line">proposer<span class="emphasis">_index：提出区块的验证者的ID</span></span><br><span class="line"><span class="emphasis">parent_</span>root：父区块的哈希值</span><br><span class="line">state<span class="emphasis">_root：状态对象的根哈希</span></span><br></pre></td></tr></table></figure><p>区块体包含的字段信息如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">randao<span class="emphasis">_reveal：用于选择下一个区块提议者的值</span></span><br><span class="line"><span class="emphasis">eth1_</span>data：有关存款合约的信息</span><br><span class="line">graffiti：用于标记区块的任意数据</span><br><span class="line">proposer<span class="emphasis">_slashings：将要受到惩罚的验证者的列表</span></span><br><span class="line"><span class="emphasis">attester_</span>slashings：将要受到惩罚的验证者的列表</span><br><span class="line">attestations：支持当前区块的认证列表</span><br><span class="line">deposits：存入存款合约中的新存款的列表</span><br><span class="line">voluntary<span class="emphasis">_exits：将要退出网络的验证者的列表</span></span><br><span class="line"><span class="emphasis">sync_</span>aggregate：用于服务轻客户端的验证者子集</span><br><span class="line">execution<span class="emphasis">_payload：由执行客户端传送的交易</span></span><br></pre></td></tr></table></figure><h3 id="以太坊虚拟机EVM"><a href="#以太坊虚拟机EVM" class="headerlink" title="以太坊虚拟机EVM"></a>以太坊虚拟机EVM</h3><p>以太坊虚拟机是所有以太坊帐户和智能合约依存的环境。 当智能合约被编译成二进制文件后，被部署到以太坊上。用户通过调用智能合约的接口，来触发智能合约的执行操作。EVM执行智能合约的代码，修改当前以太坊网络上的数据（状态）。被修改的数据，会通过共识，确保一致性。</p><blockquote><p>参考页面：</p><p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">以太坊虚拟机图解</a></p><p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/virtual_machine/evm.html">FISCO BCOS技术文档</a></p></blockquote><p>EVM与节点的交互，抽象出EVMC接口标准（EVM Connector API）。EVMC主要定义了两种调用的接口：</p><ul><li>Instance接口：节点调用EVM的接口，定义了节点对虚拟机的操作，包括创建、销毁、设置等</li><li>Callback接口：EVM回调节点的接口，定义了EVM对节点的操作，主要是对状态的读写、区块信息的读写等</li></ul><p>EVM本身不保存状态数据，节点通过instance接口操作EVM，EVM反过来，调Callback接口，对节点的状态进行操作。</p><img src="https://i.ibb.co/QmqgQf4/Ady-Qf-Ioi-Tb-FJB7-P.png" alt="EVMC接口" style="zoom:70%;" /><h3 id="节点和客户端"><a href="#节点和客户端" class="headerlink" title="节点和客户端"></a>节点和客户端</h3><p>以太坊是一个由计算机组成的分布式网络，这些计算机即为节点；可验证区块和交易数据的软件在这些节点上运行，即成为客户端。</p><p>合并后的以太坊由两部分组成：执行层和共识层。这两层网络是由不同的客户端软件运行的。</p><ul><li>执行客户端：侦听网络中广播的新交易，在EVM中执行它们，并保存所有当前以太坊数据的最新状态和数据库。</li><li>共识客户端：实现了权益证明共识算法，使网络能够根据来自执行客户端的经验证数据达成一致。</li></ul><h3 id="共识机制-1"><a href="#共识机制-1" class="headerlink" title="共识机制"></a>共识机制</h3><p>以太坊采用的是权益证明的共识算法。</p><p><strong>权益证明</strong>：</p><ul><li>验证节点必须向存款合约中质押 32 个以太币，作为抵押品防止发生不良行为</li><li>在每个时隙（12 秒的时间间隔）中，会随机选择一个验证者作为区块提议者。 他们将交易打包并执行，然后确定一个新的“状态”。 他们将这些信息包装到一个区块中并传送给其他验证者。</li><li>其他获悉新区块的验证者再次执行区块中包含的交易，确定他们同意对全局状态提出的修改。 假设该区块是有效的，验证者就将该区块添加进各自的数据库。</li><li>如果验证者获悉在同一时隙内有两个冲突区块，他们会使用自己的分叉选择算法选择获得最多质押以太币支持的那一个区块。</li></ul><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>智能合约是一个运行在以太坊链上的程序，其本身也是一个合法账户，可以成为交易的对象。但无法被人操控，个人用户可以通过提交交易来执行智能合约的某一个函数与其进行交互，且该交互是不可逆的，即无法被删除或回滚。</p><p>任何人都可以编写智能合约并部署到区块链网络上，只需要有足够的以太币即可。</p><h4 id="智能合约语言"><a href="#智能合约语言" class="headerlink" title="智能合约语言"></a>智能合约语言</h4><p>主要用的是Solidity和Vyper，较为主流的是Solidity语言，以下是Solidity实现一个合约的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;= 0.7.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    // The keyword &quot;public&quot; makes variables</span><br><span class="line">    // accessible from other contracts</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    // Events allow clients to react to specific</span><br><span class="line">    // contract changes you declare</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    // Constructor code is only run when the contract</span><br><span class="line">    // is created</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Sends an amount of newly created coins to an address</span><br><span class="line">    // Can only be called by the contract creator</span><br><span class="line">    function mint(address receiver, uint amount) public &#123;</span><br><span class="line">        require(msg.sender == minter);</span><br><span class="line">        require(amount &lt; 1e60);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Sends an amount of existing coins</span><br><span class="line">    // from any caller to an address</span><br><span class="line">    function send(address receiver, uint amount) public &#123;</span><br><span class="line">        require(amount &lt;= balances[msg.sender], &quot;Insufficient balance.&quot;);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>address public minter</code> 和 <code>mapping (address =&gt; uint) public balances</code> 分别定义了一个公共地址变量和一个公共映射变量，可以从其他合约访问它们。</li><li><code>event Sent</code> 定义了一个事件，用于在某些特定情况下通知客户端。</li><li><code>constructor</code> 函数是合约创建时运行的构造函数。</li><li><code>function mint</code> 函数用于创建新的加密货币，并将其发送到指定的地址。只有合约创建者可以调用此函数。</li><li><code>function send</code> 函数用于从任何调用者向指定地址发送现有的加密货币。</li><li>两个函数中都使用了 <code>require</code> 语句进行条件检查，确保调用者有足够的余额或满足其他要求，否则函数将抛出异常。</li></ul><h4 id="智能合约结构"><a href="#智能合约结构" class="headerlink" title="智能合约结构"></a>智能合约结构</h4><p>合约的任何数据都必须指定分配到一个位置：要么是存储，要么是内存。具体内容可参考另一篇关于Solidity的文章（<a href="https://www.brokenmind.top/2023/06/08/Solidity/">Solidity笔记</a>）</p><ul><li><p>环境变量</p><p>除了用户自定义的变量，还有一些特殊的全局变量，用于提供有关区块链或当前交易的信息，例如：</p><ul><li><code>block.timestamp</code>：uint256类型，当前区块的时间戳</li><li><code>msg.sender</code>：address类型，当前调用消息的发送者</li></ul></li><li><p>View函数</p><p>View函数必须保证不会修改状态，以下操作被认为是修改状态：</p><ul><li>修改状态变量</li><li>产生事件</li><li>创建其他合约</li><li>使用<code>selfdestruct</code></li><li>通过调用发送以太币</li><li>调用任何未标记为view或者pure的函数</li><li>使用底层调用</li><li>使用包含某些操作码的内联程序组</li></ul></li><li><p>构造函数</p><p><code>constructor</code> 函数只在首次部署合约时执行一次。 与许多OOP语言中的 <code>constructor</code> 函数类似，状态变量会初始化到指定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化合约数据，设置 `owner`为合约的创建者。</span><br><span class="line">constructor() public &#123;</span><br><span class="line">    // 所有智能合约依赖外部交易来触发其函数。</span><br><span class="line">    // `msg` 是一个全局变量，包含了给定交易的相关数据，</span><br><span class="line">    // 例如发送者的地址和交易中包含的 ETH 数量</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义函数</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt;=0.6.0</span><br><span class="line"></span><br><span class="line">contract ExampleDapp&#123;</span><br><span class="line">    string dapp_name;</span><br><span class="line">    </span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        dapp_name = &quot;Example Dapp&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function read_name() public view returns(string)&#123;</span><br><span class="line">        return dapp_name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function update_name(string value) public&#123;</span><br><span class="line">        dapp_name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="智能合约库"><a href="#智能合约库" class="headerlink" title="智能合约库"></a>智能合约库</h4><p>通过<code>import</code>+路径的方式导入其他合约或者包</p>]]></content>
      
      
      <categories>
          
          <category> Topia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024秋招记录</title>
      <link href="/2023/06/06/2024%E7%A7%8B%E6%8B%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/06/06/2024%E7%A7%8B%E6%8B%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="2024秋招记录"><a href="#2024秋招记录" class="headerlink" title="2024秋招记录"></a>2024秋招记录</h1><blockquote><p>尽管只使用了轻轻的力，平静的日子还是像冰球一样一下子被抛了好远。</p></blockquote><p>打算开一篇文章记录一下自己今年秋招的面试复盘，暑期实习的面试其实也比较多，但怠惰了没去做记录。</p><hr><h2 id="私企"><a href="#私企" class="headerlink" title="私企"></a>私企</h2><div class="note success flat"><p>TP-LINK</p></div><p>提前批 - 软开 - 杭州</p><ul><li>23年5月26日，测评笔试（行测+选择+简答+编程）</li><li>23年6月7日，一面 25min<ul><li>自我介绍</li><li>实习</li><li>单点登录</li><li>跨域</li><li>反向代理</li><li>session的存储</li><li>Spring注解，启动类注解源码</li><li>MyBatis中$和#的区别</li><li>OpenStack的组件</li></ul></li><li>23年6月13日，二面 25min<ul><li>自我介绍</li><li>项目</li><li>兴趣爱好</li></ul></li></ul><div class="note success flat"><p>三一</p></div><p>提前批 - 软开 - 昆山</p><ul><li>23年6月9日，笔试</li></ul><div class="note success flat"><p>友塔游戏</p></div><p>正式批 - 游戏服务端开发 - 上海</p><ul><li>23年7月11日，笔试</li><li>23年7月22日，感谢信</li></ul><div class="note success flat"><p>星环科技</p></div><p>提前批 - Java后端 - 上海</p><ul><li>23年8月6日，笔试</li></ul><div class="note success flat"><p>虹软</p></div><p>提前批 - 云服务端开发 - 杭州</p><ul><li>23年8月20日，笔试</li></ul><div class="note success flat"><p>SHEIN</p></div><p>提前批 - 数据库工程师 - 南京</p><div class="note success flat"><p>地平线</p></div><p>提前批 - 后端开发（云服务） - 南京</p><div class="note success flat"><p>星辉游戏</p></div><p>正式批 - Java服务端开发 - 广州</p><ul><li>23年8月4日，感谢信</li></ul><div class="note success flat"><p>华钦科技</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>最右</p></div><p>正式批 - 后台开发 - 上海</p><div class="note success flat"><p>极氪</p></div><p>提前批 - 后端开发 - 杭州</p><div class="note success flat"><p>新中大科技</p></div><p>正式批 - Java开发 - 杭州</p><div class="note success flat"><p>呦尔哈</p></div><p>正式批 - 服务器开发 - 上海</p><div class="note success flat"><p>大疆</p></div><p>正式批 - 后端开发 - 深圳</p><ul><li>23年8月6日，笔试</li></ul><div class="note success flat"><p>网易雷火</p></div><p>正式批 - 后端开发 - 杭州</p><ul><li>23年8月20日，笔试</li></ul><div class="note success flat"><p>恒生电子</p></div><p>正式批 - Java开发 - 杭州</p><div class="note success flat"><p>微派网络</p></div><p>正式批 - 服务器开发 - 武汉</p><div class="note success flat"><p>招银网络科技</p></div><p>正式批 - 后端开发 - 杭州</p><div class="note success flat"><p>4399</p></div><p>正式批 - Java后端 - 广州</p><ul><li>23年8月14日，笔试</li></ul><div class="note success flat"><p>特斯拉</p></div><p>正式批 - 软件开发 - 上海</p><div class="note success flat"><p>荣耀</p></div><p>正式批 - 互联网应用软件开发 - 南京</p><div class="note success flat"><p>达实智能</p></div><p>正式批 - 软件开发 - 深圳</p><div class="note success flat"><p>科大讯飞</p></div><p>正式批 - Java开发 - 合肥</p><ul><li>23年8月13日，笔试</li></ul><div class="note success flat"><p>作业帮</p></div><p>正式批 - 后端开发 - 北京</p><div class="note success flat"><p>帆软</p></div><p>提前批 - 后台开发 - 无锡</p><ul><li>23年8月9日，笔试</li></ul><div class="note success flat"><p>佳期投资</p></div><p>正式批 - 核心系统工程师 - 上海</p><div class="note success flat"><p>搜狐畅游</p></div><p>正式批 - Java开发 - 北京</p><ul><li>23年8月16日，笔试<ul><li>5个选择 + 5个简答</li></ul></li><li>23年8月16日，一面<ul><li>实习</li><li>项目</li><li>PostgreSQL、云数据库 没用过</li><li>OLTP和OLAP 不了解<ul><li>OLAP是联机分析处理，主要用来分析聚合数据；OLTP是联机事务处理，主要用来处理数据库事务</li></ul></li><li>undo log和redo log的区别</li><li>SpringBoot相比于Spring多了什么关键特性</li></ul></li></ul><div class="note success flat"><p>用友</p></div><p>提前批 - Java开发 - 北京</p><ul><li>23年8月21日，笔试</li></ul><div class="note success flat"><p>联想</p></div><p>正式批 - Java开发 - 上海</p><ul><li>23年8月12日，笔试</li></ul><div class="note success flat"><p>唯品会</p></div><p>正式批 - Java开发 - 广州</p><div class="note success flat"><p>茄子科技</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>杉数科技</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>搜狐</p></div><p>正式批 - 后端开发 - 北京</p><div class="note success flat"><p>合合信息</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>雷霆游戏</p></div><p>正式批 - Java开发 - 深圳</p><div class="note success flat"><p>东方财富</p></div><p>正式批 - Java开发 - 上海&#x2F;南京</p><div class="note success flat"><p>经纬恒润</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>完美世界</p></div><p>正式批 - Java开发 - 北京</p><div class="note success flat"><p>高德地图</p></div><p>正式批 - Java开发 - 北京</p><div class="note success flat"><p>影石</p></div><p>正式批 - 后端开发 - 深圳</p><div class="note success flat"><p>智元研究院</p></div><p>正式批 - 软件开发 - 杭州</p><div class="note success flat"><p>海康威视</p></div><p>正式批 - 软件开发 - 杭州</p><div class="note success flat"><p>美团</p></div><p>正式批 - 后端&#x2F;软开&#x2F;测开 - 上海</p><ul><li>23年8月19日，笔试</li></ul><div class="note success flat"><p>得物</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>汇川技术</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>米哈游</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>交银金科</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>TPLink联洲</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>度小满</p></div><p>正式批 - Java开发 - 北京</p><div class="note success flat"><p>微众银行</p></div><p>正式批 - Java开发 - 深圳</p><div class="note success flat"><p>梦加网络</p></div><p>正式批 - Java服务端开发 - 厦门</p><div class="note success flat"><p>游卡</p></div><p>正式批 - 应用服务端开发 - 杭州</p><div class="note success flat"><p>神州信息</p></div><p>正式批 - Java开发 - 北京</p><div class="note success flat"><p>realme</p></div><p>正式批 - Java开发 - 深圳</p><div class="note success flat"><p>凡岛网络</p></div><p>正式批 - Java开发 - 广州</p><div class="note success flat"><p>乾象投资</p></div><p>正式批 - 软件开发 - 上海</p><div class="note success flat"><p>喜马拉雅</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>博世</p></div><p>正式批 - 后端开发 - 无锡</p><div class="note success flat"><p>蔚来</p></div><p>正式批 - 应用软件开发 - 上海</p><div class="note success flat"><p>信也科技</p></div><p>正式批 - Java后端 - 上海</p><div class="note success flat"><p>依图</p></div><p>正式批 - 后端开发 - 上海</p><div class="note success flat"><p>众安保险</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>数禾科技</p></div><p>正式批 - Java开发 - 上海</p><div class="note success flat"><p>Momenta</p></div><p>正式批 - 后端开发 - 苏州</p><div class="note success flat"><p>美的</p></div><p>正式批 - Java开发 - 无锡</p><div class="note success flat"><p>小米</p></div><p>正式批 - Java开发 - 南京</p><div class="note success flat"><p>九号公司</p></div><p>正式批 - Java后端 - 北京</p><hr><h2 id="国企"><a href="#国企" class="headerlink" title="国企"></a>国企</h2><div class="note success flat"><p>811所</p></div><p>正式批 - 信息系统开发 - 上海</p><ul><li>23年7月22日，测评</li></ul><div class="note success flat"><p>上海人工智能实验室</p></div><p>正式批 - 后端研发 - 上海</p><div class="note success flat"><p>启元实验室</p></div><p>正式批 - Java开发 - 北京</p><hr>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab1</title>
      <link href="/2023/06/06/MIT%206.830%20Lab1/"/>
      <url>/2023/06/06/MIT%206.830%20Lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab1"><a href="#MIT-6-830-Lab1" class="headerlink" title="MIT 6.830 Lab1"></a>MIT 6.830 Lab1</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>6.830的Lab1主要是实现一个数据库所需要的基本存储结构，以及相应的逻辑操作。</p><p>根据指导文档，SimpleDB目前需要实现如下的类和方法：</p><ul><li>实现<code>Tuple</code>和<code>TupleDesc</code>类，<code>Field</code>、<code>IntField</code>、<code>StringField</code>、<code>Type</code>类已经实现完毕。</li><li>实现<code>Catalog</code></li><li>实现<code>BufferPool</code>构造方法和<code>getPage()</code>方法</li><li>实现访问方法，<code>HeapPage</code>、<code>HeapFile</code>以及相关的ID类</li><li>实现顺序扫描的操作<code>SeqScan</code></li></ul><h2 id="SimpleDB-Architecture"><a href="#SimpleDB-Architecture" class="headerlink" title="SimpleDB Architecture"></a>SimpleDB Architecture</h2><p>SimpleDB的存储逻辑是这样的：</p><ul><li>数据库中的表Table是以页Page为单位进行存储的，每个页中包含了若干个元组Tuple</li><li>Tuple和TupleDesc是Table中的最基本元素，Tuple包含若干个Field，是最基本的数据单元，TupleDesc是一个表的meta-data，即每个列的数据名称和类型</li><li>HeapPage和HeapFile分别是Page和DbFile接口的实现</li><li>BufferPool作为缓存池存储最近访问的Page，<code>getPage()</code>方法会优先从这里寻找目标Page，如果没有，则会调用File的<code>readPage()</code>去文件中读取相应Page，从disk中读到的Page会缓存进BufferPool中</li><li>SeqScan会对一个Table的所有Tuple做顺序扫描</li></ul><img src="https://i.ibb.co/WFTKfDB/r-NK1c-TFf-PQji-C46.png" alt="SimpleDB Architecture" style="zoom:40%;" /><h2 id="Implementation-Guide"><a href="#Implementation-Guide" class="headerlink" title="Implementation Guide"></a>Implementation Guide</h2><p>在数据库中，行被称作记录record或者元组tuple，列被称作字段field或者属性attribute。</p><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><blockquote><p><strong>Implement the skeleton methods in:</strong></p><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;TupleDesc.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;Tuple.java</li></ul><p>At this point, your code should pass the unit tests <code>TupleTest</code> and <code>TupleDescTest</code>. At this point, <code>modifyRecordId()</code> should fail because you havn’t implemented it yet.</p></blockquote><h4 id="TupleDesc"><a href="#TupleDesc" class="headerlink" title="TupleDesc"></a>TupleDesc</h4><p><code>TupleDesc</code>定义了<code>Tuple</code>的结构，通过<code>TDItem</code>来进行描述，每个<code>TDItem</code>包括两个属性：<code>fieldType</code>和<code>fieldName</code></p><h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><p><code>Tuple</code>包括三个属性：<code>TupleDesc</code>、<code>RecordId</code>和<code>Field</code>列表</p><h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h4><p><img src="https://i.ibb.co/k4JHx59/2023-07-09-3-18-46.png" alt="TupleTest"></p><p><img src="https://i.ibb.co/hHpBpf0/2023-07-07-8-43-49.png" alt="TupleDescTest"></p><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><blockquote><p><strong>Implement the skeleton methods in:</strong></p><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;common&#x2F;Catalog.java</li></ul><p>At this point, your code should pass the unit tests in <code>CatalogTest</code>.</p></blockquote><h4 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h4><p><code>Catalog</code>相当于整个数据库的目录，记录了该库中的所有数据表及表相应的信息，可以通过<code>Database.getCatalog()</code>方法访问整个数据库的<code>Catalog</code>，向其中新增数据表时提供表文件、表名以及主键名。</p><p>因此，需额外创建一个<code>Table</code>内部类来维护表的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Table</span>&#123;</span><br><span class="line">    DbFile dbFile;</span><br><span class="line">    String name;</span><br><span class="line">    String pkeyField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tests-1"><a href="#Tests-1" class="headerlink" title="Tests"></a>Tests</h4><p><img src="https://i.ibb.co/qCB3GCC/2023-07-07-8-44-16.png" alt="CatalogTest"></p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><blockquote><p><strong>Implement the <code>getPage()</code> method in:</strong></p><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;BufferPool.java</li></ul><p>We have not provided unit tests for <code>BufferPool</code>. The functionality you implemented will be tested in the implementation of <code>HeapFile</code> below. You should use the <code>DbFile.readPage</code> method to access pages of a <code>DbFile</code>.</p></blockquote><h4 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h4><p><code>BufferPool</code>负责管理SimpleDB保存在内存中的页的信息，并且是有规定大小的，当容量达到上限时，需要进行页的置换。因此要另外实现一个<code>LRUCache</code>类，用LRU的页置换算法。</p><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><blockquote><p><strong>Implement the skeleton methods in:</strong></p><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapPageId.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;RecordId.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapPage.java</li></ul><p>Although you will not use them directly in Lab 1, we ask you to implement <code>getNumUnusedSlots()</code> and <code>isSlotUsed()</code> in <code>HeapPage</code>. These require pushing around bits in the page header. You may find it helpful to look at the other methods that have been provided in <code>HeapPage</code> or in <code>src/simpledb/HeapFileEncoder.java</code> to understand the layout of pages.</p><p>You will also need to implement an <code>Iterator</code> over the tuples in the page, which may involve an auxiliary class or data structure.</p><p>At this point, your code should pass the unit tests in <code>HeapPageIdTest</code>, <code>RecordIDTest</code>, and <code>HeapPageReadTest</code>.</p><p>After you have implemented <code>HeapPage</code>, you will write methods for <code>HeapFile</code> in this lab to calculate the number of pages in a file and to read a page from the file. You will then be able to fetch tuples from a file stored on disk.</p></blockquote><p>SimpleDB的数据有两种管理方式，一种是堆文件Heap File，即无序存放；一种是B+树，即有序索引。在这里先实现Heap File的管理方式。一个Heap File包含了若干个Heap Page，每个页所能存储的数据量是固定的，默认为4096KB。Heap File就以无序的方式存放在磁盘中，需要用的时候以页为单位读入内存。</p><h4 id="Heap-Page"><a href="#Heap-Page" class="headerlink" title="Heap Page"></a>Heap Page</h4><p>Heap Page中除了正常存放的元组之外，还要用Bit Map来标记每一条记录是否有效。每个元组对应1bit的Bit Map，因此1B的Bit Map可以标记8个元组。每个Heap Page中能存放的元组数量可如此计算：<br>$$<br>tuples \ per \ page &#x3D; floor(\frac{page \ size * 8}{tuple \ size * 8 + 1})<br>$$<br>同时还需要Bit Map来做标记，因此每个Heap Page的头部所占用的字节数为：<br>$$<br>header \ bytes &#x3D; ceiling(\frac{tuples \ per \ page}{8})<br>$$</p><blockquote><p>补充：Java虚拟机均为大端的存储模式。</p><p>大端存储：数据的低位保存在内存的高位地址，数据的高位保存在内存的低位地址</p><p>小端存储：数据的低位保存在内存的低位地址，数据的高位保存在内存的高位地址</p></blockquote><p>HeapPage中有个方法<code>isSlotUsed()</code>就是根据给定的下标来判断一个元组是否有效。可以通过位运算取出页头部中对应位置的Bit Map标记，然后判断其是否为1。</p><h4 id="Tests-2"><a href="#Tests-2" class="headerlink" title="Tests"></a>Tests</h4><p><img src="https://i.ibb.co/NjHpgqj/2023-07-07-8-44-29.png" alt="HeapPageIdTest"></p><p><img src="https://i.ibb.co/YfyY9Fh/2023-07-07-8-45-35.png" alt="HeapPageReadTest"></p><p><img src="https://i.ibb.co/B3hGsRx/2023-07-07-8-44-41.png" alt="RecordIdTest"></p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><blockquote><p><strong>Implement the skeleton methods in:</strong></p><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapFile.java</li></ul><p>To read a page from disk, you will first need to calculate the correct offset in the file. Hint: you will need random access to the file in order to read and write pages at arbitrary offsets. You should not call <code>BufferPool</code> instance methods when reading a page from disk.</p><p>You will also need to implement the <code>HeapFile.iterator()</code> method, which should iterate through through the tuples of each page in the HeapFile. The iterator must use the <code>BufferPool.getPage()</code> method to access pages in the <code>HeapFile</code>. This method loads the page into the buffer pool and will eventually be used (in a later lab) to implement locking-based concurrency control and recovery. Do not load the entire table into memory on the <code>open()</code> call – this will cause an out of memory error for very large tables.</p><p>At this point, your code should pass the unit tests in <code>HeapFileReadTest</code>.</p></blockquote><h4 id="Heap-File"><a href="#Heap-File" class="headerlink" title="Heap File"></a>Heap File</h4><p>在实现了HeapPage之后，需要实现Heap File的代码。Heap File中保存了File形式的数据文件和元组的元信息TupleDesc。其中有一个方法<code>readPage()</code>就是根据给定的页号来读取File中对应的Page，这需要通过Java提供的文件随机访问API：<code>RandomAccessFile</code>实现。</p><blockquote><p>补充：文件有两种访问方式，随机访问和顺序访问。随机访问就是可以从文件的任何一个字节开始向下读取，顺序访问就是必须从文件的头开始读取。</p></blockquote><p>另外，Heap File的迭代器可通过Heap Page的迭代器来实现。</p><h4 id="Tests-3"><a href="#Tests-3" class="headerlink" title="Tests"></a>Tests</h4><p><img src="https://i.ibb.co/fFr7Wnc/2023-07-07-8-45-55.png" alt="HeapFileReadTest"></p><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><blockquote><p><strong>Implement the skeleton methods in:</strong></p><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;SeqScan.java</li></ul><p>This operator sequentially scans all of the tuples from the pages of the table specified by the <code>tableid</code> in the constructor. This operator should access tuples through the <code>DbFile.iterator()</code> method.</p><p>At this point, you should be able to complete the ScanTest system test.</p></blockquote><h4 id="SeqScan"><a href="#SeqScan" class="headerlink" title="SeqScan"></a>SeqScan</h4><p>SeqScan是一个顺序扫描的运算符，实际上就是实现一个能够顺序扫描的迭代器，与Heap File的迭代器区别不大。</p><h4 id="Tests-4"><a href="#Tests-4" class="headerlink" title="Tests"></a>Tests</h4><p><img src="https://i.ibb.co/Y32P6nj/2023-07-07-8-46-13.png" alt="ScanTest"></p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lecture Notes</title>
      <link href="/2023/06/05/MIT%206.830%20Database%20Systems/"/>
      <url>/2023/06/05/MIT%206.830%20Database%20Systems/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lecture-Notes"><a href="#MIT-6-830-Lecture-Notes" class="headerlink" title="MIT 6.830 Lecture Notes"></a>MIT 6.830 Lecture Notes</h1><p>MIT 6.830是一门数据库系统的课程，实现语言为Java，课程主页可点击<a href="http://dsg.csail.mit.edu/6.5830/index.php">此处</a>。</p><p>这个系列的文章主要记录学习6.830课程的笔记心得。</p><hr><h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Data modeling &amp; layout 数据模型<ul><li>结构化表示数据的系统方法</li><li>对于数据的持久性、一致性、共享和访问效率很重要</li></ul></li><li>Declarative Querying and Query Processing 查询<ul><li>访问数据的一种高级语言</li></ul></li></ul><h3 id="Consistency-x2F-Transaction-Concurrency-Control"><a href="#Consistency-x2F-Transaction-Concurrency-Control" class="headerlink" title="Consistency&#x2F;Transaction + Concurrency Control"></a>Consistency&#x2F;Transaction + Concurrency Control</h3><ul><li>Atomicity 原子性：某操作要么完成要么不做，不存在做了部分的情况</li><li>Consistency 一致性：事务的操作前后不影响数据的完整性</li><li>Isolation 隔离性：并发访问时，事务之间不会互相影响</li><li>Durability 持久性：事务完成后，其所做的修改将持久地保留在数据库中</li></ul><hr><h2 id="Lecture-2"><a href="#Lecture-2" class="headerlink" title="Lecture 2"></a>Lecture 2</h2><blockquote><p>Those who cannot remember the past are condemned to repeat it</p></blockquote><h3 id="Relational-Data-Model"><a href="#Relational-Data-Model" class="headerlink" title="Relational Data Model"></a>Relational Data Model</h3><ul><li>Key properties<ul><li>表示形式简单</li><li>不需要物理数据模型描述</li></ul></li><li>The Data Model<ul><li>所有数据表示为元组的表</li><li>表是无序集，无重复元组</li><li>数据库由一个或多个表构成</li><li>每个关系都有一个schema来描述列&#x2F;字段类型</li><li>每个字段都是基础数据类型</li></ul></li><li>Keys<ul><li>主键是唯一标识一条记录的字段属性，每个表有且仅有一个主键，必须非空</li><li>外键用来建立表与表之间的联系，表A的外键是表B的主键，外键可重复可空，一个表可有多个外键</li></ul></li></ul><hr><h2 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>Left Join：返回左表所有记录和右表中连接字段相等的记录</li><li>Right Join：返回右表所有记录和左表中连接字段相等的记录</li><li>Inner Join：只返回两个表中连接字段相等的记录</li><li>Outer Join：返回两个表中所有记录</li></ul><h3 id="SimpleDB"><a href="#SimpleDB" class="headerlink" title="SimpleDB"></a>SimpleDB</h3><ul><li><p>SimpleDB主要组成部分</p><ul><li><p>Heap Files (Lab1)</p></li><li><p>Buffer Pool (Lab 1-6)</p><ul><li>Basic Operators (Lab 1 &amp; 2)<ul><li>Scan, Filter, JOIN, Aggregate</li></ul></li></ul></li><li><p>Query Optimizer (Lab 3)</p></li><li><p>Transactions (Lab 4)</p></li><li><p>B-Tree Indexs (Lab 5)</p></li><li><p>Recovery (Lab 6)</p></li></ul></li><li><p>模型图</p><img src="https://i.ibb.co/BTtc8Sn/eu-Npbi-K9-Jtzo-UGa.png" alt="DB Module Diagram" style="zoom:40%;" /><ul><li>DB -&gt; Catalog：DB调用<code>getCatalog()</code>方法，后者返回一个列表，包含了DB所有的表</li><li>DB -&gt; BufferPool：DB调用<code>getBufferPool()</code>方法，后者返回所缓存的最近访问的页</li><li>Catalog：<code>&lt;DbFileID, Table&gt;</code>，其中Table：<code>&#123;DbFile file, String name, String primary_key&#125;</code></li><li>BufferPool：<code>&lt;PageID, Page&gt;</code>，其中Page：<code>&#123;PageID id, Tuple tuples[], Byte header[]&#125;</code></li><li>HeapFile：<code>&#123;File file, TupleDesc td, DbFileIterator it&#125;</code>，生成DbFile</li><li>HeapPage：<code>&#123;HeapPageId pid, TupleDesc td, Byte header[], Tuple tuples[]&#125;</code>，生成Page</li><li>Operators：生成DbIterator</li></ul></li><li><ul><li></li></ul></li></ul><hr><h2 id="Lecture-4"><a href="#Lecture-4" class="headerlink" title="Lecture 4"></a>Lecture 4</h2><h3 id="Functional-Dependency"><a href="#Functional-Dependency" class="headerlink" title="Functional Dependency"></a>Functional Dependency</h3><ul><li>一个数据库R的一组FD可以表示成：X -&gt; Y，其中X和Y是数据库R中的两组属性集合，其含义是：对于R中的任意两个元组，只要他们在集合X中的属性相等，那么他们在集合Y中的属性也相等。这里X称为<strong>决定因素</strong>，Y称为<strong>被决定因素</strong><ul><li>完全函数依赖：在一张表中，若X -&gt; Y，且对于X的任何一个真子集（假如属性组X包含超过一个属性的话），X’ -&gt; Y不成立，那么Y对X是<strong>完全函数依赖</strong></li><li>部分函数依赖：假如Y函数依赖于 X，但同时Y并不完全函数依赖于X，那么Y部分函数依赖于X</li><li>传递函数依赖：假设Z函数依赖于Y，Y函数依赖于X，同时Y不包含于X，且X不函数依赖于Y，则Z传递函数依赖于X</li></ul></li></ul><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>设K为某表中的一个属性或属性组，若除K之外的所有属性都<strong>完全函数依赖</strong>于K，则K为一个码。（码可以不唯一，但主码唯一）码中包含的所有属性即都为<strong>主属性</strong></p><h3 id="Normal-Form"><a href="#Normal-Form" class="headerlink" title="Normal Form"></a>Normal Form</h3><ul><li>1NF：最基本的要求，每个属性都不可再分</li><li>2NF：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</li><li>3NF：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</li><li>BCNF：BCNF在3NF的基础之上，消除了主属性对于码的部分与传递函数依赖</li></ul>]]></content>
      
      
      <categories>
          
          <category> MIT 6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非理性散场</title>
      <link href="/2023/04/23/%E9%9D%9E%E7%90%86%E6%80%A7%E6%95%A3%E5%9C%BA/"/>
      <url>/2023/04/23/%E9%9D%9E%E7%90%86%E6%80%A7%E6%95%A3%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong passwd" data-whm="Wrong Hash Code">  <script id="hbeData" type="hbeData" data-hmacdigest="0e66c0b1dd06a7e2c248b5ed9b563524517d16fd0098a6f6fd8c4d8c24c06b67">1a19e4ad4addc8e5c84a496a2c5669b58b830e95c5b7ecf6edb7787dff9266c09ab38d714984c06f4b07962a8cb92d16a5231cf8cecd95ed49418dda50facc8e7683509c8f11db22fad654baceda95517128ad5d7f786f0b4c24fb3cfcc6ffc954a6c149f948d8b2c223f514a5cbceb2733ad2a3ce80ab5a7b559d0bf5e459d4e4e01ff26c076deb32ead76c556dac35762b68ca1a7573efa810b8d9fb8861ddb3972044adec0e6aef6e34a713e564fe4ec5c67a44fd7d97ac901442a6431d998e838944e7e9b0fea88e71023c9ca869994c27b6b382aaa2ce0039f76c472d4f27f6da62691eda610d3c73b6eb22bbde21a7a99b009a4b45657f249d5ee3767d296ccfa4338c3a3b9355ad62d59eacfd7e1ee8a3b02567434196249c7f4ae2e1111c8959cde8ed46945e8cfaf637016acc1c30648b582f0f8b8b3aa4b24f716bdb02ba15924474f9f3f47d4e645b606f061be22dbfcb67a5f8ae033621f9b779d17d1196ac08bb938b543b7dadf662ecb089021b660c5c907de6b129637a2bb207a24915f099ee5b1ec8de56b3e33e36cd1cf54bc341402b0eb2d253e6e397600bc9ff4e0decfc579b11c0bc284825306a1d2ab7e9aef34a1ad5333a0d4b49e70fd4fdfec630207afd311a90aa9839ff553ec5b7cd43c0a982cb69190572f264d33a6c4b22c3597ed46592e92cc9ff60b4ab0eab77def3640e2b36c6395ccdff64c3eaceec7c5ea313eaa14991a87afcaf77bf7db5f44a1078739b7c2744bcf3d778b088e62d5ddf23d2e981d7983e7a9319c832d987f3883c3c1559137f6b06321e647cd8a4cb63ca5947fa7e77b571ef1269f4244a098a14d8db2946a3d4c6acd2f0eb175d3689ec1f870b0046431f3866cfcd28ed6f484a9caf3a774fb5c233b990aa0bcdaa487e65b15306a8eeb6205a952c9b7ffa80000855a9befb243b0a603731572039a49d8207dbc94ec37a0839632ce6d65671e98cda453a64173fecf9fd25fdbd5490b360939ca485864fc305819c5397a76fcafc75ebc930bb4256c233cf726b8113861c710b4bf888d40dd911baeeb74841dbf98b5ace1fa6cd7691813c871b7d170b670cbcd4cc247cbf85f34c9c0f8570d1a6a244c71599c8e67a12d3dc44046072d86bee760e941a6aa09ab076b082f9130fbdbd4b5097af10ed104f94e038393502fbb29640924f6cca1c95830cb9d4e72bd3e00ab70883538004074ade940aeb33eacc41ae098f6d423fd1d7e86cdd48c6f928e09d46cc6c14e987b86936bd914f3726c9943f40c74ec54b93b11c08bd826aade0f65954331a8a9680b80bd45a7d533dd44741428efa36fec34a58855b1df0e48c27967772c648b1564583fb81cb5ed9d8516adeb656954cda3dc86850401cb2ddcff8838a1a476bc28bfeca85efa4445e8cd719001de7cf3c5f3253ee2e3cb6882b7eab13c7a153c87b680f60f72f2df4369836da48aeb13a579a7caf4d6b0f7ced1f31ea8d9bc9dc0fbe3f8b635c27886230ecf3f34df20d87db45a3040e3906c1aec5be707916e0afdb44748f49af55fef9c1bc5bb5c16c3958c82e86c6e0c4ca11b767c783fc2967a2a44fea535604dbc09768186437dbca544c9a49e7b9e6b95855860ada833a67ac6b16db33709e16e5ea85e4799b06d338564cc6c0aee0f36bf02dd2fca1145f38d19b57a48312c56be698612f4702e556f8e3ade4dca0dd434fac6dea73554002eb43c6ab6c8cf30fc7d159fa1543eba092704cf8c8f21744f02ced4cff998066a000e361a06e1a21133edfd7076b4f7f5248a4f426fa5229b373a2df157bd553f71bd5dfc57222784a500e70bfd9355c0ea85409e068db38df771fc7018d397489048229f87d917a49a7891fe1ddbbde716b556558527ad14c5f26936201d60e26ac1268d536e0b62d16dc02df97740d64dca841fd1b225fb720dba88aa25b59891f986cd8c2bcdec25b507e925d689c539d7e8b2aac52fce0132b9229b48b74fa5ed45dfef20e20df64cdca39b2f4a2c9094085e3ee20d96d3e1297987f231f16db064770aa3b6de51d167599c38c013bdea4d019c1de7f8a6bafe136e5727d7573d6fa230b75897bdf99789a7919226642716a801f15de6f15ee2d115911175a786896fb1c193f27a392d3e91eef930bed01e363cd2ae1f00045b94c8443f2d1f8ae56ae8ee16e3e881d7d098f1ed11b91a39460cd54d9f9c46ee0310fd64a0a38eaa86d43c5d4e301a406b71a50a8fac75a61748027f1fb88fce1d8319443af3a3614b4d8614abb60d5707eed9002b5c4149ed8c70f4e1998f35ad75b8fcc214b23ddecfaea72d1986302ef0305f978cd0dec926c5c48cea40b14762467d68f954c02f118f860e7bfff80be18a2aff18b55e5a636d33bcf9a1d31f599fefee2a13718deb48ae42815c30ce3ff62b0fe5fd452c9830bfc0e616779df04a3cc4bcd667ab894cee0dfcd5b61f28ddcf36c9f0a9df517eae8617957fc48e28557372ac23fe9c2c22103f29deabbeb2602d6ab776342772dec1a013df952ee963d68ec1b1c83b867c4881577fb6dcb63fa99b330eaf969a38511786db8e3b8c2054bdc8f6c7f9d1e742b11eb495ffc7e8e73e5ceb2d5f396b52c9f0bcba8da7465d41d238567175d50befd6c554d65903ef19ffcb213beab69f6c59e8b8d221684e18d0a9e99a53e6b3451f802225b689f5edda7c138bd2d63a8bacee0ef76237c69d4a49527b20b0bc0b0b475c12d4355714de2f6539280ca23355642ac19be60cd0b512fb4b6e7bd8ae0e4e20832d03ce6aaddd11a68cb45573a5f7ecaf8c5adddc3427248ea67ea5c2f920155422149a58973584d166716ca923923a03d3dbe6c62c92601876f12eaa6613c44f212500c8c9737a5a66c17d6c5ded4f3cda018ae6dc564f0c50a981b07529224c06b2988e393b79d4495ebc64f1ac5d8168f159cea2d0e35b18cf5a48a678a139a98d70fabb2304b66a7a7e9e364ac53ced59fbcb54f62940da6b284fadef209470e47e5d8732876b4c9a5e177648a4593fcc1e22efaca06ce0435b49768149c89e7b3e0ba479667d7fde3abf9383fcd4a2ecc0c5c2438d8b852eb055f59f53c5359db8b9fcf957da71ebad665757d0aa9175c4d5f52fc29d3264999d7e88df4aefc466fba7b57417da3b26970ddfa95eec390a896d3641ff86325ae6599c2fe11107aa3382095f1cfadfeb70b783fcbd45e8c08ba01c17aa8277f43d674159288fbbaa0cba0c26f9087bcbbc398c36b74351ab94d0b469adb71928ed12deeb1561171fe11f48ffb3491db4aacc050b6d28e46d0cc773f81a790663eb3d6874de49d85685ea687709e2220be95ac29558c1a95b3557ccfba79caec166613472a645a8f9dfdd98119d520d887a111a7546a8ae65d4e42ddd4e02a1465d0d4a287239f08f627584a962a6be22a4ad76ce1d563f4a04c060a74a24859ef6fd8a73acb5cc72faee1d85d3f43fad3b9c0c31b75f97cf32a0799d973d8280714edb2a6003a7a7f86d24c793b5e3f02c2afa2456d67bac9d648054fe2da2eb1411fe2c17a400b7e78a3842371aae7ed6f25668f700095cbe700981178fccdbc5aa9bb8f2a9eb2afcc9e08501f2d8c2fc5006e22f0c8f39d05d593b4e8e2fdda9ead1c4e44efd92cc9ce5ab7ef2a82aa5af93af90fa28e68b2a17dc9d75ca6c8b20a3434918abed3b3788bdb7034a47a067dd4dd77dc2f38fc4e2cc6523ac8b04066e186e71740f952905c8ade84ffc272bf1d09412b7dc8e571af6bd2d8c31a8ffdef665c3a0d198f2fddb3967bca0bc2dc6af0cb72e04ef7c56efef908e47a014ce3b98804201f7a068c8b4639e29b8ae253ab6ff1c1952be0ceb523dfc146ed2d5e15640887f9d50c16326adbb1e8eb44383eac3681a5a09035258ae735756cfbad84ce541c64ebbe23d40363e76b9b10d9518dbf5685596d3d2016ca6f2d0eaf9525a14c7787768bbbbc6701ef156c961a2ab8f9956578b412476ab753a7b969d0e9900f7ab0e198d0e7811425cf4cfefb18cae727326398ac6cefbb640c8f1dbef732f78964ad6b853fe5d58114b3b79fa5f5e53de10ad567c1e456f6506f400751bb52c053903a6c6c44739a99913c7cd56b9797706b6430c836decf6e3caf30eeeab8fc8e34e94fa578ce4a50860ee00a399373d29674bb034581bbc7e914986d11dacd83e2a6b6d742d16085e656baabdb4dbb9c1bb8c8420c091ad4ee846e2e7464515e12741233b8d8e1d94f369b3c2005d0c11d5314546bbc97626d67258b84fa903dce50f688a68d3c5cb65df76077f670a601e482ae0e6ef5caac54f516e539ff59e3d0429d59a84340c68ea46e55932a9c28edad808994886c1a8bee06591c101acaf1947533f5c47c2642e553d9b8695ec2f01420b6f88ff7bae099e40d77cf4e394c6f8b9bef48ab2091385d4e1c20f6324de309e9ec1ce93c8c7ac557cd4acfc7bf2e6b6eb1365b4576a3ee6327a40c5ae856b3bf0657b63d6828bf91dcf728c07ac8f64c3a1626723a2e6eb58dcf7869437b1f8dd58402e07950118f85f9f5b12e7912690d50e62716dbfe52519324ca75dc9d94d13ef0ec5184cf55c7fae0cd4c796ad299ceb2629684fdd14cab6130d1ff5cc12a98b9ec640340c06c30e0254abde2f78613224584f23f8b71870e8f3d64ee4da2ea0f34ceb66df581d0cb717bea238bb1bc7a1efca2c37ea941a6ea149821723caffbcf1733918681df83a97c6db5274e88b8104472159ff085c64ab69d2597ee6d9f5c311a699c025f3a5ce890c4aa20b99898f94cb52489cecd69cec36bd332d405dd20b8110c6cd6def3df6359dca60c036800ed6b146adaf624ec0132b79df11eae234c8a8d030963ad7b87b44802befc7940c8f6fde7271e345708de18ecd45ce043735daffbd139066f94022ca60806b93fbb649185a2f77e521bdbe0bd71b708feddf882a996e99fcb166f16245d2da512bf0e1646bc987514f641d176946177a84423eb0ca99886f52c11cc11f0b99e219642920ea7693f15085621d4898969698b0b8cf4f3d51d1e5df0ffdf09ceb3fb26d500921c01073a0080f7dd0b6035d06820f6fdf2dacdcb2d13b6594ad762b37300feb3fd11424c7a504be7d20dcbe71ef583768fe3d6dc4ddc87330358b9e6bf954f80fdf1cbe28155064810f71a50713cbdb652a062168a07d0865e956bdd1c906837a031bd73e0c12ac1c119bd4702886113d6737c4878fa0f9fc5a3268ee1c7770d1c7025226c069fcd42e334a7cc63fc88ca8852613929ede055f11ccfac3e772085b09e8726fdf192d5b5e485496ee7c6c8fb15781cbeec7bd869305bc1399e9d9499845877966be65ff73960e99ba352d487365c134b09d05932a2a17a728e7e45049243203904739e3105308b87a9b7716569e326e900f70f5cef744adce150d2e2551dc23582a9625aaef053014d4f9cbb8066608b294003f2f1db0c4c856a815e0607a9e09cae2ce34372eadb28008fe93d94aaae7776b3ff7ed6c593709ce73adaada58a0f110fb74bfa2e403970ec1dd0699b64b9371aa2c3c0029f0768db9bef2cd100bc4db80851183492b6d38c5ed5d66862ddddf0420d7cca9b224f4e74a50a87a586a15a52e6a9e62c33376c8c9ea6d1232c182d6b203fc2f08ca84c6c57db7822164ce914a1803c4e2953b71c465e26b7b71f775242640cdc3d8129ef6a061769226dbbe2f47c9bf517b85d0682e245c94d1f49f8854c6ce77df90ca64de232409602f021e3a071705e82afb5172a5cc699d4134886ef08c7f56f66a2aa167c935201dd7f2decbeca2576dc1080baf97daf3837f81fe4a8cc1b11b788a3939e1b0a1f3249f6f5db18e35cdee0b00d80ad5cad2e3f39367a7cd38ac9df793d2788e10c0e675e72380804f081126241fe9fd33d1ce1884526529971513810fd6c9e4108ef772148d2d61f03e6647ca1e5657a7a53ce0fc33e22e43efb6ff8843df5fcd02dd161d3948b8fd7660e155262b62d9c0a3a07f5ccc3a039c2f96fb622b92fcdfb146cd08da16548b6f3201fed7932fc88ea6ac43c01db14c0085cf621419c23ec361e743a58deb14306660d2d508e0bb6b4a3e46c5b720a640691d16ba767897d5b41932a5cdfe6e9b4d506df1f811cccac57e0f3c25f19790dfa137a2f1e68d9ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="Password Needed">Password Needed</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 街灯晚河 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒雪的绉纱</title>
      <link href="/2023/04/04/%E5%AF%92%E9%9B%AA%E7%9A%84%E7%BB%89%E7%BA%B1/"/>
      <url>/2023/04/04/%E5%AF%92%E9%9B%AA%E7%9A%84%E7%BB%89%E7%BA%B1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong passwd" data-whm="Wrong Hash Code">  <script id="hbeData" type="hbeData" data-hmacdigest="4ad9bec66423a628704bb30bbe1349f04f31ad3051c4ce6e8e69927776e37987">1a19e4ad4addc8e5c84a496a2c5669b58b830e95c5b7ecf6edb7787dff9266c02cd4c19d7da818cd4a89bf0c4317b32459cac75e44123a44915df547bc7352f07c254e33ec0e80692efe92f1049896791b3a9e8423426d876985f05c640afb6e3043a9f006153c422f6531e89a70288f10ed31f2c2cb1671211dc46d75b397181180c050fb4ba967d808030ad852e615dd6a5ba7ea4260877702206a4a6ce7189cdb739e66776e36ea68f4800116313aa5b1155ff59f579aabbff3478f3956d9f42c1df05d43ad502a42941fae8ec3438704ca5ee85ece30470fae296a72029b8245f6bb8836f1ed98cb2a555f4feebe3ac2216fe51c53fafe7e85c6aeaf556e2d71e231c1c89a11807576cf11c0126f9f8d104ad8335ff34df45c10131c7fdd9513a3e3f612c3983bd59f734ad913f0f3caa9535c0af205988a0a3c180c9953a419ec87ea4c8fc718ca0dbdd4e250af5f27c4f9f668274b685c539588287cede4c04c447546b4e74018948b915603d06708686ff5a95b3ea3bb6552be7d49c697994b29f96833889ac83acc547138edb0934b6212b31fbd4e80202a4531c7e1c64ab42d679e7baf1d8362873d615d9ff910b537220fa398eba4dcfefef6e2536a60810edd17c802800c52c07a567e29aa923e46995c7b5326a19ef97854ffaf4a24e79cb3eb810adf74838a3ec3e2b31b61dfde781d9f0b8a2adf9d1f7fd970c3abca5c63a79abc497cc94a08e686a656c4d0f29c569b623de604e5c4660b066db22a804b2c4289f13077bc24983c8e59c697bf4fb4ce3848bfd0fd08c8939db12958bc85c94ed1b14754604f7e84f774952f56f211d3c14413451d92791edb885be86b0fecfc46255aa754a7da471641e9721fd2b4e711df5f61fdfd7ba8f6b3a02a1f7473f2bed6a513f91f2c67669f92d44bf310c3c5dfa0b5540265ee691f65c24493231e383d481d8641f72e4368efbca77d09054f8a131477678f138ce322aa674638e806a4bda50d74457b0607c4dad176c95f90f092464a50c528f3aa4a71649ed74474a2194be62df6164a997ff7ef78082697f5c18e05ae79441a901682ce1ed691dad8e6d0edef69dec4ccafa57ca5d323480b83fb15f53eb0941d4cec9b0f5e1a11116570cde41fad4f408fb03a6502d1c95bd2a6ad28f17492bf066893442e4788e546a1f4b82da16af529c30cd9766cfef395c8ac02598db92815e2d17010e684f569ba657112899b7c651dd05b698626356f421dc7d81a323d68a52fb6a612bba2f53000198d92fe30a9e264f8003482540395581b1baafdc731583f7573d3c5b8388f6e644f0b5d9c0efa6c0fea785db3584eb2c4acb063b441fdae6d86bc376e89bef53915f57e943145b8f601e6b2784ba0293e26b0655475faeb1cf51835104d5eb5f379479e09caf01801c559477ff747705790e902050fcd3f7d1e1324d58970f568923d7ca029d46eedadc272f5bf9c6173963a14719e23ff54209c283de4e9670fcfcee17ac569e76d8900223e2633662dce16ca10632a8820c090e7c05b39f717f00cf61ef3eb97156c15422a23f12f14412924e9cfff15d104f4c8442bd01889b3d36bfc0add6dc4ef705737311707b15d635b3dcd45a23ea8e44a74d8c8a3dff40d84a9ee3070a2c0b1102cb94b5bf8d75d0bbb14ea3da525877c005282627c29b9491d5f74ebf565212505b21abb690c0504500a51dc475f1342fc924b82ba20094bd79ac6ec91b65f317d5bff103e6c5c731bf23d7559b1a62e181e0b3e1fbc971f3d53322029742ddf8846217d1492bbca9fbdaec6c8d61d9a8ac21a775a64363d23ce68389bb40b753a1187482da2b109537c823c10eb719410dbbbe154424b29dc577d17efec7dffe57704e599c3713d5c696500c48354f1eb808c479bd36a39b3df5636884ce8078226c654c25a4dcd02d967e5c21bb780d3145b1ef264490e7e9c6e617c663d76bbbfc4d049d09a18f741b20740830c784efa150e37d76c074a19dad956713ed8920db10c5e7bf51986acff6b9f490fce26d07a5bfe76cce246c2bb06e328d268f105f5e006e4a9b13ca19b1df5e0b0a133fb0b28d8f84078feacdc0515bab377e267e211f8be4c67f30f2603679e56b81e9544469efdd0630963e3271289f5fe4db57d69fa994caa4d2e425fe4f003edb8abd44dc5c09a092f5e9c5343232097723eef3cac8119b02dd0476693f79d5b9d002d35c4a73d5c34bd71dc83b83f01408b2adeff2e32f635e226c8ef33c9f077bfb23cc39aef7fd33005f39d66be280fe3e851d413f7c4691ac675ceb8bf08cbbcf1d02636888d1e05bbf12713d6e4c486169c3bb15509983f8a2e3ddc5090615e6246dfc98dab8c451e69a50de3f4a885738a6e824c1d6a205847213fe79a9fc341e588fa199e1a538bc94ebe5d98cb2f6ac7bce5da3d0b84a7b3c14465df0d0b14509d1a77dca109ef60ebaaca763096189f2cb7038f067e384aa373c25e200d6dd6c7c84bf1bd4f67067ce68f94d3ecb71f07bdfa513d22a8dd911fe2f2567e1fad49dfcd49ed0af0394bcfb458344885fa936f7a201420631889aad0a36187570912302e9059b2a8bca01b2d790f95fde18656cdb5e74d78843d48bdbedfd4089678d96064aff57c5bb8d7c40616e739d92d5e2c86a9dba97ad4284f2970ffee5b364d13400e474a861b86e6887f6dc38517204af29fe8308eb599c86f098778ce454376665d2b4805ca6786121fc3ad4ebf2259822482c8503743f8e031ad2d01f445647568c29f5ff9611ced102ad99273ecc27c5384920eb7b2bf3ce8d3284ea477610b24371e93afe9d87e64f11a56600cf7ea28486fe7772038b6bcf0830a30c107cab4d302549c79802d7a6aab113e9a3ae9cf5a4b99176fc92f2c3c73bc122d9c67d90074559e67377690632e300989d89ca9cf1813b9ab1c34efe13ae190e69ff978128be83ace9e22b75b47693828b794a02eddabfbdd084681cef7b8fcbfd9d74da93ec7b97602ee12bd7a6aab5a3b806bc426345aecfd63f063a5d1a922d7fe65ce13b1237e4b805e33e70ccb30b2b26ec8d56bcf3af507eb1de229ce899e7e3dc30ff9e9fc8610ae25cba17dc1ad6e316fda7b633b7bcd43b1b9f3d7a82a0d1f795495efce75ac674553def4ac3cc60e34a8058a2347dd2801b47c3b1463d6aa6bd647b881ce0cd8b5b1ead19cc8679d9a349eae457819d7f79bfd8c5beb09ef5741a24ad54530bd7f89906d642907a3b4093ddc9857919e9056b37a2e275dc35de8146888aae4339312f9007582b16e7b4ac1f43802298b21d6be79fb0088f41c3ea1585f07c04c04ea723d75860e6d1b5d4f63222f3fd35cc78bbc6e53afb9e10d6e982d940bf7f39eac17c48e061f3b86d03de42fd13f7c615119c8108edf13b6847932984010a784f2de4d7604e0faf88884bec19541c71ccf8f04bbc3e633bdee5078901a74356164b09f3a4829cd34dfc3aa8ad9d446106a65da86b66e3c8fba83e110ccf42d3143ad507d2fe880589b30a6944c1e12e6f06e130afb6e11e49508dad7cfed8ab244d02ec1da2868aa6ee2302a54437b3392a46966543eff5cd50bbfb91905f9a414594fb59ef5cb0b126d756cb0e844845c81e365c746056b416abc265282ca329724945ebc300a48846bd83a195f041b367804be48af623fa5a1b2be51c8265da5a92eb3e2767995ba5d5b7f29e85f48894dfce5781ad75671107b6dd0b779151923def27367c3db21fe72d49c02abc9c286ad6f5bc93c2e3e656afe25fefa26c2a32890d101cc4d37075ca043eb75c7ac8bc7c24e6a1bd76f2bde9796c7b4a700cd4125fb91d8ea2e56bbdd284b04a3140538d08766220864c582a0b528aaa68edfb674d984dd16fd4f4844005925cc93a5147a679b882a42e8d2943e1834ca1f1dbc998a676c6d56c85dccd2a72a0ee85d56e598231f34b1eabbb26f007ae0776c1fce260d5f3631e8316bde4c6cf2bea00610cea4e905f1ff341b71ba72fe2a2a0f4edefbe8f6f73a1c7a6ffc7a171e5cbe28d5850f8993b3468782bafc63a65d249a31cad2dea063e892f02803e7d46ec42b36f4f25fea8c47d99b3d28c2cda3f0b2bae56ffaf0cc9ebf2464860c525960f44723a4e4c81e9dfe793db75086a5ddc66ffd32fe4f4183d2e97339dd8d7aa339b137b542042e54b885560ce38e69210b7ff7177176207ee47d5d049278adb9cc21e47ebca0f8b7f339032c7953e0046ba409e9c582519aaf1d10c5fac7c7cb060e26ff106ecc169da054056988f132a5a24c5ac5ce2975b94b35499329b1f06654a2d4e0015c86d80e32d29fa9aea78af39f0a1294f06238cfd36376f98b47922dfe3186d1af7ab05e03711e85a7d7346f3616c6c300f004e8b0ea5a1eb0bc7a596df57f289ad6f660e5f695219ebab1dd08e63959b5117c4570a16f9568c241069151f683012401c9e07ae16573775be505f9cff4058384144e30c6b5aa3c4a52b88d4a8fdabcfdeff13d45ed7242e26baed3ae7a2caaf1497aad5c33c5ecdaa196929db88b34ec7116dc2d21bf89b9078abe53034c6dce27b5896c460bf65c065aaf07ca46ad5ba71dd3a5139dd6f26c5ccc748498cfb0c69c623044ef951f9f2af3f3b395ba283bf1aa864860581df0454a8e034eb6d7b8c8555982fd55f1594df40ef1f809cb04e6dd8af89cfa85fb071771cd7bae7a3f1cb21676d0020c4903997bd24362d31238b563d750f0920584e38f656f6199debaaa807f28fc2b473db4747d95ef5c5cb22e168a8833dcda15ce0065b856d4dddb4fb3243245a1a68f337f40ad10aed5f93f07c668c28a0089984f7ddb5c99c65a42a78aff80c58bebda7c7b19cdcc046604cbb5da4627e375308b590f0656818a98556d8af3b4320362b10afa7b6c4eed779180dc6f31cd1b0a0d34ccd85bf01570fbc145c9124371e64b4eba742919194b66ea3194188452203b682f2f625571e2d988628ccb6aaa85d3b3188bc93c966b97875809cb62da225498b76d52a887ec145614ba7ff542f140fd69ec22c4bcc7201ec09a6b55a8c0518b95aca84ce4bb26c1975126b1d933c5ceb62b6f61b8879f7892d607b4d22eacb966281e70a2ad57b646490195ac2eb3aba696fca910eea44646a7ae22b2b2e320df6d2086f34d9f1995fdcf4edcbcbc0da416ee9bfed1b18f17d9a5f3f6465e26da2a2c151a259da4acc056c1f5bddd30663d13ef65176e6f22bf5049e37577654a843a8c608c6ec9baf5381d862be9d7ac36c7c65f8a4d8359f95db4a54b7d3ae19a34ebb48e7e6b709741d0e240cc8ca8cefcfec01f2d8acd179e554c23669c619998e5b227415484728b2ca7a2fcf37e0a9881c8098c1a28430c82b516df226d74b1b5261b0bfd2f3d240473f129407932f4c6ce2211f81d177044bf430c63e5492cf3f1d9ec30d1418392f254c3569f21d4b3050c6a562bc75da5e0bd34beeb50d6b81a19d81aaf0ec6c817695b414fc8fba86b9e70369fabd226388b9b06ced07a09e620fdbae6cabb66d2098df056e652fa670f010d809a43784893876c18689784cac17948309caee35a9bf256320f55393bc583978bba0da4643a33d6958b9154baf5e1a81dfff0018bf1442b9f94425f3b356afd1138f1a06740464bbbf5fcff02ebee56cd3b22d6e0968783b59e63be5a50450046a53cb75110dca15f368b8541c2032b4efb07e5f6edf4a0c1a3a9de8e37841f6dff2b489b93a7e3e8b302983954eb87ccdd9ca049f397e460a8ea0dca676ad10ab94a1ec7a779db2e38a40bb342df9f9ee3b3413afbdc2d803e975818f57496b87a9177e390d935bfeee3e404b8953aa272e1cba999b07bb6d069912b1e1851c25c06422c438d7a1ca53655b91b0267ed15ab2919516093b26565311f0fba25984f65ee13e031189427be5b6034404227edcc2abc083ed7ac6f08e7c02d0942f67155a088229ed735bdac01224d14cdfc3d2d321ef2e75605b38b0e376857831a2e748bb13263bfaf582bb7b76f8fa5248ec2aafad4deec366b0e5552346bab7306c191ef4f3b8f9f13965446500e1ff357fbb2ab24e76597eddb1e83716a692f1b09a40b7bd8c32ee70bd2cac5a6c6db4ce302c049ff40d760eda8e70ed1658252ef77db683467593056124a743f279be65b4f21cdf5a8fcea982cc75c29eda64044a07e4ef59ddc7b2fe26150661cbf5ceeb0d602380b5b2e7c9c36a113210a61e0108ed9c601b6b19bb2b0dca93f91f58a224c6b558093078f508551a27b88fa560b0912c30fde34800aa7cb7af4b3312ee1f0b0cdc8c81b8f9388ff7647895dd7384e7f4bf4d2b505cef01b1b8e7a42513168f9ce27e3f9b6df388ae8533b6d9e2a66a1110d8f6fc0a5b10d09e65c5330a74056e47beb1abd3c62c9241ce6253cff0a114063f33a09dada0a66219299c613b0a5b45a619b6f2d9659a7d25588c91d6d7dfc682661b2c77bcb27fe541a27d4e099285f30bd499206372edd3117324205e9ae25853ad8386372820bd5732b1b33ae8c626e544b58a0f74bc1fc8f0dd93e1f75c7f0fb46d13047f951a160eddd240813589a23258f2b05cd7a1d20fd5686eca9ef4d1e9f9ab1bccc85f781b2b5780e1dc5efd6e5629c6351dcb0b51c3e1a702264dbbb657e8790361dfd60069a9ff7127fc8ccdb9a463f86a7cb8b118f675105b13eaec04156aca5b860f9f41935f573671289357c02630ba3d8d7ab81d9b8269241a406f7d56a7c9ae8e20d7176060055e1fa3787d0fc87662dd87fe08880022bfed7c0760a77b3fda7bbc8f090c5e00097ee0c81705516c22cb02fe7dd17b7d59754093479ec9b0a260fbb6cb27e36a148376abc9ab69d7b23debd0493ecee94aeee4643ad0b36868397d87bc031cdfe89fdf959bad0ef3e7742a2e6b61b9fc1baf880ceb6b2d646f9997bbffa4675751631b9ec09d9bf88dea223e193ccb18083b1698367ec04d4e9ba3815a6d65f99c55981a3a286472128e68ff39aba9d6fdd92cbc79e6695534945389a81233ae21deeea8641033fa431cb3e3493510b980f8b778abf0db4fd2171970543449ebfdac18dd0be606ae68892e525588d129fcab4e356f6a807e46703bfea1a1cfda68e0c01cd7dcd8bf4f68c3bae0deec00e537d1f1b85dec46517bcc1b7becbb11b04ca3508c98489da9330b4d5ade0867094fa204aa51adeaee902e2053cf36a09efa5cd78c0d5ec43cfa31f22c37e6af620d04a370cde78e27fd97d45cc1a288ec12dda113cc58ad154063951ccbe93755a518c40c13d3440a7f2aa1daa29804b485fcad342ff6733840a07f5d57133433634406f4695dc9e2e28ce54481044e074018b7e02b4362c39fb955b6a7e842f143026c35ff3c3004251c98328dd3870fa68a4f1118eabd7d2179a5f47525bf064c00aa7045b4f9e77c44df6f568bc241b4365835d54f6a35aa9825392286ac5ff775763ea8c3e03a7e2e08d4ad693646bc37890bb32e1092ef7152b8097b15173b1e7878ee440e434a17b25aecfcbf6811303604fb14b7e98071d829b3edd499d30c4530df5f8150f7845a86e76e5da476244aafc4ba6c00e17813f6ce063a91208d61da1299c82ce51cecf1945130b9b832d9a49f8cec7288a4d02ad8923ce1247621f8491db8d18cb59780deaa2725d9564d5f2a4e9234f1c04bb3e97be78d93d37af7b6e3dff21b19a7a2cb929a637b9d5546b03d99675fdcf3bee50e91a83251b5a716d603a42537dd962928878f6371aaa0a17e5bf75ef6441e202dfb2609dbb09fc402f846e2023ecf7b330ac605ae12b1cd4efde58ac93f7ebe18fe8854222b10412bcb311dd676be8ed5e96721d560bedf8b37c2f4610b447b19a5083049d15915472986471a5a2395a3af60ffd95160f4bd8ee54c117f2c5955e43762d86a7cf1fd70fb22749bcdfaf3c08a51b9760a46ded1b7f44d55b10f48116395623e26f95aa2be3e2e83c6213a7147c32370f9e9c4671c91d7e6da192d4b82c79ead895155686a03b8d8193cecf0420acf104fe359b299b744d522229d939db02ceb0854da1697bf592e2e84471e100d6caeab39a914780639acdd0cc40887a66c4f38fdb6ae6a6f18f48610dd599a1f0aacd85988f3a759a65674d6ca16704490f57b7a6ffb5ab5c14e73ec684120c44f0b9d77164093ffc02cd6d13a753337fcf8c228f09e7cb3a1f0b972ec49c64192cd299897a013490f7db25a5ed21af661e46705533a567c4830f30092dd8188e9ed9fa487a303ef27387ef3e2518fdf4e044be78462a528928b5f68c96b834ab3235fd86f1d0108378fc01f4925b670446e0944acbc0524b9cc31bef0137ca7a32fa606cda14a5e25ec959d22eb08224750bc6d2a33b7b4ca99531f707e64cc9e463b7b009c3568b77781eba58e9660529d47b0314737e806c64c3212460748281155453ddffd9312ae88a705a13216cbf7b9748699f4a8a6c5613048d9af163d20869ee681c0537cc52002d155088a85806fad2b0eee7dcdda76c823f43c949fd2206eb6a8e68cff686bfc5f1d86e1e3a3706193dc7b5441bca35b47c6a12f7a059983a4f2cab7413aac0765e155deadf2a5dbb536bed2419e3a8e67e723188f78f2670e362972f20ff2795213766b831e667da0718660c198bf850f67d89f703dcc0ff9c5202e6c8d9dbd7fefe2ab1871cf2fc8fc77b478ccc37719212c6ccffebb64d689a49e19d2f7340c18100b291245f53eb6807dd6d6350974b3864f9a386cac742543d97f0bd500dbaed2cd4f3f3589967efafd71ccc03fdfe88e1285548b02b16881fd2a413ff3dbc3c9af1eaa419e44764ab65422a645b5d84cd0e21fe4bce395e042c6746be0095ff432fed9b72ad2f1d80ff7ac4dae1bc92e40ee6ae1fc9ff03d2d178237163b7a57b129cc5518a9612aa359c4df64c9204f01de168101251b27da836aef1158e5a12af1df7b4d82022d66d181feca4ae26a329ebfb1172ccb500003c88cf43ac2c7336753f5a1e18a60440f41bc254e7745611fcaabecb81b6a54899ebe978464e2539ae20a6f5303a367fb33d158d8637556baba59e3c0fe207bb29068ef7a10129004f1a0a31ee24eb87553430509d89327185ffaf0e14703c254c12e7ab2a99d42cee9418ebb7b36e60acb09c7aa8d33b5490798cc525c872f2d281f3ee694b2301c5b9242d910c003bc9b9cd4cb066342311f39d7531a50ac73a5658577f77db388d1522b0e5a327ba22725bbe582282d84e9c7f6c0549e0165f26b6f12b603edaca618db0a662351d7b5d413ab1208ce281b3f86739bec44ef7a99d4933c695d2a09b7480afb6d14c329f8ac62439d67e1319692e0a9b4e87344766bf12934eaf4de3bc71d66dec55b97c1d21ca527ea9fa573e76917320ab486c6d745ab8dabb39b59ae3e5fcb153fe46eb342aa79469256b10cdc2bdc37e09239f7f1f18290c7e24de86a6533e41f955437e71a5a5a0a3694dc4bcede21ab493fdbc907c511cbc734cad9fec5c8de555890c3ac23791a127ba0f1ba10dd17a496817a74cc344ed903ce2bcbaeda53c97f8811a330b2132ea00aeef5e00b611a0b083f4a5a6be93cc3333dd5659782087daf4eea4c8dea78882ab7b697ad80e7e55a337db6cfe61b9667c2bdeb55eb4d6032ec5e39c576348953876fed0abc44d831794ab0bfc9bc469757714c4f704b990037011a33933259683475aed821e9aa051b8d6ba939adddf9cd083c05ada8a87caa0777043d4450c425e66d23a32dd37312a08ffb241b5f6f5cb5cb4514980af535455c45a914e59f1158b40e823e1052262a7bbedc49a0a7daaf83c96fef0b69d2ef8f64eaa2128d06a9d9abfa2cbb086913bd8b7a26d14a0edd22f442f01b18953b903f447f24ec4e9fa03c86f056f5e8965fd83e1b15523bd3796df4157122de2cd09694e08412473065096d979d600791945780be53ac170cb229640f8daa3fa42118e0469430b0d17704a5a7972d3817af4b6c4767fe1e3646078826b016290ec68353e5536ace953c6af9adbd55846a2adec08d755f0291c57ad698f6d18fe8af7e093e809fbff35e9885cac174ef8dec1d9167cf8aff05306568d62e7c8474ad6934a70eb28056088dfd6d6c0c58e93bd0b48fb26e67f77c40c0bd076b908c156160aaf715912ed875d48de28851e0fda6b9dcd8a0771373ebdfcdd3a3ea89f70864dcea494a21f3c6dc279bab549fc1961cb93141c0f97076ad391be98210ce23600e88d50328834b0d00325e2599b421e09ba4ccde352effd5a2d25a03e11f792638354c4eb6869594269746b0fea137f75d5d5fd994676ecee7d46d3fc9ce0dd6ecf47226cfe2b2a120ce5191a6e43bfc1438768dd38aa8e3a78b5aacee570d1aa89efe2f3994d45ec50b39fdb8c41c90d57256b38a92e7c6748937b5a5b46872eb69099216c821477e5a4c1013843ad6dd10e5d12bfb936de615ff37b392b72aaddb71215a8f2ac7d5fbb9e5867ede92f381a49040086b4f56de1c12f1bf1326dcf4b568d5b806870052f0805f23ac481cf1f0aa648bef7435456f2668aa442638ec9ad1b01c09fe0c7ff288d6b16cb8057e961cea48956948a8bb32b48e23495d3af77291f398d7489c32fae7f5a7493685791d1db89827c512844585b41fc1c09d9ffce1b7071159a33b1fc28f97274e45a21295e436673503f34742e732cce8e9526a6b00d208c47e4ae88b842adbe7495fdfd227c0e470c1ae9112100872cdbe86cef4e906f3a9b101df5c0b8447fc07bf61d73da932fcb067487ca35957243762267bf6047d18e712910ecc409b8960a7192db3a64e146002c9d0d199be7cd91ad9e977ee0189cd2a7017cc67d8c845f8b1eca779cd4a73aceb2795dac42705f92fefd076bfde7719f024d79ef89c02fa2f37afdc01f2e5f56d032100969e03b6f7524cad58da541b80e1fe3c122601ee115998b40b454731dbdaa62f61e7c6fc14b31d56317bd8b914a2f09e378f0e5a7f00d772f826465206d1fc6360f6660ccf80c57ff0e296b8abdd349722640542c8c742e4d03b55df8615fe98609000cca978ad1ef9916da6bb92da8a50cada4d02135c083b8b30e35074570b0f1656a6f4b0fefcac031637df367869f571d9940690bfd44076505bed943dc05b16687cdf56925642a7dbc67c6353fa66266ea0199e8ae4fe9202f39f6285af461a1310724e3b4ebfa603b18e6412c176e60e4d5bb94d82d90cb305e4550c0afb169a4bb1b61b227488609d8272128ea9b4418f2c1d83fc9875612ca740c22434daaab2d5746c66ed1340bec049867329ac81d527a809ba74945478c82893d6a349b98b9fa4e07192ad1d554fb5f734c7e3486445c2c1f90d331537ebc384a81e438cff4ece68a78c87f2d1fa15c158a766f232c1ab738ed973d6d2494eafd6b8030e4bf51460982612b5d321e923d99b244cbbd7cc8b319075faf79204d3d2bb4a2725413d60fe2ca0334692fdd17812c600ef35d9d7a218d4570a04d61863dde4965847d7407758bfba3b37ebc90aa089e4e3a9b5b61b2f5858faf9811bcaddfd066f51727f90855d8a4396292383a786865f8b14249775eafc536f9c7a2d519038fd5e448d4c31ec7bf029840655a65ade1b1436336bd0e0aaed44030b979204a66577a1ea5ead758ae3be70e3999ceb0bfe39acfd336c4e7a813c218012c1cefa266ac2a5b2de2074e9d6fe680c4b1d704954582590948067996e4abfa2193fb8be4ae5153738516899061631332df30021cad3e9aa7bbd22c2298047c1daf5fbb37259eb5eb5c821de24e5169ccb829125f73e33bb67c498ffc97a02dbef9b5a6b50d8e41eb6cc677aef3f2875535cf84c6fcf5e51785a124284929556d6bc58d8e91ffd5729ac297cfb825a529500980e55279cbc548c09e57d36524326a2dc355071f5a14da2c96a678a9d28c096433f541685bfeb7e7fc933c2053f0a478722d5a2f2f54dcc48e8343c1812e742c4972929d776f8b76fa325b51af80ca5c0a5434d5a93b6be19f1116334deb31c76746015b1538779ac785e05b482c4ad370923729a544b9a672083e7dcb81236e022fdce51a46b9be0b0baaeea76e3b0e8abc772ce6a0be3ad948796b213e1fb425046c18e2631e2eeb90a9fd2dadd4849878c86c96cfc0f6c90e8906d1e95aef3032295a081e16e1b3729e5737a233c8d530004fbe9745f12d99df41c8413385dcaed7b0eefd90a3313c3334dd696ff4007ab53fe2d81e4fde668e15eb1a014bc2012b5ffd6178a56f6cba9845f7e29a61e84053d61ed9503c2d3e1ad08a3b1431089cc36def53d99e8160d9a3e44a8c16cba745f3a964b45ed7ce2e377e8c05b18295597969bc4aa9816d4f913ca95208fef1c507e10b8f299f997aa9f8a9960c96a2e5e5f3fe78db244c4a430eb5d29759a15f35ef34e8c423fb5e0468ef64775f1d51b9a5baa76e87e502828cbbb4635619fe434e2f1ab039ae21131ff1f12d6d3fb80079b4a7361ebcb0dce2be62312c67de5401948311ee68baca31fe8e1e01eccbdf5f0f0f80816418849266cc1d41de37b2a0163aae440af38b61a2eedcd8a192a6102f9bfdf4dcdf6a64501c800466fd5ab779c5beaf28f286b6fd1595ec12f1a65d68d2f95cc26f4b200106e467eb81811800edea1df6b2328d145e50887f60f1564ca94aa82b884bb209279091f9b5eb4e80ee1fb709887eba19365822e3c7aea5adb6e20d445444e74db8671cb89cf7bc430b9556aaf882cff1a76ede86e18da1b5d2005807e3403a0d77d1ed75b372a8abb2e45d73ac391c1ec646365be56d9d4ce8ddb2202628b55ec68e4586ef4cf75c39988b1c02495fe63ac43e9ef5adccb710c397d68125a1972e02ecb80552ba9b0775433b1faabb2f7fef668bbfe576b3783d4e5279fe665b0811d9a6bd97667627c74915ca6c745aa7a09a0385a46d613d7cd616a4ad181b91f1ecd17a348f55aa66ee85653d66b35616d80758c4b25d62a808785980f9a9edb015c5ef9b17b02ef4ebb88febfd3b41bfcfa57ddded8264dd08278d489567ebebcf2fd20625aabd7cf8bcfe0c20b4c3cf924b5b0f74c7199b1fee9f35089090bedcdc40a3eacb99f082d8e00aacf64f027d1a64d6f89c06d1142777af58c02fc80b97562714b8e90176c2dd548250e539232ef9cbfb35883ac538fd821be6963fffadb355115d6b3ba65624c9dedd6793722a0a1e6f89eaf42d1ca1ce9068a8322e39964342c98dfeda40669b309d9972a5d5c80dd57027b9feb3d5bc52453c4529a0bd2cd7a636cdaa9f66552ec77426231d3fca280055d4805d8642cb1fd910a5e969bca7aadd877b2cda92703534dfe0746d225d1cc19c416572ab32f9f52b36bf35cbce554bfeedd2de93cc6ad5c8f6d7e7e526c24a2de396f11f9c52641f97d72fa4ba69bad0efad833158492e46db006400de194309218fd87a0e5423a0733d459dca780a22e33e15f3c2625b65fd3e17a06f55e15fff9033b3703183e1602b088a12def24443353b2c41df4467cad96addff0e61a2f57379686e6f30630adfd7b24fba9455cd1c8ac45c073047747da20361b90af1a5804ffb42236cdcff58e7aaecf1ecaa0bbdab1dae5730f6f6da6b46abf3930b525c67f5662c502eabc3d180261a3cfceb266a23e7e5a2c366c568b2ce115f9008ee36e72d2848dd7ca131dc41c2994f2303d3f74ddf3dbfcb8e93d0a2b421f5d42979409c7fdf1ee88a73ea732907031a771cdeac51a095c0dd73f85fbfe46e1331686c157557c0860eb65c7bb9e1dab0dfff99e9176886eea7d0fb553ee3cbbe2b535c226477fdacf17bbaea240ead03479ca371ce5ec40dc449094068d9a1fd3e37734b2c8457dcdc6bdb8e9f59cbc2853407e5338ee23210587ddf7f7fdfa12bac63ab0a8bdb444eef5926d71006228d253b3546d79cde66a8c1459b5f956679762cd7035f4449cd11858631815d0f4234aa363b403f27a0eca184fc4edffe3291171c884bb6035cdcc1a223949e1431476b12c94f63001f7a9ba5571f82ef8367de83a0b1aead3e11b0cc4126e581c0064a9b9ae551c2a380a3de794854e85da0cb1fb002b6fbd5c3393db5295a0fcb2b608e8ea5b6f1284103c051af562f77c537aa50f0d0ea0c759a96549f45013795f6aaf4c7d17a676908d5fa2395a9b5120a7e61cbb26c9303fb9a8dfb687627ace9e43748a68373ce105c4fb5305899a9f00230195bb120ef72eced57623204c539d1822004dbd17e76d3c1dd401b93fa3be1213ddcc05fff95521c811bf03217392a4f67039e543c0492b28ffb8878cf58d1db0e42039c2f226790fcf9f3adacc7ba4097d009c3cbd1d84e72ae103406270894d7d14b583543e61c1ee307242bb8366dfe4d899091973bdd7e94b50f071eb114f9ddd48f590d795114d33381a185391edbff5505e276df0413b9b7c59ede4b94b8d85df1675b9c8261a14bb733e575f2b2260a8736d9233482a435434f62e8d4d9be882094cc6abd6de57d0ecfe6cb217cbd4df6bbb3554584540ec41ab5fcefba4f16c609f1c09a00bd175e28670b20f8b127c34d4ad19a39e20d5d440bc6f08891926b1ee5ab9609307b6ef4cbce4861716b25b60b1037a488b63ed4598bcb82042bd81511e75e6bb16a1c6eb2e82c5fd2b7a04c7a70013045902bd5dd4a8234dbc7c2eb5411a0191445390aa4b4184547f8e138a80c772e632d68f53bb1eb9f8cba17f3d34104a3f76748b73aaa862a2fd89b9f8abe7cd231f57d0dc49231c761fdf9537cbdc8e1629a67eb10253b535bfef48207544dcd9976d8601fb875f9250c94dd06e1885beba7f7f643277a4118387d1212a0819774b2faf5651c87568a48ad1ffc77656e81a79096497827538437a4f3e2e20063bc6bf8ed8abf43b46355ac3e90a2f9ed3e21452cfd2cdc6056956d95f97ec068911d354e3021502ffadefd35886b23da782cf13ad08db385cb03b9b06c8d9c57fab42d2cb0ef2a12c00499924345987b5755d1e241237b08eaec443c1ac17958c8546c06057049cde56027c72aab7c2857cf1b11d8b6784364732e8a6e61874f1529dd4ce94c87bf3e9861d396ffa68f709c1ea15423b9f00cc4dba0903c4657477aa3597aa97186f3f0dbba0177ace3ceec75c975740cec455b1e77eaa07dd3cdb723b369f4853ffc36009c50d2b9d5295f2e86d029c613d497f2d67311a9d7ba79979057f182d0b96d224d5fdde5c14dbce60431fd5a92a0e1708d2548f04b57b3e01325666b9416644ba469eab4f2bf7928f5c4111df46bd05c533198526c4bc5141e29bd19e899702dcd14d9ee988aea6e10fd1ac4240e2a7d6c78163bb3574bc296b6b6aca44d1ad047399c1820a381779c8e4f1ba522aaa2fa4004447935deb506bbac0869f6f98cb5c3e1667b292cae2e87d05ab9bfc90250e015fd03d1b2addd096252db7ea5dd1dfc49847a0a8442d05ccc2e4e880662be77eebc0e5ab017acc1edb1d012d602857ef0e5a615ab936ba8a58c49f81bc3adc302c80a45d3e8f3fb210f79856d9cb673b4eee4a9bece44514145761a8db405b6ee7055a5315fbe1f23312ccca97dec7293cf45d82c1900a0c4497163ad870a579bc13baf740133d7dcf0a0a3ac246eebfd099ce4db5229f827bf961be327002e80a5e3f9bf15f6c6a6ad9e9087d42f36c9e8e849e37dd5ee9a40ab939663704162ec73344f23cf517e457f451ed27f46a442afd7f08aa242627982644533a3c74be8beb90fae28cf788a71084574a8ee5036a8495bcdf9757fb3e3848933cf31daf7dd3d17723972232de08bf2a69d98bfabe375306b01e85fa9d2f7e468d03bd60d24e3a46ab2ef1e7c14b36cd23452342e98a06eae35a428a66148758507f1a04e35c660e9e8c9ccf21f7ac34837490b14efde87752f399fc8826fd8c2a15ef851e14bf89876d6cf76e09b98f735cd0be2f2b60908de5112336f7396b6ef5a1309eeefc2911897c8cdc82e420f306c474b11313314a4e77ff1eb55727fdc445b5967ade1394d3d3531a8716feb572ae795072121c0b6de24df4b4f9a64c70d3f01d20dfbedfa8fec67022704d0c45cd8b8527f25d17558e866b6213eec025423003891d52d5801990afd84264c705286ae51f7d1d2020f2bd3269aa3b2aafd9e3086738a584c3704f65ed8e07d1a0742f563a850f2a976b7b8e0a1416695751d2e0452f36ce14393d4669333f657a44e490607e411bd35996c13a4306ffaefd2bb6c1194d45bfb9fdbcbf762ee2caa83d0153e9087a85f80b26ce236d8808b3c08114e79e0989eecbd7e76c5d664ebd9c41560a6174975f477b0787f3f3660aa50b6f3dd9ad92634cfcc414862b3e0be9fa51ce74cf10e550d767e9981a4e8457e3d67dd5ae31be7bc8a80ace75542e2111a770e1e7a5290a2a38873f34473e6b391d5dc3ddc23f78b421835619646f034313374610ffe73eb262e386713f25f19118682112c6d51bf76ee3c79f2aa3a1e15a159cd00550757f86b65e4dd3a73d40eee092aa13edbf44660ce34a98d50c62913bdbaa4eb45c310e5d08641540957ff08a1c386a7f392f54a7d944afb46daaf9d9434a5de906a52ff85ac0eea3df50ad9bb0aeaaa7728891404798476d82262832da213494750ba29e89bd2cff7386bba3de8f9f19a77abb5528fa3b316bbc6e045276590e44810382ee343cad80b6b737303fe74c936d9fbbc0794b317a49830c7071a6138e4ade784f2b95aab8dfccc67b1a5a1cc6ea2fc47de7ba87354b2052b571f26920af1b3e90828316928276fbb638f1388be032d2ce7acfe528009ac4c5afd3f09432e5c45ec5894109fabbbebe154ee42ab0155b2fdfc0381613a5e06c80b9b790fbef9ef335d1b229700318a0c06e0bc7a48415c2a4b25025a107ddbfad9db5ef75bf23dc404fcf3073fb44f319dfeae3ac70b96154714115bbe40b290ceff6a0ec4d6705cd2cb25b4b56193f8e1b44efec310e42a1884ba63b04782d89abc89b1d9ff3a8549a3895a234cf8b3044c43f8b9eef432da76acf80f7d51d1308fe27402843055cb26f61ecf3db24ba238e39b4f230440a9f937e14e1c10299310b9ff3513e05fec31624797a0029ca0fa70f0f138de256be5d0bbeed85a75ce296c86e867b1adc8cb56b6addb44c0a641cb2069a48d639d2654433307aa2a34f0f171a39eed26b4517ca7806c118caeb2cb0cf825ee98c5e88d3476a606a070aa422398d4de99289685198d80cbd522eba4a112c60dd6b885efb5bbad19779ea3d38a104d7ab5ce86723a946903a2eba3a2b04a0100f2a2c42cf1010e26878695783c31657463a271a9694d9bc9e29bc9683908620fe5d74cd291a74119469328f87e09e5ecc3666f091d798de233c21c05c1f53c73ca12a1be1cff0f7de130e832a62fd61f6f9db19e4fc0984b1d7df17469bdad34a17937a67ca32b548b7a93906d939dd18f7ffa465ed3fdd1251ba8b6c9b1617a5b012e468a8ed61c9811f01a3dd601a4ae848ea08a622d4b350a9abf779c58b037bbdc697363d4209a24843965a92050a2d9e7095eb1b7b2f36076f0f1509e1e6a1aa0f60f0da80c7f42757cd5a12d3c88312e1d0ff8de737c852e813f550714c56b65b0cfa3610d3cc855d757daa55c5c26e141007ba99c8149f3da260ca040a4ec95c8c29da3b011fe6ff5168fb6800435fbefe236467ea4fe29f5655730bbe630d322687e92780c768e53c2d45ec09e7de7d8280c967deed40c229ad4dd5267f8d61d17286351b662ea65b95ac9eea70cf6806466fce4f9408f7df3a7d3964e049e0c03e0b3ce3d5a48d6b3f9c1b7f3b5971e24b74e5367494d2f39ecc6fc28ab1c76ab63d2d20a521ebf3ef621c325f2719adec9a8a54a9db872c6e0f8451575fb55cfa2da6a3f33c075afe2b1e475fac341f5b234193e43c41428b0ce948ef32cead77e0a07890739e73479c7542d31a74c83fe5bd209ea837f82c2cfe6a5e37c8d0698922f6020ad1dfe6577b34d16cfb2deeef7972e962e582f0d2f208919b3f1bc77b5a7522618c36d072fd951597d18172bc81288070cd7530368f573a9d01b554897136b2aa188c6c221b2f9a7832c2d3596051a898a6079d88abb56baac94afe8b4107ed98c33e3d1bca7311404fc14d70ee7dc0288442571f2b3ca031a12cb840dacd429c6cf793c3f0827fecdee04d63c9fc3e5739fafc09b97069df06ecab73c4e059d9ce4b902e6ad11120dce9f215e019117dbb9b306750ff8aa8a6f66945b94c417c8b866faba5be0a7141ec849f0ae84d632e1a96e18480bf90f36028c412131561ee361ba1a051013ab6d918508bdfedfa1531d02a5e88a2c89d2cf7182193e180d4fde5bac5c6a143181c58184d6b676fbc118fdfe8de84e8cda1ba0b2cf2c75657441d596728c19e91ad2d282baf635cb28f7d0f1c11df218f66e9a3da7dbbb4f22c60dce1d07317786cfe67bad456cfc58cde861b71064813b243364060beeb44e3682449e3fb34f92bd08bf26205856337e141e1d13a3b9a344a3526f872fd3c199230900690219aec751e26ecf685dc4c98410daeb99556b825141d93f2e015050d586f0135683d3d450faa6b5f2840d43515c32677e6fc6018d8ec37b869b98c9950c66ad5ec50d50d8553ed7180feb156711574df9ded3b3ec09917239c665c946e84c6cb3ac47a762985ff30179af6cacae1254531b8414028a5e78dc2b40b7d48782a8ac84488e7be9f5d7cfb6d3bed4668ca8149d49d54930429137fdcba217c2fec2606c693c04e0744ac3e8b514e30ebe306527c0d323565ec0ea847d7975539d4f7e44fbb22230735385ef032e46adec3a45abe42fe04e2522ab9ba9bfcf54839a46524e0d0237ab382e570d5d84298895095074e6702dac406ccf91aa2b21db478dc86e10efda84384c8ba44b638a3ef7de346749eef8c8db273e0b334a16381fdd68091ee49047c4fb712af7a76bf8242c2acf5034f2b72f69839cf0be704798e982031b9d329997524d3d0a70c73449d48ab6f566579a0046a0d39258ced4fb84289625f5a93f0d8ec5b5b2adc9ec49f8fc2e6921006b1cdbc48d388f587536eb841eaf5886153edac995684f0112204f647a7e08bddfe02cfa07333d928b275a38add8ee28e864341daae15bb311bb2c409fd9b1795347b5af92532762094d986b16df9a5fcb811c0d673c0e9d3324602e30a978a0f9e724af5fb73d570b87d73f2a8e133bad85cca5e1d4b1092a8b7a4e6055536678ddad76a209fb02d4275f8e81dc21ee7e7ba9981dcd1ba4b3129ab9de142f5eda01d9d0e1cc52f62586f05a71780f76c5ff0577f9738f18a14943183e320a686d5912287dd3c7db08d08f0a76fa69d5bc87ea5ca10229d23689095f7e32bb34209284d3602a62e72aea74920a1013b277a2b677764a992d2e0e177d23e2b8ad159420db3166cd17bd5b5bccf78ea4e32f00fbda395784348ef7a0bb52758697c940c086dddb8e4fab59bb0166a6c567f66a1d5d07e4080565c2773159efca9ecabb1a8ee71119ec4aec79c6ec138905f28d15f927a6963abb38521c91db8b03ba794d2d68083585a94338644750e12a573d0ad5b7cc531299adc196978e9a46117c489bd36cdd4e68fca1c4171934e40896ef7084c85f55fd706ddce4c2063ea9c7cfda1c9688a59c6645a49ce9f214135391ec2eb05c7763150691e6f6a3f2073a5561df021e974a3436ca4ff1d5e647ccad6f5827d64b28ec09250407404856a430f86595b753adb998e037b6efd3cc29f035290c45156e344f65619ce430cc3f217ed895feaf9bb083a54c54d71306ecb2b6653f34c712b938cbef020d4f85f6277fc21d73a69af43f99132527fcfb0f70bcee5193f54d58999217e311013e75628332c3a5f78e949577545d8913266103435ff2b70b3579171daf65462c0f6cad18a2c4058dfaca45c36aa1a21e5391dcb1a96a3e79cdcc2a62bd17e5f29e18f98f3e118eaf10aa125f396091e5cda3bca238c1838ccada450f654518421a45202a4ccbc7a88776cfc6b4ac336265ee5c577fc8d005540a5795cdbce32ca6777a5bdf9e0a7cbb9330739983e5fd74b3610624f620b2f241e61d7714efad0894dae92f26ea51a31429763dfad296b2f7df2a9399205547796a5552e175df3fbd0f0fed6d4ba0807469c7804a1dd02d64026ce9885dc931bfea04e793add7bb882a6a42210ac8c102d69333dc75f6753bd0255d7f98f544f09db013a20c25ec313a7cbff3eb39948c42b1888a0d5e2c4c7e6a48a74db395f35fd3e0115eb8db3c5808e0568c1b67cc8dece65ad9130ec633553b1897ece1fb0d0b8f1be17a89e6f05fd6e2a42fbc0f0e28fcdc048195503f8792b0d32da776ed3bd4d03d293e5c1927c9fbb22285daa1a4c6537f33c5a8870ba04a01d5f41976fcd98f1e0decc7a3a1ba533033bb9581dbdd87dadc917b35cbad90e9cf0436a2ec18de163304634ba3f95b9b8536e7eab15663c551efb4939fe6fefc639bfdfbcab959ed44193742ed17aec0364ce10e5707360fa6b70c1d608386676e1acf95e56855c6745798558eb81a4c2e507de71c919a6b60ec0b2181c0deecccc7f1c223bfc208c0218637c14ef69d833b32d17888271806516ba538d274afde5b81576692d7e9b1600019739a3ecf9d8928b4ec6868ee8540d5a0316c82e9056a748115cb0a14b00b772e9246aefd5f7aefd93d24b62b2834df0c6c4db85b9a7ef2c151f867414a5f1e2b93b42c067b2ceb809bab5636b68acf24611c6e9f2db9417b0a4c7514eab59b4add74acfb55f0cb7aa2305caadee3db2bcb2a024181d5303bb7045745ad25d1a1ec484235012f8ad41fe787f3aa06a2d7e3bf368f87a5746a7e27c0d6e71b9eb90a9a33f1e4ef8b1b9de8420320fca690db4e05a5a46f6ae83c154b7d146f5674535b1862cc1a879c3d27806be320525bc241a93d018898a642c370729f432f92951141174781d79c395b97f1548e5ee1320c58a1801d4612e20cafff52c183beab6f6d5726c7afbb4767c8162aa96c563bb53c70001519356df75a51a639af6ba719d7200036f33ae5fd7494de99949a4632f801224d658ba633f1aa73a3671a3b9a4d374974c0ae6231fe4e344efc1b6fa9569418aa66215840521b9b3ef7f30175be67ce7b31f1fce44cddfa48886ef8e519fed166de3e9891aa057a17c5043c4a3bc5ca505f110da268281bb5c90f53503b8ab02340f03029000ac83cc27edc0f6f1fcb680f63ea6d02177ca99f988197c25022161a701bba1affb77a0780c80424694e2c9735f34b0e254f5ce78d8ed00be8bcff972908b2a907d6470538d17b17c23efb00e73f8fb916887aad6dc97da029fc1585cf4df48d5de7acf785f7e435f3081e6e313efe36b86823f5b30af9e574d40e06fb297aad3c66342988893b3041dc35378e80364ef2401340e538ddadb3b5483597bcb57849dbda0f7b0f2aaa272d12c5d966e030fbe590a7e7bbccc7ea51a7ee16af7e7c8c4d922a3fb0d2e49b36b99898081410d8b973fea4899906c43aa73625f50fc1706a0e5a9596ebda946729af74d8630e80314a30d0e8f7da96a83eec5c8c8b70aca50eb4ab3d41a0b51d17aac420867e0e0059cbe1f2094e68c07283fd4b76a765340216e5257e6b8f8b375d1011cf32d8f75d62d323a71a4031b5d706acee2063503d88572ae6b5db848e6a75dd7fcda39c6927ab0610aee8acc0565a7501735a885d1d30e14eccfed3798053f7b710599f44c69573b138aeeaf81fd4aa0391ac63d841a4c950ec26419bc634cedd2f7fb4a01375844b0815600d0010b1832de93270a1f6bbecf4566f1eadf81a0c24e8f91710053913f6b9be64dec3d793a2c31dcdf408d5b3db993b81d1fbf1220e057a1dbe0d0c58517c487a263a4a6f1cb6c7c2e5900ec3475909037b431a412d62a60d6cb477b518790b3b1886ec655d5249f96f36b1e71ca575c56251612276416db7b963de7c5870b67dd83f3ada5d0e0a5f6e041bf6b7bc462552dd39cff66e667da20a8809d034611f8bac5684e3e52e904a3f68d739d8bd226e0f78dbcb7d3d4a18e318b5f7d8f11cdaf43c094e9593d4fcb9ad69a0207c3c8543908104a1218c66db151935548698ea17322b4892c55fa67215559007f12757e38389901b7980cce50c85bad283e05a297c564ca61201ba9a585c1560ffa458df3a47957cad9f81f6800677e97363129fb8e2c4754fc8ff951b386efa1b5ffa9ae5c9b8d439824ccce14c1cf75be8e9cbdfdd6d977a00f533998f2775f170613716891386655451e127516b904c60440abe9289b6f7689f42a8bf0c3eed3a89c01446ab6ff36e24b0022b0a3b0e39d74c3a5eecc123eede02606c25cce07c20ff63221aafb9ab1cf0e07c18f2d61c4a8f9e4159b22dc983f93f45f9b029cdf4b699455b754ea04eb5bde895b2b6aaeda28753fc7b5b5b1be1a02435003fe46d62f245cfacfd08de32fbd8114c9de15a713113161065544b301f1abcc3a726003a8f3c300374522c592a33fea104d653817c901f4cb1b1ff1f7c5f1dcf44893d41c5b0c9376f6731107cfe4ae632a09eaa0d226d00ad1f59cc94a283d4c890f859366eec6dea43818f0f7d16ecf39fc39f646ffc0752295b941879a912940c7ca7bd1c3fa88630e0394d5073271463ab4f604a0de476d56ef1b25fc772cdaa58f974cd5fc1c365fb0a072ca17b6950f1e1be22cc66df88151539251da0ad50e47dd1ff0090142fc945bf303fe209dc8a0eb42c3a429ccde5490c83ecb63d8aa36651b0379bb8ffb895a13bc9c10213776086015e894e77624a8c56a0b15337d95d5158580ac528966b300010b942026948da9f121ce475e2f4be830881effaa37a029d6744aaf995dddc2477749ca87d2dd86838cee7023d6504be2017917d2eb7e31bf6ea39741720801911372502c1a60f7aaaff8ebbdc5e8c27606bcbfe78be05250bce0b099ee77eb89dc29d903d8ac15048039600b46fedd1c4e205113d6d815efcffc389548f6752004aeca4ab724599b3de8d6473f955c99504f5ee9133b87e438a4228f5ef07060271bc137f864f4c739d8e68728821152183e03151dc39ada8a0fd381790c482998e8044c9aba67962bff8d1f3ffcc6bb2470782d4d7d9b7c842a8529deb81025305ed447a3c11d711d5211425d6fa4c9f4efae77d8f7348330afd20039f8c7722f29176b8bfd4a751a051846d583c2b111633e8c40190af5e4124a9b3442e223e3b022fe794c4b89102a02422ac14dfc33d28f45fd92574b1e28c60cb1045a69f9619bde726cb8b788b5849f9dd3a43503be7fb1d82e78b36a28a595ca49a0b08ee4126f1f27326a0b9578574350bd56aa5ab51b2f47a35a450e99bb3a215ba0b61d17737e9ee16eaf9de01aef74838d0508892533310cada188df123eb0be8da3af04bf016a4cdaa0ebb9dd6119c743ce76e61ba8e3aeb0bf82756725fd365f9c4beb02cc41cf654dbca2260885562e9f280da89bb4658626481fe869cb5fe4a49ef0ffa0910fa2701d327d57504d6826873c2da7a830ac3241a2e4a701db8470df8c14337847e0cff64c02619f7d3fd6b6ea32791c988133cf308d6d6a0589ae0c33766be0943142e21063767f0aaba602fac62401f76370b63c6913087d73d56d28a2ecdf8bc902701380a19973d587bf6d30216772d8b5e1e98ac472e551caf3a7ac0387f527c3c15c79b1b62678edd39d212c8479b2d52157fa0011bb110c3632a747c896bf3feecb4a9b2c2df151d406de7bbeb82cde4449b905ecb360117b9a009626ab90535435219571774b19e49cf6376086e42eeee871987f7e249902385554d5fea030b9ff64ff06fd82d2d9aa27eee7becd2822a16e154107ddd580948ea5d604890b508a0a48e2e73edd245c7ec1ab32ee5eb87365197736f400b95e601efa63be7cbcb7ae66eefc31dbafa7d707318a130eeea7ac9ad7187aa089e4aafa6e29ea91a8a3e08c8f24eb4ccdbcd4e7d4a013e5064853649c58ddb129b9d40bddcd689819a7e0765e6d59d6f260d3f4322177eaf1c740a11ab834b835dcf93174203e19b5324d21d10647ded44998d99b5a289c342646433c633c1401493c027300b82ec34b945979cfcd923885dc68522ac844d9d6a17cd815a8a803f544c1bdefc059476d6417454dd7c93851c60e203d9e73bd165039173ff7d759f6aa9d984b683cd1f28405f90cac08f23a67bf0b54844f4b5020c0a9b1f230ae9a97e9c13bdeab2e20f29169b5400e959c59f9b36ab164bcbd7f835ffc73ee8873df4e8a7eb627c1de9b02d943c44feabe964fe503ea8f13d4d05fd2e9414db74fe04eb6f2132e1e92383b2a77cf337d7bb69d67460433ff85e1713d4fa423c14a6c677532843913ec96b3d033e00c2738a33c9f117a902a40f03febc5f45826f7adeb5f2dbd55b8c9c408227d4c5d0e9dcb3e1cadd1b7f526fefa84a0759a51569936a86760ae4ca3acac3c997af487afe24738360cb7d35d2d5272db6df9e9792dff4fc706997c68a312a48e19dc5c00d42d208666160c4a52ad44e1af044b1bad09b91fcb27345d12a8624cfbb1972123a634036c2fe2561e19b5f834ddd2a10ca7db594cca5aa67450efc5fdb07d9c419940c9f3835955c77ca9c84a7f696a25ee750a877c3c6c673634c4a6673bfb33e90aac50832c7c1a93dca648dd0d5f0be5cf83b91d5761f07b4a739d5255a8e61c59b8d2ad30c6ef3c703faad2bb1202901660ae3eb50c021612dc0cfe77fcc0736dc4cac423f942296eed67a519b4de86e1308eff7ac08863786176456bc72ca35abdf7feb5bd3d4f064211095d0bab7499babab5baf2db389e9127f10b1ee172e2d7240906bd049dd36ed7d702918bcee36cbb014486a98770d84d560beaaafe27b8c0d9af50dfe81151260b02b854fb4ec331d554cdb9a8895a9d2ace835a7f8268aac4226a9432d884a585a11fc898a3dc01476ffa0ade916e37cb42eeaf807c8ab7f613f728e5c7cf4965aa2ebe4a11e5c50dfbe8d957ea1f802538924c212cab769838b9a5ae53d54d7016a0b5003918699dbcaf7a186e32b156e9e9ed8cee6d382952cd394b6d570f4e658eb27acc3f93d34ea60ed603aee456959aea71381a3d3c3b508f8d46a0bb952967b0acb7881928e1afacb9d0b83f40aa38555eeb91ffc2bf9e90981f5cd455b4cf2f4bb754f87eec79afe0cf6f8e33845fa507cec8356835d191e1b46d5cebaf67312b59df54b409c8ade6cdbf3ca6e9c1769bf01d9a564276381c2ef24f4d2bfc7475f39e26c77a6c2a85b85f4b2809225fc15a0c30ef28386813c36050d5efc3408b254a5b8bd3867a52fa56c89141aa07aeb9e451048058130406cf24815d63f4e77a3640584e48db16838270fda013e4709df6010158faeb088a8f43f665f7991bd944d625b991f76ad0934c9a06a6b8bf4c9bf27b969ebbb0dad7a56dc579257b624e64d69528ee51f05db6546a577f3ac29ec0e918fba9696247116246800fbeae8a46b0d41a727337f75627f1d6649a73ccc377bf7dd23bc1d0d1cf8b852856b24cb64b6d8ffa7348fd1571ad042e72c6f7f904ecb7fb2dad6cccc2c37ba133ee9d5076588aee645316f561e0c7505e09d69022aeae397803e8fbf96f8d3e5b659f54de2f5811a6ac751e8cacd39e1a245054b0059354074e6586fff9239e5ee03ee70ccf276df03529733036aa6ca56839ce757fdd73b9557e5bc97f3ba15cedb0283c351249952be42af285badd9061fda4d5b5dfb8f42363a9db775dc212942560957c86c7ed77a67f7f76a44b3b0773035674a2b13841130ac7f01f2d9913d1c39d49493806379de52ae8432b284f1aa6a4f3b26ad6bbfc41dc2f8354a103802d5312d6e2b62ff426635079fa66b71b82622fd9b44ee387d75041558f7ec5a978dd88e7bcae5be9a15c3762166118745dd15af312ca313e3bb017bc5a7e5f616733e65994ee959d8af5e2eec9fb53e8eb36b554835c8fe470e0a51caf439fdbeca70a3d12a2e54252ce4115f8a2423170f4122194e277b2dbd4398151ecf54518a82fdc2d2975c0e2ea7f63089a5cf6ad5eec877a095cc9ba72e96bea9bc34657f464273b0fe7fcca8e45f7ab114a502a79941a27ea3db92e029f53c215bdec2af1845e70f9d57689af555ce27dadb8d46d822235f4c2576e835c0a9cd035204c32ece0c5e896b144c7c8f6e3b1a2fb813e731c01b3eaa5d1964f1b1ca850bddafdd0daffa330ecff80131313d454ebea5e3caca25aafdd18a6e927133601f069341329aa65df2df4d4cb42d1c308662c00e556c4ceeb0ff852e91c7374840a530cb43759330f19f9d1274e8b82d642c4daf26aee34fc7571e893866a126f65fa6f39c61d0dd737cba1be9532db2c840d293bbdf7b65f89bc4a024c7cd94bc5d7640cb58c52f14c895f663d9b3c365b3273793b4686ad574269b73239ff4c109a1a60a6cffd81c6ffa77690b960513ceae55e0ec1df9ddaa57156605c8743ab1c9b9fd7aa1db7e94e522783324c9ed2fa0e2544f0d13b50b3bb3f00ebb07e5e3d12e24f4662941c6bd59f453cbfae1b4252692afa9780ae9cfd8ba8ec447793fdc9d2a9af24de9e2f14e2bd3054fa738cba1132d51adb76c658b55648cbba13109f2fe6dbc3558febfe97352fe0a1e868c44fc112638421eba231e8177a6d33ecbfdcc101122f9be58eb01bb909b06f99064dabf52c24565181bcc38879817604a86b37f00715847d544bf504425f545f11134d0e6e4b494dcb05347f3370d4db13b482b1b5c34211262b23ecb0d56c666f572b78d077c59105f2d0928a5c8e9ad43784b7849074f537afcbad0cdbe7c121a9c969bdb0eb59d97d6794ad3b476debfc2a184c4607ca755a2c3db9d089f27f35bb702e2bfe597f8ba700c2b68e034b06268b63b5bf6adebdb6299d6980aae449f9f30030db7b81339b6c68d0b3c9eb45393e8255487c84f6b346e6e5f150223ff2c86d73b9d72e16a58cc3946f1736288494a7dd557369ef9dc7aaffa007c9db2a2a76a65467bd948310dffbfb7c1086c0d06bccf95f3e264d4a367901a053e0b76acc8b1d16c32ec7727e66d13e1f7a0f76a2d444490572b08dfd70ac851650ce5ae5ffd98d29122a2e6d096d60e60d150695060bca68cb817c149177020270ce51fbf70138fbdd9a8faf4d4573f10cb0a2280aa13a351a038cbe2975d2306c627a03b51a3e11a517018f31180ce260841776f13b41d0734fe3f7611938e909f9d1f989c9b98592b2136aa0f20aa30b302c2a894bd4ae2c0f08a97161470037a9cee57aea814043cf41ca303115b08ba35734319c9dba278e751dc7579aae181bc2f2027accdf526347bddec5f882ae7f4e4f1b54017933713e11751b89dc6766c3e88e3da1b86ef5b273895f8b21d7ab49a382716b3ea80df0bb3414d7f269367aeca02276b257438de06c00c7f02da4a3ecb9ab760bddf48e1231a498edb51f3ace93ed817ee389ec6d59b4bc4b65ee6d09f85406fe68f6996e9de522a94ae140fe8865dca64e99b7da188de6277bcb5730733db88e28b25528857f74f05062d0f482b6fa5e1092f2cea24bd1b21b5b7cdfbf86432e1db459890c196d8131930cb957d103104e2cf5ca3ad308d17979d420136f8668e38687572cda7db47e31ad50557857b1848a49f2b4573bb601270e19136dca097c1ba52f65ac451cd21a2a250ccdf2fe2bfdf051e96ee23f363ba41de0f07c410ddb80ac308807eae7431c84d60e41bdcec8de7f8240a24644efe9aeb93372e9ad7fe926693c8c6b7b6cce059aafdbdeb17f728bbbc952203dbf183d67b4d6072e7953ab41d9faee102d59fcb53af1a3a79f8507fbdfaa6ff5c03cf9f6bec1319dac1473d044e687908f8cf56929908a3e1129dcc198e290cb8fd77e215d4411c9bae9d2a38aa754f68cbd76729ef63f193f79eb9b5a18c6ba55729c42a0af432e15b1f59c63660a1b32fa11032654335c28e2ce8d1660b0e695cf5f0d8d2c7a8c683bb08f9e3d209522e139bbf13cced6db15ebb03218cdcd393ab2e12895bf5a160c25aae276be852ebd8705da462ce2f62160cef78930ab9d2febd42844bbe80c16d0a314a5a7417e2686a555f6e59d6444087062ce7f862f3c3d63689526e75fb75968391b8f3df6e47b46bf0a09b9365de696081817c47a3dfb33be4ea44d999376e639ade3c5610a9423773e07507e4322d1a9b313733f4422dca50b675d2b10c4df01c85a5859169423df0dcc3bb5dc31c1ce29dd5f04740765b9e6752a930d886cf423d4804194f17f3cd3d036ab7d6304ff262b0c09cd4770bb313f572763a0a70cf774b77c922f3c8f32ded9e23573504f37d26cc66e235b6f1efcb7c64b489a7f7a26fb047553043b839eb679f2e4bac6204f83258dd722f64376aeb56d7de226e9e97534ab86bbcd567fc21fc82b504bcd3ee793b50ca50dc2a03370d03eafaaba346f522094f35764e6ae2e919564372e0db26d514031e436bafb0882655b3daeef08a25b06ee2a49b5c6411fe9a456ca448e3d1ed11b06996d3b4ca7650d9bda0dc717fe34bf10fc776074e293356b6af1adeebb5d39e0620cdf6aef2afffbd17315b929f81dd614e8c5a9da1c92dce494bf63b1bd69fadd6d8dbc916cc8e2733d5359aff2ec6995094b707f598763354b1c50227e12af78cbeb3ec748b317c9bf6d896fdd66e1a799556bf061831deb951d2bbbfeff57fc106491acc6591017d80b04226cc8ef083421c280e14bf6c8bdb2aa247b666ada6edb76c79095494e31025a69dcc51bf083d029ada229ae78f89aaabec2bb3493ff01f30054a3ba9f1e196a2d8b19eb6d036e193895c566707bd5ec1489fdc31f627df6dc90bd9e27f38dc14c2b4dad9390bac3e322cb164b4b82494f25f6f46a9b8c78983a4fe8db9ca378a0c0ef628614ba477e36e9c41fea3d7e4955ffddeefd9b9de185ba5e3993602b126bf6e1fc3debfef5b28f3b384b8a6849a6b10316e4bc00269fad1a2fd0866df7479164e98d83a152f6d7573f5aee76f64b7ac4b3cd908c5d42f04e9253f398cc73b25fa118bac5519159990f9f2ea014e9df94a45db2375e34076a533264af3de9fc28813661c9efdb561768ee247094e34529a1f12e181eac4ead00ad1b46658bc3897ce019e77c119cc000405b8cb0b1038098310c7a25e518b8a9bbd54746e65e99e70b6a4cc1dc1997b92e93ab4d7fb6bf1f7664ac9608ff7afe16bffe80b1b4eb57944835ad534804aa48a61bfdcdc72e4786413fe9d8d497915c848940e3e4d68b0f248d68f670ba1568d3395948ba1f1f23617dc780f0949298c9539aedbeade129e9fb778d4b8a162c63354057fee3312ee998592140d330357742632214e7e01ed29f4ff9d584ae7ac48ed154fb3e0b6bffd50aa664afeb8769b6a8acbef8a7a07add7453990202dabf0ee13ac8aae5a0220774e773e93788b14e50c1e9ed0bf1d03a1ccbfde97ac81e583e09a312618c0c134747fc2f554074235756f4152d627fc908326562f26f866e5ed4ce80b1c54659856ce1f4cdb1811766b50a6458d57957460914d3c0d2cf5a8c3612ae54a927c6996df37e551f52ad4f65d00b2297ce7b44312d65da98300af3952d49faf5492b249f0f37e28555a638f9b3776e6e15624fd6368bbc4577169545f19e881267975683865b03142f0fb38d827df42b6fbb11d38a5fac201d2a24cfcf9e1b10fcc3455391a3de160b7b5a2bc835749a0127af7060efcb5589fd2e87674d24b6e36f34a46d8bd4c2013e3cf9169ec0ceaeb47ed155a48f88c4de65fa3213884027dd9956be541bb2afa85f899af760c829c0e531503a9d6ac2897216770adbab718982914a522c6e5d860d7816ca6769f2300662889529bc6bd4c7d7ab31944c86912fed662e4289b02cfd5c095657739d58f17d7ebad7f69a338c360b81e3934113da12d3ff1a2c5deacbc1e55dc3ba361bd0bc32ce8266a1c6124eecd7847cda8ec3645f4d96dfa0b9b1e97b322f74a6d6c2e2e52232c398006978f9cafc8b8edfc07b3f7cc46d275929cc98c1ccc02b4169b04e6f627201d49477eae54bc467bdee9cee77b0134fc5710b8fe8fb780e250d27d5dc050f37411e7c9eb01e2601de9f7dc4763ea67966d930ccc3bb22609b5e0a07081a6c507bc02d6add5bebf66638d0470a07a96ac36360d3bfd4c6162beb82f0f6bbe4a4368200f216ee0ef797fbb22909a0bae45128db68cc31f078a297da3aaa7917e0704562dd1d37b693d3ac06c44d5de66464533083673d273e13e82d1af662d9e727d43eef5d11c2ee96b7382f339fbd61193447142d38c7a289627656c1b398149aaa11e92c7aa110caf24ae50e7f7baa23dccd1a527e4cb9d08ed3299ac25c0f633fb79d40df4720444e4cdd73c2638f66bc7e1edcb06ef949464b1cb0bd7e5a246556313516c1c5e2dd507b9378c85c746480f709ca97ff782c45cca79314c46290f6441ff14b4fb5ba1bed69784938bb38ddcdad72a80daf1c639278ff2a14067ebd877d3d437c6155f819947733efe69981def79732fa5c8dab8e996c7be7bd2f05dc8b48f73ae3d1d2ba92723d0d019015d8673c9b8da6e957ff2d26f7e0b89b275a38465a61b6dbca24d75f2da876677e02318e17c7d0850abaa7726041e6fd8f8089c31950a60c4a82b03335382c430ca126064941d488e2c0058e581ea7403d1d10d75a81750179e178cfe6b000e376ac276a1624b89fdf90c693d7e2897aa5961925adf51e1cf5d52c3e4777a40205451becc3ed971203a7590f66496a8dc1d9c1d1b2990d6b075f5e2fb473ec2cf4c28fd7d2207b1ea932db37f09e8bf7e0086573a1fc3973482144b575e362ccce8803b91f04e1ef200c0256cedc915205e47b86a4cdd6b72a741f5824a473287551dbc37421348bbf63e541741c7e70434da307d9574dbcde1d4c3a83ba4ce53fa84b3a81ae66e93bb6289b96eceabd8bceadab2925152f1e5017c46e90acfb1a8f966ec1cb3e99af883ab4d893633fcaca1a224181e735c0026919ad79e02595778b429cc56dd6ebe22f4dce67247758b9fcb483508d75ff835b22e4d2c47647d91e4ba44a2ce4b67b7435fa8a65e72e68f98e6692697fb769b3a5efa7702152df888ef9d36ce5c41397865f62ba9853403091f5eda1e4cdf0e1ea5de2962588ab345faf2f1d66619676ae37fb92a6ef902a3201d6c34978488804e729c3092412ddd51f0bd7bdfc25d900a565fdbfb287363b736c105a8b6ca273ba0d131a6902f324c71243f6eb42ef49c2d83e68a3f2e209ccc159ca1250c7c1457596f29521885164887e20c981bcadb3bb6fb3d6a66fcf9babf72985245b9af5023ad07729c4b12b828289396ca1c3677f3de538c4f91793f04156d822ba66c550db6678859c3c79dd195c8cdd6f34d4bd14cacc5b08bccd910e87db9299ddf181ce137a640c1b09a4e9bafdad503a62b8ebdbba7db24ecde3e9d7b31487263b1c0c0bc5468dbdc8723b6d0deada5912b2fc03038ceb8c28c6f468ba4066ea581a67541c053b7b7ad95b2154f2f7a4ad74ccfdf413a24766dcdef1d3169ce8ccb1ff6a2af5075f757ba52149be1c64f095c579481b93215de314cee2eb6ab73dd74dc4b3e2fd8f6cfc8ebdfd92c8bead029fcd4ff1b9bda3ed938944973c75d47e07662d01586fdb074dd0c6ff60b8eaddf917161e524a616b2b859fa00689d150743742e8f9c0a34cadb29fea1a40c127415c0ba07dbb225f7be59def6eb7a308feef7cc44a7476ad5cc2a77832b6f18d05f3910b9e685c3df9f2c6d0123b18685a74ea53d8817ba69bd70905f49c4da3898f9bfca513f6f4b1799bff1e0a98519b8cc6b1a3ffda0ca5ff1b6fb2b2e0f72cff840b494871e80832bc96fcfeee89ea5e53885440ff4ecde90f58f774bfdc9d3f15840b843d75801036dab4ab20d01103b1cdf92d6825a6e7b54dc1341ad474cebc064b7827183a6ad012bb80539014fae9bb991fd5685ca1d13101ca7110d556e2018211c9381a156d7cf0e9b93838979184dab18d4bb94a7f6034fc79976b9791a44ffe178dd234e4c8b3bd010149c1bb07b6aca189d99b2b65bb3b4da908948f63795f5d86330797c3d12ae7bad72829a736930273a31445632b32a107b6e40b587bcfa8a975feb81d921971df2d628919e9e08f3f022756781bcbb6940f60c4dec6304519734c497599ad8b1946b1eacb9a314ad2f867461d8d1a248fbd3033b375f888a5aa7bd720ba8a56e6b9be7a3849ce333e9720e67024e138cea84db546286c0c62bef5bdb6393728bf295b8efd178477d85f7a553ad31210da95d71656cb2e1e935b579ded99e672ae630df2f37ef0afc5b4d3e0a93650dc121bf2a3ff6e166a05732ffe51912ce2df0ee2d37f398803a7d88fafb4267ec7764687cd0235b00417611868c7b0d1570b2b9414744a6f1bf70b7f762f78c62c7e57cd361b06fe6ee8cb1843875aa775b2234186131b76e76a4f356af05f1cb7ec1b1fa8ebec734bf99efa6876e839afb06563600b28b04fcc6c267a2a250eedfff967c05fc5330c387d5e88874fea06f6a5114185f76a143b190565372808ac3cffb724e85f5f06adc5ef4467a739220b025cc55987b535a86e7e20a42775d9ffee6cbecd921424ff7c9c4205508fb2c0848b81ff5ebd22fdff3c98c42811bb1fceea8ed14d30c4763c86a0ca4d0eb2e0b967c0c86bab4446960101a1401102bf1b72ba4a12000db12131a6a52b2daaff63420dbbf7ec5b34327c6b6066efa88f1144748a213a461bdac8a325ffd49c44a662288f3b429783d821030ba5043bf5f6260cc83260ccc9fa80eec65189d356b2bbc4d6e34a20aae0a7a7e4375467843e6cf216395b9d469cc1a5de6b8826755235084e165af0f7ef3d6dbbf9431e502d201f88b193ff51463f8bec12f7d1ca22a00cf9dfdd66fab93c413eccb70a68f6f2b849bcc453a79e9a3e4c89473e05c9da7a031738d94a473eb80118c88be7d97854256c3b8a8958303eafcc03e7c52740ece204d948c90fa7d01010abeb6e1d7ac70b07aa4228719d9d5e0bdcb559d51abc57541fbbb17c56c7db742ffe7822223d625f0507e1ea8df6b4b535790eaae9cc10378078e2be1565fdf57ab59a7ce89f92b53b6aa8050317f76e0dce1a911f9bb0d971ab2e5b56b8c3c8d1e36eb2ddf2e0df3c50c6dc3f2834d5876fd8df53c99e4826971e51bc9ade5f7038d3a8fd5b8c320152be8f7dcb779359e47ce4c8ff02163699559d02d52197ba2011dabd94b25f7ae533504c3f9ef58fe37b9ed24b1886e5cdb78fb430e88c5a98d1d97e10ad724ca3c8832806288ff783a972e55f9b87139e07070333f79bb7caa7cdfcf6538708e0e25515aadefebe5aefb2350d55b7606a67ca030cff864e85054cde55d9f1ed6a413b8f6fe42387a72b459ccc73e5b8cdd15991da17368e46e8fc4b5b3be8813937b6b77b84eaf162443b4f6cd2d9106043e12a17ef028dd013e8d63fbed1c9664c9833aa85f1e6b40fb94635b2745774c8af03968c50c7335f1f8d0e82f7e3fa98ef6fa997184bd479021dca8d66e5bc2baebeeb58bac5f07bae10dbccb3e31ccfd3df291a8088c620e4972936c158301a1cfa2b9ba93cafcccfda669ad3d2089c657502bc5ed352cfcbc8c6cb73ac7df56f7f8fd1f5813d2b43448808b8c039d25cb730ba44d7e0035fb5da6c63fa841d6727ffa20615889b93ad64f9b8d8ec76c18cbc882863e7847d2a63d519a097a09c1d155fc87a9b70bd232ecdd04cd94de00abc3aedd68e7a838d7d4b25257e25abfb88d07fecff887077877ab586aeee91733c41d363dc41fd7217ff7a6198396fe9c71e788ee1f7f3e2a7ecdcb070f15e9c3d5de481c0db44e89cae54178dc22aacafc290361cf8f99fc6be22d415fd51503953a3021c3fd116441e91a5553625670c85f043d0043974787e9f7ab949f79044a96b26fa5a69269cf475a86126ba92c7d30f10ae8f7150bd52a859df46c53420e425b8302f4adc55afcc7f6723a0e9d38c5e94bb7e51a88bb938b12dc26e9575105771490857638d2e9381c522e0b9fa3d816224ad97057d0931ce72309de1c054f757d7d70646e210227ccdf721597dd35809088b3558195209a536db7615501cb305b13f3b8b6053d6e4a182a872e11ef0bf0b285f1e069474209d7ffddd545b0998a5f35d8de04e49598d0ae776f999b1f1722f89f16d167a1b129faa021b95f0da0b517682868fa3af8804c5fba770ffa47d8e4feea83032042c00ee83033a58ba633b920bdcafadce0b6f2749a01094892929d79f65c6b45246603299f8637b29bacfd8b2e1b20fb567c124810aae628f961c3692787c07a726c989f42508765858d4048394d74ec59ffa8c1af0066923133ed78153b7be60bfc21b5f72bc992908fc8c2e73ddf7578a68350f7c45353241eb8ac16bee5af9a5f8bfafb5882bf9e51856b58ebf958cfe3fecb0ecc5c7381484c0618cd3d86bb7f3cf792114633a3c6c75b353de28f3bcc77c3be147a7177748c2d6895f39aae8a68d9da3075c81e4947dc7bdbbfd0fa59ae1032bd840424d9cbf2d7679dc6e6c858602d8b47992a757fe623b664a3dfcf7bd6445237fabb054e5f38653af61d4b1aee2c49af7b88cd06deacfe6136f73cd2f0525cc91ffc0ddff00b092560b3a304e1d84028da2e6d8254b06af27cc6cd91d6dfc351fa0bb3f00fa16cafeae1b55849710181822e35c154f53887ae48b367ed674ebb84a7ed0513c6a5edef99bf17f5801c123043e68e17c678e06e6d9d0496466e20b152ac5add0712e5067874c8ee11c823726b1508240b268f02a2e126975da3243eb87ecb8cdc945466382951d08ab0fb5e836963368ffc69e68f863d758b1f66fb29451963ba9f3ba7cf59b73cf09f8c148f0b45770b8b55d9e1af9cd26c0478e2388ae20805cb0b9cceaa7504a23c22746747220a8cc485ce36b010691a14dc35967a9b8b3083a35af07d3110ef80ee04fb109a7e67bb498d51887648d676e1663735bb80b32be4724137e0e9a3bc62c77cd6c4af4b527d9722df0dff54706dc2c75da697117591bf96f9dd27e422635339712d8052d12a68c0d92ce65cdb8e9895c87237cc5dee8d618c76ad8c5d9066bc0e9bd3fef097036e90435c99ec845d7070d0dc6663e7c0564d89666d00f7ba5e37826991496849323770aaf46f21ca47aadb791b162fa7f95155330b526bcb5504122ead3d9747d2359deb13b55f70c6ed7c7a65dc50637db611ee2b0f5565c5146023a1946faaa50eee0eb7302a03c478a4a9a73b5ca9d34596b6fdbe9a7e65f49ddb53ba07e69f2dc164a43bf361891d50243032092a57cea79631f6122c870fbe78f81e5e52f613b250d7e2c6a92bf0e1f1c6a1f54d781d4c32c6b51a0ffbdc147c80e09625013fe0ff4f5cd7c50eb77d2d75fdfedb711539eba2e9d6669e46de436a51c3d91d39c09467f61101747b9ccce84858db1e5b8761003c1219a2e5a76562ba5bef2d97235e61141a8af4b1328b83c0ba5666f949bb39ee54944c17757fa6a12723741cf67bffb0d886aca8053585d1280ee01b3483383dd511f8b9fe39c31eb5818b682055b1d443d3bf76e9f72a1456c5a35e6b0fd15fd9adb0a25142bd44762def81ff6b249b79dc51586b403aea03c2fa78e6fd8d2cdcb5aefb8c8869c8994c697943a902b253f15a637abb0c694d828001494ec0bbd99b0d79fbe1dd2371976b4f957aef84c0d230af6cef1bd5dbd9bdcf969c4df5c4b94a03d26e2deb37d6a86dbfde185978693509cbfbd8958520139b4aa5566e5070f9402a0364c570166aeac0a0bf29a47ad50ab2f75a81e65e8c5f3c97a731509141b933c0922976dc1a0175237bbf5adfed9d03f2c6d073a90914889fd62901f76f6bbae963826ff001d914e30a05b3559638d987f4a46b776c80ada01377a20c3c316e29f989c134fcc902989762133b7165010b6d25c770927a6aeaf51114e83dea3308e1c30e6d0f0317d2e104cfec7211af65020f411362cf15e5ce1fbc11a6b1cb7e67d732a05268f057a9a1c23a5a3a9fb40af73c162ac1bbb6935a0ef73ffb02db4ea6d5d415e52098447605a1c297452983a946155c0b10844eed845bc17fb4d777583d8efc61acb6a7c8f796960a72cd643f9e329b07914059f4c526144ef7de8121cf35076ef4d46c678bc7c6f609836aee1ee02df90bf37429cedb50137b2c896324e35912a1ce8b0320666e8e4bb9d14355b941f15b7684197484b9a82443c8e7469c0f9f4fcc88fdd6b50faf3ab2cfbda8d6d864dc39a602811c2096d5c7006a81ed286c265f044a4664bebc140873f7a3dd4e04731fd4bb70e8ee5774d86b2ae87930cdea8246a113ca9b188d68b9c8a229b3ce71d61436fea4662c060829d07b82fdccabb46d366d8137d5abf0ac8d2b860fb3a4c4691192519b79dfb3fa5b4c0692be4b9f976660f7e27955f1e5573c0f43bdd81f702532bf5477094bd57730ce79d026ab3085ed5b8176fcff72ee12fb5026708d61f26f3b41ed1c336823a6db161e7f62a3a270c8330eb9be74278fae47effbc0893f604b3aeb3f9d6b489c7adf77ce4afae6593c2868e83571f03077b2519202fba6a41fe16f361d77caf9627c92dba081d69c494e7c20b0a2e33c876a991f4d6a2b634a47731d78843b7331207cbf78a33b4de486c275606e4ca23d5b812a47f6c07c381fb9eb8d62ddc1e014efb1e90f4d60150b56d56613e48551ff96086fb91d4a0a97cbec6fdc891426af4eb46ba7ee0a620677d2ef3b68e755a1b81be5ee14e3d972190ec89aa7d1ce7900647e636023a7aa16fda2b9813b3bffcf8d230eaec221856ffe8064c3a9bea66c72f6439fc3008f18f89aa28e49fd623f09964fd38d79b91732750d1edc07aad2d7ebb714abe06a198521cd8b0de6388b0f83c7c973c58b9e029d270157d2622162747e5045c15dfa5796f8484a49b759907d29414c881490cbc53eb105fd2990ea1ad00b95480d6e950b5f28a9e5bb7e916c5a5ac0709d133e387e802aeb26cd227ff0f8287be0f2e014694578722bdfa1e8aaaa2ad0ec4934f7c0cc31b5f72bf554638057ef579063cde0bc15572fa0dc2ec0b41be7b3d896b03a767055275a2081f4283cc61d8cc1d6bab971f22961a5b1ca9bc4dcfd9ca78f688f06d3f6bbf0c5e342a7171aa163f7c47d6ae9c9e0e5815f40742552800b21da78646aabc4b5acf674d368d0e86942af1eba8e4ee8d5ee0eef04c3472410b1ad2552cf4ed302b495f098a46509b3114927fc6ef01ffd07e6cebd5d583429a03e07c58c788c9e56346a6c8679acffa9b370f754a00c7e09cfe702f9af4238d8e3872ee6c109616ba423d55f8896033eaef2a90b167355fb621717edb819d36ff82dd067fb469015ee73eb7384321713a5c8474175dbfb0369b51cc9cdd24d819bab891bc76cafa3a87afff80b5d6d2bccb8676b8c19e5b4ab08760b16de3556ec2571e412b87c077938e59b0755331d7fff3a99e7701e9ffe0286e263581595c1365e01d911d1ef524079c3fb8369507f47a30c187d574a71c2ce445c8ce8d317885f4776d99b7106516ea14ee66171f760c086eac1f47761dfdc3f54ea74938a73b706905ceb95d19431b8ec87208a6755d946d24e56df4a749987a33ee6d6e7e23b9b0be00500f3eeeba80f157403b11c712b71cb63f031c14ea16bb711599857025b7f2942b683448aa3839cee700d7ad8b131d10f8c24ac7ba075e848fa8bddd5828870a75766ea4cc693f13f466ca0cef4e4f447299e158da689f97abf4569d9b464e885ac2b87b1cd9002e1de5bf86d6b47875febe38041d4772dcd1c1bb026115daf7eae3e9bbb7b5c4ea4f8fa78eb2f5051da0d121cf9b61357d8985b194e6bc766a870fdfd62212cecae17a5483cf37534537b327e22e8dc1a9103be5c8cce088f9a1f1072a17c63537c9c480904f453689ea82ec7131759f3e13d7ce917c36e097cbe8e92e86fa15cf1bc60e2ed31f4cad1e34149ac01c8d582e17d4f1f0934c296cef1394497361a55576c5080766115356f2a3541e1fbb038d4902588aa7b517286a3f1c37415df19c28829dce45bf8416f58b40ee5cd425034fbca341b820ee66f29af9bb1e04563cc4d14e68bcfcc547a6e56300df46446ab86780d6441513f9d434e405d81d9297ea2de66ebdaf3231ffcfd19536aeddb0bfe664890190dc34dacc471715b86ae7c145f8dcb57838389d4403abf1857bcf56524fc70d325c17070a4e4a72355b15367e6c3309ecbae60188c35271e07f11ee3fef6f9463fadf3c424900d5b6ea722743e5f1c232f1ab3832f13631016dc9c97bf9a1c5ad7c74a03cb48d6a49a91dc5c2359cef31ddd6e3887c981d9364480f28a0496da427f1ffc7a7f39ef571e5082de1c898c9a93812c6a7bee34f56c8bacd16d952c8a03b1bcaa55b78492ee83c5b0c4fdc4ced346096d0b0942c7a3a4b062a6d2deba24a0f5e3f689b47d8619ba9619d1f45f1d122b816a9ef86daa93f6a0b47a659466ca79551e57ec382e31c1c6ad273def91356b25cf57cd57094e1f186f24b13865ccd136d5b768b29f172d6f19ba7f64bd885c55f4fc6ac62ef02261ca96b2d57b66c74ef45e3a5d38090772afb3519b4a8f8a95397ebda6f878fb52975d03c4b34cd124269663b7c73cf6f14387b3048c19834441bee0024b801f4112f346725a06cdb3861abc8ecf52c4d05759858712767eb20099128bb6ae2ac66f141cb5102beb7527a78869ecd15869bb373bff9ced8dcc37114ab8c7a9d5e6aab11fa23cbb79cbfb26b9e1cbe54080122898e0879867e6dd8da991148b40e4b1c77697e618041537369cacee5df71356e17b273d932cec3a7d9318a0acbd818b399dc01dfba0b1f3e7d0719ac50d6827cf10e14bd1049d43bcc2d6d6a7d410c2cbf86cb4001ef3223dd3ee510366f8ce14ce3e4eec3323427d8fd25916c8457499bb59d8110ca3fed19e9f60c2c62f8b9d776cbc309e3c47e3634d9ad57d05f884d22a9d67fb2c97371ea80c404990ea7cdb035f5c5c6e13c794136c75bb363d158e69f23b47d02441484d53f4d74bf4fe868fc8932480213dcdd58309445681cfc4b02211454c0430e912a4e8451c8ba3d361d740aa15901387173b816688808aac594b57eb1225d641e45dc8cd0cb75028cdcbd6debbdab541beada98147978f5cce478ee09815db8ffe8d75bd754c29452f307f7ea7e466cb626da601263463a705a5e9d6a49c23c2d875cfa488f5c58467ae1a057b3cbadd7416cff29e6d33b2d950b80b5b4590c3b72474ea9ca2b34ce33e6a94f4b7185d708a4781c8b695aa9451db25910a0f2c5ddb2221a1dab8cfaaf209f6d2d89cc91e44508af1f9fcc4b4ab4b4c56ab257acffc9d669c5943e88206b0b2b930da2e72bdf916874ef7b2395144a941adcbd51d0680f8eeda72618e38a6cc8ea70e6cc0891b6f691ee42852db3f686b3262100365f3bce2cc0a1e3cdde018fc7365209319a5c2d6b76fcf5c66eb65fdb8a8c008fa032640c788b4763314d0f771acb2977d4a942301358b1702199289802fda44b41329ad895ece59f3c98ae99ea038759ba2202998cea3d7a1726040bce6cc69fa379e7cf1d8e3a05f41e88915c2580c237a73d6364b9d83a07eaa76fec132562f50317b27cdbad2b35af71ef90a4510b508e21159ead998c08ecf1bb331a56ad5df250b71f75744eca97384d3eea756b3c9998f3c6720118826f7fbb6896a035e3b84a4eed4bee0dab58a9f6da8966f0cd72c4f3d1fa0259ee38f7242682af4b8c279abcf1aa1801acbc5b90b6037fe2d13e9cc32f734851430b8b1d6487f863718415d80baf53dc5b9a443ec329b7d4411d6b0599abde7c411e0e7f580f9439b2326f1d040b89a1e47f043abe83fc3b48555fb7fcc52d2dbf0984e2455ab1a6215f966e7214c82f728c212e5b9e9bb3208df810d201e0e044333046204b4a2899d7af1776f9ea7990bbf9e06a0c639cbe968a04d04e53f4a52937c58e26205641e367c9c01201f5427ff832bd23035af8dbd83539f4d349f511da7b67966a3090ca2126a5a50a0e2c7f2acf6961cb0b4a5a8b1192c187e207362e5111fdc5b304aa6b6bc91b97744891f84c76e88007980c20f64928c9b7f50ae8e36f11ff83678a57aae36959a809ee0b535b2544214cd39d5b854351eadc64a075fb190369698a5872c89fe785d12c69a3261256fa94efdea53dd0e32ef275006728b603327918b8c183da628c463f3874ee2677d6afe479b5b9a554040daad911258753f52dedfea8696a15189d616660ce31ca3ca48ef68eb48b729225285992875b66b0e45b005a3acf5b25cb07d97622a03af127a25a5c149ce74c3acdff05323bb5dbdf48b67f1614665b2d9fd02b5aaad20f9f8c18dd250e4d8a23febf19388fb41f13ea5179abc85cdc829c438c9ebfd1fe86edfa5a03d34b5078e64e653efa12e8e62f45d87fce42cd230685ce7ac580513e4318c9133554dcf5f6dd06d9040712d57b89cd2c247115bad8301a7384378c17ec99c3035a381ce1e095af4b1fd57ea6473f88790d006118d8fe990e19ec838b5f36c9ec44832ef9299466d694ef0ff95d96877e8362a98e9523bfa4aa6512eaa309e02a0ffa2666a5d6ecfbfbf188d07270a236018dd39d096b954a1d7c51fad408a77ed4aa3b3b12fc15d2444fd533b510de2c6115dd4843b78063de79f3a350e834b1958a48164ff21b782dc8ce1d36b53415a587ab3aa9804d6a8d60cee13013117de58eeb711db402df3e03d335dd9dab87dcb9da35bff7000f038319af97366d031e37e13c1f3ed536491506acd9a28704b5aa4f038a3671a406c6d3cb30a6f1cfd9792c6a013eea2d267db23fcb34a12a95bc3c9256e334f5c19cde40c6e693bd223525d39a850bd0b4a24104c9cb1472194a64fe942be983330bbba6bb3ec16c7bedd48a86fce095e184c07a9d0e551cde0ae2c4667190529aa6aefbd0e655db6b77a26747a7909070982dc68796c51ffca9d05b78abe60fcfb94a9a20bfbb59681e62d4d7dbfadba960f6ba35ec7897307c1a79eae759ceff58da127b21140177beeb71a00eb2d8e1e82f5d6da406c03ac0c636507552ffe64b974f085de2e81e797eae456352e3c14d39720d6baa165446e55a9ee7f8b96024fdd45a4bc22e5f4a0eb1b7bc3583665559f62d6ac272fc23607d0e91b331841652dedf2e6fab89a446b93adf871809a490d7b0dc7ba71ad059751cb65fc97edd75eaeb4733853e8c24adaa5e46acf77a63094f63b21543da423a4241544ccef94688d454eeec9d9366cf30021f288c35eb86abdf3cc641dba770c0b1b31c116658bd35219d4d3c2a023f16447751248d88221e6cd9daaf11cfc76d561806f2880a2850316783ee9a91c4fd7365f74457019c3eba59c3473520905734f8fa8f879731a6dfaea44036cafd6e196f4158e6dcb122c214bc51ad1ca7bd11213cfd4693a1e4534332a143fc38db95d973bda61f009eb475e80818e86b450f51e1254897dde5f01c2287204bb9a928dad0fe3f421c9fe5bb75524295f0baedbf12df93d331df2c0d8bf4d0c37674f1fb9797c3e53c9e24dedf82e8b35a76e259f10c41b1f2c57b3f44f637b56b431bcc8bfc1af9589f7b4359c1d33766e8f340bbcd0151473ca2636556c63fd8d193201efd807055bf1da2b606b1f48434e11c9d7a671bfbb224d69342a4cb3ad9298a2c385ce5b7d8f8d9d4d50552041982f21b659688fe7433f924a412f9f410e8c4e67e923cdd95c6ca2ae68dd06e7270b3aea2eea0625e241235a7912a23941a011b340cb406e43e5d0bf3a9d2654aeb21eb35637e585dad0d62d1fa987c3e3d86d378def823c220af7b431ac4db577d2c8d9c9e078f7e6188a87255595aeac0978d366246f1e5a486501af47bbdf31eda7a065681a3c99d6f2dd555ab902a4dc11064c25974cdbee2b6b0e4a2b11ab384485d5ca2e66f535fd208ee01b8200597822eefc76762cad6c547fea95bdc25dca55dbd76cdeab22d2446347b4ef2edd1c1d6a2a12b36424d3dfe1517b4f9af8d835c1fc253db2c2318ab7d74e6c768fcb8c37284516fdf63b744de7cebdc9514a80c947f168acbe83acf847987846b3790d02c2c6d1a3638506164ca43a762b15bb8caeb1dac1970a86570f992701d6685aab9ea47c58c47c6ed8da5fe4090521af747e619e342b07f6e4e763bcc82921cc3d476b8e039a0565ecae7fcd01cf6b2095bc003499c9cbe9c7fc8fb0e437c2897885ceb263207a808f3c791587e5b611023e4ec7359f99b0138d6b069950a24ff54fb9caa68f7db4411465d07c1b1bb731de43417aca7e3823495193d0d481ceacd4635acc5f459ab35087565d5b6c51136ecbd1e49724adde47e6c85179e377109884b3b9f964196bb8b29995794508f5d34e314a6eb60cb3e5d76c5d869f2e1230fc17371252a484ea8b2ce18b0c87f708a613c287914495102b5e297dc578e5fefce5b761f88dcde18e122ac46b0b984b2b4c4a3b79b8c0b45d43548f71677178ce4e7958626b9eca2ac71b74aa5cbfaf2862dfc504bd5294f615c6e06996be7d17327b0ab931bcbed9f337d82b4f2792e6c08573aa8f7fd6e9fa5ab46eed8255ccd2929af7c0da347a094bb6e816d310d57e114126a87d80922a13ec52e4fea5e250745d68ae76223d690d411641371fe0ff409bcd5a59d4d0c931d997cf9931d90e2fdd4293e878e3c124976da3073bbc70769be49222ae9e9e268493ae752542460cbf0f09b6c23f894d0eff6d9d59bfd02c54c15355854ffd12d0d19c5d94c100f0a4f694532fa237cff5fd10785993e51283e6a71fe203dbbdb466a74b0768468bf0ae939549fad2a8b242e9adb99cf1b741b35842d5f452f381851207132c4ad45e0e37c8f8de0808c13d52511dfc804f5aee0e640abc53a8350b1021a872c712b04fb599b4d31466f1d4823de82570901921cd1e06c55b5c268790d83671343cd9a9882b82ca64794a0369d7334507be1331878c758a040398e303cfd0a7103f3bb533bd8f2c0ebd3983d28e20e980831216195b44c78384c3411f4ba464ed860e0f301928e3c471329869f1b2b9f4cc22be8b724b19ae6cf4f15d1092f1dce0a0590f01fc0dc6a914db14e9935ffa268dfce4dcea1cbe14f890a64d810702cb919cb1d4e7663ed28a2453f415317582b0f36ed8d656decd6364badad26afce5aa0bc3714dd426dd2c0b6933a57ba187224abfc4e035f21365d8e2e7858fa458dd73d6de962499aaf7d1c9f4ca3ecb359ef4c7fcc36f831793475f2e4e67debf9b75e121fd6752a77787608394cc99af475432529ff48a8cdf18e08d1151dc5d04c104bcbe5fc5dc699f2dd2980fdde35dfc7986b657955b97e436e596d994290d3ecc31ca093f8ecb4408726da030c20fea6b054155c3c12d4160e1427844f5905bc8d34384cadd7a40c4c3b113f34d714929a54848ffbecf23c00a1f549d7a9d7a0d6fdba57316afa362d7b302401cd747b5e7614f3948d2672fafc45310417de1790676fbf2e5660e982d436c53bd694eda14cdb15080abd743c0548a706be0e1fee443a64e0587e521b362e27c9bad76f8e58afa486de792ad5c2d5e14348c97f43b4ac17a770412e820178a40655f2aea30b75a99385b2f0de95bf3497d2249aeb6b0c75d3593d32dab02435b4325ce84ea9460f41e20e0665594915a4f11001d5cc1a4f2fdab7543c0c6230455f2b66d970e477a6f90ab85a4777a98aa0d40ebf75ffa4b698a5ea4664d7a4851f3f040db8dd9fadac6eb416a27efb334d663daa8c53882ecb2693de51227aad10001ec19205254fb0e84842a62c07e1bf6d394534507631de36cbde7db7e3e9038cfef7ffdf2564612818a5ef257a8352042403dcf612eec14d36e26364a543900c5a70e3e00326fb187780225c4fb2260ca3258b02642705a0f44a4e5c579516528ec5faded5f57fb241ced46d1f7ecf6709eef921d1fa0585c3dcf7bf06ba1723ae59ab9e0a20e86ea897eab4ac115757e15e8625013d64c074bb26879eb2d41a937a33f8b19ea60e9f04d2c2aa5fe933b7068bec6ca16d9e99186f8ca781e8f528f23cbdaa37a8b02d2398c6899b094cad6b146dfe35a074bcafd321fa6c3f9b6bc5876df5832ec16b80d0e677b82289dce795ad7fb4d32e0b39d2148297e47fbfdb788246bc929dbd9d1227cf998c7cfc4e3465468a5234172987e62d201f514410c3abb89b59f669cd757a2520a31d56c39b27f8088675dbeefd6d452da7dd9c39bf14851c2469bcb9492d10def0797391fa5dafe342234f3fd72e221747912adcdfa178abc07c0f467fa40126313cf2f8c48ee6940d6ad3bbde9d3f009914785a4217513ce55645afd57dc9ab8cc57b872a631540989b61e5b0f48c7e7bbad5f184f12d810abea5812a2ba21fffc3ea2085aeed34d41ddd5506474062a52102dbfa775c3afa843f7429af7a9188853e9ec36734970402dc075bde1d8b3081800a7208ba6f858c396dd1bda0ab3f62fb1c13cd28c2f6612bc253bf541d85e59b150a76d63530bf9cffae4ac877fdda9def07a17f3066c9ca1e48089dcbeb47027ccff59a70b6edc197cdca195a9b0ff0e764d2563efb9830b1b1e91beed884106f0c95ac0d13b6f51a060ce048887126556ca45191b09ab15da16aaa0c43ded61510096de19bd64ee600eec1ba7f1aea9e2e657518c87170c1914b3ad620cd567caf235c3586277942de4aec501084993f6028cc9a47e5c3e6ca1cacc26921a61457ad416063297d67a6ac846c2b0466cb140c8d285b2b1166040aaf1d027a97e62827ee2fc19250e5d4ac3bf679f095c203084c5e2fad6e4df48f88533bb793390ffdafd6dcdb1e041332b25f61dd02662d73a3c2846a92c2f8c630c11dddb1e8077e8b468b32f07296822a4daa334761e6526874dfec9dcdb2ecafc437c81a7710033fec6bb647bb7251ddecc2009ff6f8e5dd56ce0cc2574d5ec2ec5c34dc93189358a46f827e2190823a48f76e9338f0306d3ebbf7b63dff0485914451031728029ffb2cc0a3859a44bac30997062a316f5b75e79c9855004e5eba8b289099ef458f438f55bf0572c2df71ee13f9848f6d59673c66d77996ed9d2fc36ffafb3869b3d56165ba29b27ee2abed400a397e3981afd3e52c6a987906c20bfd80819a8bc9f79af21b09de4f205e9131cadf47a64802a63e4e65e39b80cc87bd4ba51f6d770c8fe9aa93afc07e6d6371051159d8a7fd70c1fb7f63e956beeadb5e5396cd6973e7ab9585bfaa6b4940e3293607ad2970b8b4ad5c8e3359c09eeef4a49099d19bf952ff7635a909f28ae2c0bbe1139ec638ad72479bc63886eaecac5104e980b98ebf2e4bc9b3d421454e69147ee7c2adc20422a1c0b7a6ce629fb89175e9c4c2b44c6211bfa2fa6d35b989052b757cb82bfb30cb324aa05ac36f0b7d23eff10ee89c67c62a2a35cfb366472ee4458df4ed1265c82f68f25e4091512270f14d5c6ebfbd2b2a915778bc9011aa676803b2d33867acfed1d18562c9b919ba3c7859155267ea5cf45ea855a927ff59726128d0f1d9bf5725010b64891aacb45432c967fde0ba05cdb2b78eef452921a8ab2b80467390809a9db2e233d60f8959181bd46153dfa6b1fca56f2ad4fb532e71e388082ccfffb619c31dd568bbd4445242397163d87b00e55c0cde342ef05e5818a6215418f4e34522da2f7095bd12a25f1095262a209434138fd6b74d064093c5fb764e8df3a058d97c6fe4a11773cc956e823e850e245c375fb9bc18e0b4d850fc4846e7d054345e32b8ecdcba62aed7a58888c1493bb08f7f2f13f35829b60faa80492f54b913a47fe74b13fc15ed66c84fd39838d052ea728d68433664c4c9bfb1b4d10d5a3e7ffba26472f40355b1a86923d1b13db897625a8a602b2265d55b55addad7b53eaf4c3527d069487c0338bf21e45ac0499aac393ccaae6ac26b21fe5f622113e05c938f9373d5a5a97716fd107f096bfe9c32271cbd8076445ad9d21c352fff35c0e8af0a0b28513698b1462c7f54e2ba1035a41b8806ed1b3bcd5e1c91a8b46430191f65dfaa889b71eb9d68586ffa50614569ea47dfa0b5322252d4c7c22023677417d6b80da901c2b206c73b42a16939eb0bba1334e1fa1eaeeeb99cb6fb22fd75fdd81fcd8153cb7fc64bfaaf37277d447423e9edaa9c7f2ae373e27b556a875e0d32bef07d13cfa79492bdf0aa0c5f13ee8475e73e4fe466e86db0c8559ee22b7e668cfa6cb6bf100c806467acc539785159869262f559d7e22ca4ecb2907429791de4118bf296bdb69b3305d69b0e5895956c34092a9a7f8290a298c0700189cd86df878c94630888880ef34e7d89706593501da49c421f4dbce4412ff5d6bdb3a97496ffaaba0cb87a58fe6bd973e37b3fcdc5d11fe37b23070704a1ee0be28b934bf0e013b1fd07e0aec0c6408c16d150841a5dacc57cc4ce9bc20241ef56027e7785d03f3d01e89487d6427982e98899b2494f6ee87b457a437d3be2c0582f7b1d18672a1240084df64ab92425423c8de67a67f04cdd9bc5eb3347efb4245335d673735765953f857aed02e511cdcf704b16f5f1cb37d3b6ce20314197b466fc2be81a89a580624f91710499d448ed961c872aa93585502bbfbe75d9c786791191fb453c0baca30763e30015b5fb75a5e04392b16ba77a1c03c8e4dc4add9cf51b581f13dc910c7059a83b71eca72c627fde6b1be698c7dabe79ea74c3bdaa72bbe716e86d29055c9415e649bbaa508d8ec355887d57c8c017bf644bf28db34506345b36dfa87b66764d6f83f36182b01c0f05964284e2c83b5ffdb9134e4dfb305b5b5d85fc9263cc94a75a1882042f6b4ce56ea8f7a73565968f4b595554868a41cc26db1c319b099226a760962c004cca4e661b4cec2d9986ed63fc385901eb018b3e1d4dcd666a7e56d9dfe62a5a360a7ee27c8de7ee9b3243e0ba11dd92ddfce1278ef5771f53357096024edacc09c9999d78f6a5550e60bf03d06f5c500039e075e7d6373bf8ac40f14ea0fbb542185e8276348df2c8dca1240cee2bf2b211dd96ea4dda2d6da6b1d7f7ad49c191335c4d2467abb3a1a2c6646b85f259d48ccd82ebf8b31599f6b6db027f808d4bc9b3614488582e2fbf515f4998d9a8f3eae6b6e399d883c9de9f1d0ffa0620a7e8a1842468675f50b6a4878b818ba7565f44bb9888ca9b572b318258ea97946dc6aa8666f8c3254a7945878ef696a4afade79b48c5a17c3d00672af7932fa84ec74cf61a2731c1042d9253cc7ec43bfe7d3a26a9be931f515c35cae74d464563b259b701b65c014aef00261a681a8f39ad9264bb9d11d3577a2a81883a3e9fefe7834c0a4cf4f0a90ec0d6aacb727bb07bdc49f971fe303bd4bce2d6b81593afc672441e0b66d40893e177583a63dd695813969b2fb520c52a9469ee40007ed86b9d15b78004debff627a2f72903ecddf2e883f20b9d3b1d88155431729ab8c67bfd89d968a55ec8f5419ae6cdd28e8d0f000797c797d839e213739c06c49f788910e71de63b8f400827e0121c5b97ef3e4cf49919a0ae701d6d62ff24899da622240188966c07c7c213a5ec204610edc78b066810bd240542627ac5967f9e841295eb7e4907b5579137969114006e48719695c8e642df897055829ee3d0fba7f61973d756b9b69d01779f4644448eec5eb259fd8e6808eb1abfdc7b266f5e01e7feb0fc0b020abaa329fa708c182e28a3225675622c493b61b8f5b131f669ded7695c74f816aeae98a7a974393b619150e04445827e6d2e23740c1cda4560819cd885b09c405e9c6e746d5697b5ce3d0bd24c1a97c0ed1f2328c4f428b17ea6854ae9ae3bde2e0ae8cf7af744cbc51c54b5bc97c8911e70891858191cbbf5348265b2ce826b12a19f39ef0781c12df8949ef7134d4cc0936dcdc9d270e10d6bfb0f77b59ac709a59929e863e56758a1db81ce06da370d98cc62359f226b433fd2a3c9aed18435b1b762d65bd5278a19da4a70b65c71d92b2263f0a3cba7b6460fabb7b5d4e89afa8bbb806da6792256a6462528192a7dd88d2329a360281990737ef8a0f309ac31afcf772eae4750b94f3f29d7bf875b4d2de063feff3855a5eb537aa76c0f8151f214fcc18828c071e846728f5dfe2b81df8f0407a16dab73bffd21bb1be05134626ee22c3765d4d8073c941358b4ac417cff8d88f678dad677ee9c7334f00ffa8aa2210cef6d2cebb2ea026676dc6a451208e090a25172220d1b85d76af90ab7f2969cdeaec2cff958753b08b5b4cbcf4cbdc781ce221d51ff6f4e1e0fad57eef8614d6b3c3c86ee4f0ecc592feda3dac7d49ae18da3fb0df882e85bf007513d50dfc28a252ad2bd4d6611beafced993a739319e5976e03715b142eb364861cfb2614acf456e9e8516e6c6dc0ecaa06fa007d9655f5451595a3fca2b4f8444e1a5771af4ccd17430f678f92522675f8262dbebba4806bf0779cdf433384208c5931328f629f3ab754c4abfbe350107df1d74af8f4b1a187bfb2718d54718573fef1c1a5c1070744f4a168af9a2fced345d2cef24ed7dd9f85eca22d1f4b892e2006e7ad6e60f148abec9e7cd94e2211c187cfb2b3aadade2ef1852b7a2840b7d31957f85aa14db0b4c5583d84fc2bfeb8d7335ea8e058bdaf0d3e8d628925090e465fd37de56affec78cd9baf1e687a0b405a0527463426f6b8300ed19355badd6fe65c595985ee4ea942b5e7d46d194ef42a26b4bd781f742a6ec07c203811848a39367e94fb2c9ce9944bf2021c7537c49591cdfdc9a3aa378f8c3d7afe6e2476ec2a74dd183773a1d01694afaf9ca22addc12ccfd4211e45ffb9171a1d2532c0cfd4cdd0d3549a13b70309f04635cddf1e5cfbc44e4236e0697d63a81131075bbb67f151996051f25d110e784fb54bd4939428f2c9e9b2ee29b7c657f4c2de674845eedfa20843be9e76992b1691afe0add46efbe30a3bd8b204ef92012234282ad52baf66c280ec94626fb1019d61d5ebf7bd14fb42ff1731517038ab799b8dcae97d93717a6548d3641aec27aefa99c53c880b20582827a96a91ac93fcc707a65ebc10bc346a86dd3ba5767b1a9f2b0f28cbe7af9b937768a2c8d16e85ac558991e23e4f01c7e08302149e89724b8d818ba9a5f110c63e0df4588d5a24677a387ed569fe3c33c0b4bd91b0e52e8616d275e0097255c7f24bb3108bd6c724002477560634b479a16a8414d20f6b264d3b59ab2719955e9f4410dba30822d9e25e499c5107ef112c93ee2f41afe2a710bfafeca5efda4325c8ca95318bf7efa59cb2e0f2dfc1ffc77f9173e8d8fd881db030eeac1cb218682be64f4c268ca048eb434a35b5e28423a67fe0792ceb997eda8fd692164fe88e95cd11ce0dad9eb173a8af050567ec7f3b4f405c24267c29af0ee50c3fb02df1577be7164c7504ced7b8000ca9b3d147719ecf5151ed0f914c4a63713448bc3667a49f91199867853c9dd3257cecaa04bcb7f06cbaed71c664b76e7d96fa6619eea23b535a4794ca3ef392ab609f3e11f555d51142a64cc183ea62d7013de8317a51c718dcf071148e85f1b57932c3cf1325fd9e40aa4563d8ac8f51f86b2b140d500e049402b7bd97c90a065f26a1bbd534bc358966a0b8cced65508b8c408ee17d409fa40c242bf8dfc2fedbd10646c2ee622a6db3720c02b20b16f7ca5828cc11601e83165a18d0579c10c7de7b3a52a76eeef307f06421fb74c56251ac3a28f06a0ef36a2f38cecb3ad5cc6426965dd6b225fd98677b2d5d7618e07d611d8c647d3d7d16db576d03f3b2df421cc8316ad170195cc93061532f7d284ae1f7424d9bc4ee36536dde783e590d331d17cf9d151f1e7e538a5227ff3217876d9a429868395a0b4bdc544fb598428fc640d886fae8c02837e81f9d7e3720bcc63ca1b73a0980ec963ff0494805a989b071b21af4077a0e3b109a05d620f40019140e3f1467adb92acd67ced6f51223a5551b3f1675420efa2fa7cee1fc6c0b77e510e0022ea43ea99b26894ae24a298011294e3022478e9a7dc3018ae6e5010da63d9e138c3e68a53e905d1fa1719a89e47543ee291922d9ed7c07fc4de08cfe2c495c106c4a81502f6f56e523b335feb0f7f59f4a3f526b5d25dbd0e999d1b2d70e7c459f523cba76b11a4472138f8315ab02490696d9f4aade78f4a21bd1d483eb8161b91aabca21b465138eeeb923d86911daf95057b5e1753f2fd002de0d9528159fed6ede78ba143743892cc9f7cbbc820c40937d0b263c1d8ecd403585efe0dbd701f7e41a8090afeea1ef1fd9cd5496f5069eefacd38da958031ffe701429f2b852cd395aa0b9f21364960f1901d16c5cd43f4cc2e40d81ba91e38a71ce0a87c521c186d6c1c7cf7fd7f7a997b9cbc15350169f4103f796c33940da1a1db8136aec0ebc987684f93aac69c8ae66541e9d033cb2905c7530f6600f05f4e6e9bcd5ba6d4fd036b4a9fe981cd07f8025eff72bf6fa585d446ded25699dfab25a28c5b26d4dce3464fcd01187303e2c712cf1ba8a24422dd8615c0d1b2d2424bd0e85c8353bc9cbfd39de4a119ed3486bd19fb5c8d698c7b40bb83b44adb3492833503e42a08ec567c5aa166e5cc88353de274d74c65bfe16935ede76c63e4838f3dddd66f20d220dae1da52c7910ee156ff4073bf40ea166695f152e354eb5d7e2e10a9158ecdacc3c41e7dd7c20b8055e40d8b68a22a7bd3bf18888fb23f6f15a0cd425a062213f45823b3aaebb36051258a53c7d39415df65c09eac860b755411914e4a26b0681be28e8179d351e2ba72f31a5e222ca3952a2e66880c75cb9094bc4eaf2644b401727c95d297ef7e076eedd74c39d0b608cf08e05ab566b115532409e98bcd6dcc124c0481b342222ac1fe351ac7d40747b0887ff9f9f0c2fef21b2b77d4501acbebf944bf81c513c2750f26ac3b417ea8d2e8b42a25c8b315bf7c78b59e080425936b2b291b7d07765dc2b68e883991b382704e6b60eedfb829d4402f9fc21df9445b9789eab02386453ca3d2c9930e67feb5961d4431ab59db4195df5476dbd65b9c9b8ed526370d69fe251f1924e2eca77caac61d9a887f7c7b5235b33e4d2f4f0b3179b6698eb209dd441184e9eaa8a5b318b57a40e0e8a09e771f5e87b9e19c2617be178bf1fa85c2b9624f410dc1d4e88d74b62eb6a18b2cec49f7feb51d092af8c9c6643ebb6f89598840d56438abfe906398918d2131eefc4aab88d6bafd63a13ac24adaab708ab9157912398391b2893e13b052c48aeb4d6b5d43584c6716a1e2a2565ce5bc1751ac17208fcd1c6437ca9027fe3bef48d30c2b0c421753a48661e60b673d1e3af70009a1c0c007664c0106b28a85979ec068f0f997ffc1869f9f382aeb2c2778ab75202b13cfe93f7ac2922b2f5d78d2bec04dba1d49c46baabbc5f301c089b693beb2c33bf4278a5cf384ca0ada272b3bc845d49bf0411aa2f367a97aa34b5ffd7e5e8c429f351ec9ae016229ee86b35402d0a90a6c5208e976eeab9a754d39f20a2324dcfc648a169058346d3c03ec50722d11bff2ae1bc3dce2812c34cdc9d5959f3aa643bde9ef8ca6cbe92b35d943b4b51a15a6e7a49c63c78cce8b51f898956fb2d5c1723a5b2624d6c64c809f3083ba1162f6942c1e3b97252031c91e3758c77ce011603cbd03407a045d997a296943adc3b72817087383ae3a374274ab3bb62e90d266bdebc787ff5985dfc31b75c28465bec74e1ae94dc87d14e3cf04a2c45d11a9d8f337f89e496f4bd6e17245ad5ca7b98c8d5a7c8aeeb12600e9a8ca28caa7ccb15412a1da5e1eb56b27d233e4aff637b3506753b1c1d4933a381d205e8229b985af07ab998e72c7489e277a69e165d6f956c5b52667b0e1c66f1ee1d376d3d06a085dc798ab24c81e011224175575c3cdae69e9e73922f8bdd2b03f76eba50854dac6e9cd47288292a91e6232058f8e3973ae3bd3988101d47ec72962f7178ba0ffd5aef956d76b4149316473dd5ca0c6da195eac3e380f57ebfdbbebbf677735fcb03e39f6356ac75c598f38137326b7de2ef8c85296a26512df440741156368f74bb33c954bddcd2afdc2cfd70e41077ee78bdc99e69c989bca981748eebfc9e7ef2f5ab9e6356f0dca839927ff7bb9a84eb12f305d99f96042bf28cde10775a33705d3966eab80ad41f365501170bb1c7b2cb8ebbef8023b225fe2ef1fc943b8931773d22d5b94bc0b4afad8a5e56b9bc2571bdd25eec2e710f1b23966eac0c6e123259c774bf7ab71ce6d84f5d86f17f0c9b1527740287a818ca68b6298c0c4abe7cd440a154c3fb12fd31dedde1646401772fc656df38a8c20713a5ba042cca23b9c4ba3a0db6ef5a8d8a20b401bcb77bd327d0636a939ac0c731fe814f9b56c0b9dee8db0253e7492b2460e042f010d83e12082eda0ad449ca3fe5dca9d7bae9c9b782537ab0c776066de4ecd2acdc744adbb72f00436ffed04034bb2fd018cc449e01758847e327e854c9f150dbd8ea402d181ccef96c83753409807e9432054e55fb9f02c4febc851417</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="Password Needed">Password Needed</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 街灯晚河 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试汇总</title>
      <link href="/2023/04/03/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
      <url>/2023/04/03/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h2 id="Java-Base"><a href="#Java-Base" class="headerlink" title="Java Base"></a>Java Base</h2><h3 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，多用于实现多态</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名相同，参数的类型、个数、顺序不同，方法的返回值与访问修饰符可以不同</p><h4 id="重写（遵循两同两小一大）"><a href="#重写（遵循两同两小一大）" class="headerlink" title="重写（遵循两同两小一大）"></a>重写（遵循两同两小一大）</h4><ul><li><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p></li><li><p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p></li><li><p>构造方法无法被重写</p></li><li><p>如果方法的返回类型是<code>void</code>和基本数据类型，则返回值重写时不可修改；但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li></ul><h3 id="、equals-、hashCode"><a href="#、equals-、hashCode" class="headerlink" title="==、equals()、hashCode()"></a><code>==</code>、<code>equals()</code>、<code>hashCode()</code></h3><ul><li>对于基本数据类型，<code>==</code>比较的是变量的值</li><li>对于引用数据类型，<code>==</code>比较的是对象的内存地址</li></ul><p><code>equals()</code>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。</p><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。由于哈希碰撞的原因，不同的对象也有可能得到相同的<code>hashCode</code>值，如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p><h4 id="为什么重写equals-必须重写hashCode"><a href="#为什么重写equals-必须重写hashCode" class="headerlink" title="为什么重写equals()必须重写hashCode()"></a>为什么重写<code>equals()</code>必须重写<code>hashCode()</code></h4><p>如果只重写<code>equals()</code>而不重写<code>hashCode()</code>，那么<code>equals()</code>判断是相等的两个对象，<code>hashCode()</code>有可能不同；例如，HashSet进行去重添加时，会先通过<code>hashCode()</code>判断，那么没有重写的<code>hashCode()</code>就会返回<code>false</code>，即认为这两个对象是不同的，最终导致Set加入了重复元素。</p><h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a><code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>的区别</h3><ul><li>可变性<ul><li>String是不可变的，StringBuilder和StringBuffer可变</li></ul></li><li>线程安全性<ul><li>String和StringBuffer是线程安全的，StringBuilder是线程不安全的</li></ul></li><li>性能<ul><li>StringBuilder性能比StringBuffer略好</li></ul></li></ul><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li></ul><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet、LinkedHashSet、TreeSet的区别"><a href="#HashSet、LinkedHashSet、TreeSet的区别" class="headerlink" title="HashSet、LinkedHashSet、TreeSet的区别"></a>HashSet、LinkedHashSet、TreeSet的区别</h4><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p></li><li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h4><ul><li><p><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</p></li><li><p><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</p></li><li><p><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</p></li><li><p><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><ul><li><strong>线程安全性</strong>：HashMap是非线程安全的，HashTable是线程安全的（内部方法经过synchronized修饰）</li><li><strong>对Null key和Null value的支持</strong>：HashMap可以存储null的key和value，但null作为key只能有一个，作为value可有多个；HashTable不允许存在null key和null value</li><li><strong>底层数据结构</strong>：HashMap采用数组+链表&#x2F;数组+红黑树（链表长度超过阈值时，会转换为红黑树），HashTable采用数组+链表</li></ul><h4 id="HashMap和TreeMap的区别"><a href="#HashMap和TreeMap的区别" class="headerlink" title="HashMap和TreeMap的区别"></a>HashMap和TreeMap的区别</h4><ul><li><strong>底层数据结构</strong>：HashMap采用数组+链表&#x2F;数组+红黑树，TreeMap采用红黑树</li><li><strong>功能</strong>：TreeMap由于实现了NavigableMap接口和SortedMap接口，因此相较于HashMap增加了对集合内元素的搜索能力和对元素根据key排序的能力</li></ul><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><ul><li>NEW 初始状态，线程被创建出来但还没被调用start()</li><li>RUNNABLE 运行状态，线程被调用了start()，则变为READY可运行状态，等获得了CPU时间片后，处于RUNNING运行中状态</li><li>BLOCKED 阻塞状态，需要等待锁释放</li><li>WAITING 等待状态，需要其他线程做出一些特定动作（通知或者中断）</li><li>TIME_WAITING 超时等待状态，等待指定时间后返回而不是WAITING那样一直等待</li><li>TERMINATED 终止状态，线程执行完毕</li></ul><h4 id="死锁的产生和避免"><a href="#死锁的产生和避免" class="headerlink" title="死锁的产生和避免"></a>死锁的产生和避免</h4><ul><li><p>死锁产生的必要条件</p><ul><li>互斥：该资源任意一个时刻只能有一个线程占有</li><li>请求与保持：一个线程请求新资源的同时，不释放已占有的资源</li><li>不剥夺：占用中的资源只能由对应线程主动释放，无法被其他线程抢占</li><li>循环等待：若干线程形成一种环形的等待资源关系</li></ul></li><li><p>死锁的预防</p><ul><li>破坏请求与保持：一次性申请所有的资源</li><li>破坏不剥夺：线程在申请新资源时，释放自己占有的当前资源</li><li>破坏循环等待：按照某一顺序申请资源，释放资源则按照逆序</li></ul></li></ul><h4 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h4><p><strong>同</strong>：两者都可以暂停线程的执行</p><p><strong>异</strong>：</p><ul><li>sleep()没有释放锁，wait()释放了锁</li><li>wait()默认需要notify()或者notifyAll()来唤醒目标线程，sleep()执行完成后，目标线程会自动苏醒，或者也可以用wait(long timeout)，这样超时后线程也会自动苏醒</li><li>sleep()是Thread类的静态本地方法，wait()是Object类的本地方法</li></ul><h5 id="为什么wait-定义在Object类中，而sleep-定义在Thread类中"><a href="#为什么wait-定义在Object类中，而sleep-定义在Thread类中" class="headerlink" title="为什么wait()定义在Object类中，而sleep()定义在Thread类中"></a>为什么wait()定义在Object类中，而sleep()定义在Thread类中</h5><p>因为wait()是让获得对象锁的线程等待，自动释放当前线程占有的对象锁，所以操作的目标是Object而不是当前的Thread；</p><p>sleep()是让当前线程暂停执行，不涉及到Object，也不需要获得对象锁</p><h5 id="可以直接调用Thread类的run-方法吗"><a href="#可以直接调用Thread类的run-方法吗" class="headerlink" title="可以直接调用Thread类的run()方法吗"></a>可以直接调用Thread类的run()方法吗</h5><p>调用start()方法，会启动一个线程并使其进入Ready状态，当得到CPU时间片后即开始运行；因此真正的多线程工作方式是：start()执行线程的准备工作，然后自动执行run()方法；若直接调用run()，则当前方法会被当成一个main线程下的普通方法去执行，而不是在某个线程中执行</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><ul><li><p>volatile关键字可以保证变量的可见性，即该变量是共享且不稳定的，每次使用它都到主存中读取</p></li><li><p>volatile关键字可以防止JVM的指令重排序（通过插入特定的内存屏障来实现），例如单例模式的双重检验锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断对象是否已经实例过，没有实例过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>uniqueInstance = new Singleton()</code>这句代码是分成三步执行的：</p><ul><li>为<code>uniqueInstance</code>分配内存空间</li><li>初始化<code>uniqueInstance</code></li><li>将<code>uniqueInstance</code>指向分配的内存地址</li></ul><p>由于JVM有指令重排的特性，这三步的顺序可能发生调换，在多线程环境下可能会发生一个线程获得了尚未初始化的实例这类问题</p></li><li><p>volatile关键字无法保证原子性</p><ul><li>可用synchronized、AtomicInteger、ReentrantLock实现</li></ul></li></ul><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><h4 id="synchronized使用方式"><a href="#synchronized使用方式" class="headerlink" title="synchronized使用方式"></a>synchronized使用方式</h4><ul><li><p>修饰实例方法（锁当前对象实例）</p><p>进入同步代码前需要获得当前对象实例的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法（锁当前类）</p><p>因为静态方法是属于当前类而不是对象的，所以进入同步代码前需要获得当前类的锁。但静态synchronized方法和非静态synchronized方法可以互相调用，这是因为两者加锁的目标不同（一个是当前类，一个是当前对象实例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰代码块（锁指定的对象&#x2F;类）</p><p>对括号内的对象&#x2F;类加锁</p><ul><li><code>synchronized(object)</code>锁<code>object</code>对象</li><li><code>synchronized(类.class)</code>锁该类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指向同步代码块的起始位置，monitorexit指向同步代码块的结束位置；当执行monitorenter时，线程会试图获取对象监视器monitor的持有权；此时会去判断该锁的计数器是否为0，若为0，则获取锁成功，并将计数器+1；锁的拥有者可以通过monitorexit指令来释放锁，释放后将计数器-1</p><p>synchronized修饰方法时并没有monitorenter和monitorexit指令，而是通过ACC_SYNCHRONIZED标识；JVM借助该标识来辨别一个方法是否是同步方法</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是一个可重入且独占的锁，底层由AQS来实现</p><h3 id="各机制之间的对比"><a href="#各机制之间的对比" class="headerlink" title="各机制之间的对比"></a>各机制之间的对比</h3><h4 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h4><ul><li>volatile是线程同步的轻量级实现，所以性能相对于synchronized较好</li><li>volatile只能作用于变量之上，synchronized可修饰方法和代码块</li><li>volatile可以保证可见性，synchronized可以保证可见性和原子性</li></ul><h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><ul><li>两者都是可重入锁，即递归锁，指的是线程可以再次获取自己的内部锁，这样当出现线程递归申请锁的时候，不会产生死锁现象</li><li>synchronized依赖于JVM层面实现，ReentrantLock依赖于JDK层面实现</li><li>ReentrantLock实现了等待可中断，即正在等待的线程可以放弃等待，改为处理其他事情；synchronized等待不可中断</li><li>ReentrantLock可指定锁的公平性，synchronized只能是非公平锁；公平锁指的是先等待的线程先获得锁</li><li>ReentrantLock可绑定多个Condition，synchronized只能通过wait和notify绑定一个条件</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal类主要解决的就是让每个线程绑定自己的值</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>当有任务需要处理时，可从线程池中取出线程，处理完后线程不会销毁，而是等待下一个任务；池化思想的目的是为了减少每次获取资源的消耗，提高资源利用率</p><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><ul><li>通过<code>ThreadPoolExecutor</code>构造函数来创建</li><li>通过<code>Executor</code>框架的工具类<code>Executors</code>来创建</li></ul><h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul><li><code>corePoolSize</code>：任务队列未达到队列容量时，最大可以同时运行的线程数量</li><li><code>maximumPoolSize</code>：任务队列中存放的任务达到队列容量时，当前可同时运行的线程数变为最大线程数</li><li><code>workQueue</code>：新任务来的时候先判断当前运行的线程数是否达到核心线程数，若达到，则新任务会被放在队列中</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是<code>AbstractQueueSynchronizer</code>，即抽象队列同步器；这个抽象类主要用来构建锁和同步锁</p><p><strong>AQS的原理</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将该共享资源锁定；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。AQS用了<strong>CLH队列锁</strong>来实现该机制，即将暂时获取不到锁的线程加入到队列中</p><p>CLH队列是一个虚拟的双向队列；AQS将每条请求共享资源的线程封装成一个节点，每个节点保存了线程的引用、当前节点的状态、前驱和后继</p><p>节点的同步状态是用volatile修饰的，通过CAS等方法进行操作。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="悲观锁和应用场景"><a href="#悲观锁和应用场景" class="headerlink" title="悲观锁和应用场景"></a>悲观锁和应用场景</h4><p>共享资源每次只给一个线程使用，其他线程阻塞，用完后再将资源转让给其他线程，例如ReentrantLock和synchronized这种独占锁；悲观锁一般用于多写场景</p><h4 id="乐观锁和应用场景"><a href="#乐观锁和应用场景" class="headerlink" title="乐观锁和应用场景"></a>乐观锁和应用场景</h4><p>乐观锁只有在提交修改时才去验证对应的资源是否被其他线程修改；一般用于多读场景</p><h4 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h4><p>一般用版本号机制或CAS算法实现</p><ul><li><p>版本号机制</p><p>在数据表中加一个版本号字段，当数据被修改时，版本号加一。线程A更新数据时，读取数据的同时也读取版本号，提交更新时，若刚刚读到的版本号和数据库记录的版本号相等，则更新成功；否则重试直到成功</p></li><li><p>CAS算法</p><p>Compare And Swap 比较与交换。用一个预期值和要更新的变量值进行比较，两者相等才进行更新操作。</p><p>CAS是一个原子操作，涉及到三个操作数：</p><ul><li>V：要更新的变量值</li><li>E：预期值</li><li>N：拟写入的新值</li></ul><p>当且仅当V和E相等时，CAS通过原子方式用N来更新E；否则就说明有其他线程更新了V，当前线程放弃更新</p></li></ul><h4 id="乐观锁的问题"><a href="#乐观锁的问题" class="headerlink" title="乐观锁的问题"></a>乐观锁的问题</h4><ul><li><p><strong>ABA问题</strong>是乐观锁最常见的问题</p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过</p><p>解决方案：可以在变量前追加<strong>时间戳或者版本号</strong></p></li><li><p>循环时间长开销大</p><p>可通过pause指令降低资源消耗</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>主要由五个部分组成，可分为两个类别：</p><ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：堆、方法区</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</p></li><li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</p></li></ul><p>因此，程序计数器必须是每个线程独有的，无法共享</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址</p><ul><li>局部变量表：数据类型、对象引用之类</li><li>操作数栈：临时变量、中间计算结果等</li><li>动态链接：将符号引用转换为所要调用方法的直接引用</li><li>方法返回地址</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为执行本地方法（Java调用非Java代码的接口）而服务</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>存放对象实例以及数组</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>当JVM要使用一个类时，它需要读取并解析Class文件并获取相关信息，这些信息就会被存入方法区。方法区会存储<strong>已被JVM加载的类信息、字段信息、方法信息、常量等数据</strong>。</p><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1 类加载检查"></a>Step1 类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2 分配内存"></a>Step2 分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>，分配方式有两种：<strong>指针碰撞</strong>和<strong>空闲列表</strong>，<strong>选择哪种分配方式由 Java 堆是否规整（即有无内存碎片）决定，而 Java 堆是否规整又由所采用的GC收集算法决定</strong></p><ul><li>指针碰撞<ul><li>适用情况：堆内存规整，无内存碎片</li><li>操作：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小即可</li><li>使用该分配方式的GC收集器：Serial、ParNew</li></ul></li><li>空闲列表<ul><li>适用情况：堆内存不规整</li><li>操作：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录</li><li>使用该分配方式的GC收集器：CMS</li></ul></li></ul><p><strong>创建对象时的线程安全问题</strong></p><ul><li><strong>CAS+失败重试</strong>：CAS是乐观锁的一种实现方式，乐观锁指的是，不加锁而是假设不存在冲突去执行操作，如果因为冲突失败就进行重试，直到操作成功</li><li><strong>TLAB</strong>：为每一个线程预先在Eden区分配一块内存，JVM在给对象分配内存时，首先在TLAB分配，当对象大于TLAB剩余内存时，再采用CAS+失败重试方法</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3 初始化零值"></a>Step3 初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4 设置对象头"></a>Step4 设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息， <strong>这些信息存放在对象头中</strong></p><h4 id="Step5-执行init方法"><a href="#Step5-执行init方法" class="headerlink" title="Step5 执行init方法"></a>Step5 执行init方法</h4><p>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化</p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><strong>对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h4><ul><li>新生代：Eden区、Survivor S0区、Survivor S1区</li><li>老年代</li><li>元空间，使用的是直接内存</li></ul><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><ul><li>对象优先在Eden区分配，若Eden区空间不足，则发起Minor GC</li><li>大对象直接进入老年代，如字符串、数组等需要大量连续内存空间的对象，以此避免由于复制而降低效率</li><li>长期存活的对象将进入老年代，对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁</li></ul><h4 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h4><p>可达性分析算法：基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p><p>可作为GC Roots的对象：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li>标记-清除<ul><li>该算法分为标记和清除阶段：首先标记出存活的对象，在标记完成后统一回收掉所有未标记的对象。效率不高，且会产生大量内存碎片</li></ul></li><li>标记-复制<ul><li>将内存分为相同大小的两块，每次使用其中一块，当一块的内存用完后，把存活的对象复制到另一块内存，然后把当前内存块清理掉</li></ul></li><li>标记-整理<ul><li>先标记出存活的对象，然后将存活对象向一端移动，再清理掉端边界以外的内存</li></ul></li><li>分代收集<ul><li>将堆分为新生代和老年代，新生代采用标记-复制的GC算法，老年代采用标记-清除或标记-整理的GC算法</li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li>Serial<ul><li>单线程，必须暂停其他所有的工作线程；新生代标记-复制，老年代标记-整理</li></ul></li><li>ParNew<ul><li>多线程，新生代标记-复制，老年代标记-整理；唯一能与CMS配合工作</li></ul></li><li>Parallel Scavenge<ul><li>关注点在于吞吐量（CPU中运行用户代码的时间与CPU总耗时的比值）</li></ul></li><li>Serial Old<ul><li>Serial的老年代版本</li></ul></li><li>Parallel Old<ul><li>Parallel Scavenge的老年代版本</li></ul></li><li>CMS<ul><li>关注点在于用户线程的停顿时间</li><li>并发收集，GC收集线程可与用户线程几乎同时工作，标记-清除</li><li>具体运作过程分为四个阶段<ul><li>初始标记：暂停其他线程，记录与GC Roots相连的对象</li><li>并发标记：GC线程和用户线程同时开启，记录可达对象和发生引用更新的地方</li><li>重新标记：修正并发阶段由于用户线程运行而产生的标记变动，该阶段的暂停时段比初始阶段稍长，远小于并发阶段</li><li>并发清除：用户线程开启，GC线程同时开始清除未标记区域</li></ul></li><li>缺点：无法处理浮动垃圾，且由于使用标记-清除算法，会产生内存碎片</li></ul></li><li>G1<ul><li>标记-复制</li></ul></li><li>ZGC<ul><li>标记-复制</li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载过程：加载 -&gt; 连接 -&gt; 初始化</li><li>连接过程分为三步：验证 -&gt; 准备 -&gt; 解析</li></ul><p>类加载器的主要作用是加载Java类的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）</p><p>加载规则：JVM启动时，只会在类被用到的时候去加载，对于已经加载过的类会放到ClassLoader中；系统会首先判断该类是否加载过，已加载的类会直接返回。因此，对于一个类加载器来说，相同二进制名称的类只会被加载一次</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型如下图所示</p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 75%;" /><ul><li>BootstrapClassLoader启动类加载器：最顶层的加载器，无父类，主要用来加载JDK内部的核心类库和Xbootclasspath参数指定路径下的所有类</li><li>ExtensionClassLoader扩展类加载器：主要加载ext目录下的jar包和类以及java.ext.dirs系统变量所指定的路径下的所有类</li><li>AppClassLoader应用程序类加载器：面向用户的类加载器，负责加载当前应用classpath下的所有jar包和类</li></ul><h5 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h5><ul><li>在类加载时，系统会首先判断当前类是否已加载过，已加载过的类会直接返回，否则会尝试加载</li><li>类加载器首先不会自己去尝试加载这个类，而是先将这个请求委派给父类加载器（调用父类加载器的<code>loadClass()</code>方法）来完成；那么，所有的请求最终都会传给最顶层的BootstrapClassLoader</li><li>只有当父类加载器反馈无法完成当前的加载请求时，子加载器才会尝试自己去加载（调用<code>findClass()</code>方法）</li></ul><p><strong>JVM判定两个Java类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同，才认为两个类是相同的</p><h5 id="为什么要使用双亲委派"><a href="#为什么要使用双亲委派" class="headerlink" title="为什么要使用双亲委派"></a>为什么要使用双亲委派</h5><ul><li>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改</li><li>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类</li></ul><h5 id="如何打破双亲委派"><a href="#如何打破双亲委派" class="headerlink" title="如何打破双亲委派"></a>如何打破双亲委派</h5><p>重写<code>loadClass()</code>方法</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="使用TCP和UDP的协议分别有哪些"><a href="#使用TCP和UDP的协议分别有哪些" class="headerlink" title="使用TCP和UDP的协议分别有哪些"></a>使用TCP和UDP的协议分别有哪些</h4><ul><li>运行于TCP之上的协议<ul><li>HTTP&#x2F;HTTPS</li><li>FTP</li><li>SMTP</li><li>POP3&#x2F;IMAP</li><li>Telnet</li><li>SSH</li></ul></li><li>运行于UDP之上的协议<ul><li>DHCP</li><li>DNS</li></ul></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="输入URL到页面展示的过程"><a href="#输入URL到页面展示的过程" class="headerlink" title="输入URL到页面展示的过程"></a>输入URL到页面展示的过程</h4><ul><li>DNS解析（浏览器缓存 -&gt; 路由器缓存 -&gt; DNS缓存），获取域名对应IP</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>断开连接</li></ul><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul><li>1类：信息性状态码</li><li>2类：成功状态码</li><li>3类：重定向状态码</li><li>4类：客户端错误状态码</li><li>5类：服务端错误状态码</li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul><li>端口：HTTP默认是80，HTTPS默认是443</li><li>安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>常见排序算法可分为比较类和非比较类</p><ul><li>比较类排序算法<ul><li>冒泡排序：稳定、原地、最佳$O(n)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>快速排序：不稳定、原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(nlogn)$</li><li>插入排序：稳定、原地、最佳$O(n)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>希尔排序：稳定、原地、最佳$O(nlogn)$，最差$O(n^2)$，平均$O(nlogn)$、空间$O(1)$</li><li>选择排序：不稳定、原地、最佳$O(n^2)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>堆排序：不稳定、原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(1)$</li><li>归并排序：稳定、非原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(n)$</li></ul></li><li>非比较类排序算法<ul><li>基数排序：稳定、非原地、最佳$O(n\times k)$，最差$O(n\times k)$，平均$O(n\times k)$、空间$O(n+k)$</li><li>桶排序：稳定、非原地、最佳$O(n+k)$，最差$O(n^2)$，平均$O(n+k)$、空间$O(k)$</li><li>计数排序：稳定、非原地、最佳$O(n+k)$，最差$O(n+k)$，平均$O(n+k)$、空间$O(k)$</li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="事务的酸性ACID"><a href="#事务的酸性ACID" class="headerlink" title="事务的酸性ACID"></a>事务的酸性ACID</h4><ul><li>原子性：事务是最小的执行单位</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：一个用户的事务不被其他事务干扰</li><li>持久性：事务提交后，其对数据库的改变是持久的</li></ul><h4 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h4><ul><li>丢失修改：在一个事务读取一个数据时，另一个事务也访问了该数据，在第一个事务修改这个数据后，第二个事务也修改了这个数据，导致第一个事务所做的修改结果丢失</li><li>脏读：一个事务修改了一个数据，在其尚未提交之前，另一个事务读取了修改后的数据，此时第一个事务突然回滚，导致第二个事务读取了脏数据</li><li>不可重复读：在一个事务内多次读数据，但数据被另一个事务所修改，导致两次读取的数据不一致</li><li>幻读：发生在一个事务读取了几行数据，接着另一个事务插入了一些数据时。然后，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li></ul><h4 id="并发事务的控制方式"><a href="#并发事务的控制方式" class="headerlink" title="并发事务的控制方式"></a>并发事务的控制方式</h4><p>锁（悲观控制）和MVCC（乐观控制）</p><ul><li>锁可分为读写锁（可以读读并行，无法读写&#x2F;写写并行）<ul><li>共享锁（S锁）：读锁，事务在读取记录时获取共享锁，允许多个事务同时获取</li><li>排他锁（X锁）：写锁，事务在修改记录时获得排他锁，不允许多个事务同时获得；若一个记录已经被加了排他锁，其他事务不能再对该记录加任何锁</li><li>根据粒度可分为表级锁和行级锁<ul><li>表级锁是针对非索引字段的锁，加锁快，不会出现死锁，但触发锁冲突概率高，高并发场景效率较低</li><li>行级锁是针对索引字段的锁，开销大加锁慢，会出现死锁，但并发度高</li></ul></li></ul></li><li>MVCC对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本，实现手段主要是隐藏字段、read view和undo log<ul><li>undo log用来记录某行数据的多个版本的数据</li><li>read view和隐藏字段用来判断当前版本数据的可见性</li></ul></li></ul><h4 id="四个隔离级别"><a href="#四个隔离级别" class="headerlink" title="四个隔离级别"></a>四个隔离级别</h4><p>从低到高分别为：</p><ul><li>读取未提交 Read Uncommitted（脏读、不可重复读、幻读）</li><li>读取已提交 Read Committed（不可重复读、幻读）</li><li>可重复读 Repeatable Read（幻读）</li><li>可串行化 Serializable</li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><ul><li>MyISAM只支持表级别的锁粒度，而InnoDB可支持行级别的锁粒度</li><li>MyISAM不支持事务，InnoDB支持事务，实现了SQL的四个隔离级别</li><li>MyISAM不支持外键，InnoDB支持</li><li>MyISAM不支持MVCC，InnoDB支持</li><li>虽然两者均用B+树作为索引结构，但实现方式不同；InnoDB中，其数据文件本身就是索引文件。而MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录</li><li>MyISAM不支持数据库异常崩溃后的安全恢复，InnoDB支持</li><li>InnoDB性能更好</li></ul><h4 id="MySQL的隔离级别是如何实现的，默认隔离级别是什么"><a href="#MySQL的隔离级别是如何实现的，默认隔离级别是什么" class="headerlink" title="MySQL的隔离级别是如何实现的，默认隔离级别是什么"></a>MySQL的隔离级别是如何实现的，默认隔离级别是什么</h4><p>可串行化是通过锁来实现的，RR和RC是通过MVCC来实现的；默认隔离级别是RR</p><h4 id="InnoDB有哪几类行锁"><a href="#InnoDB有哪几类行锁" class="headerlink" title="InnoDB有哪几类行锁"></a>InnoDB有哪几类行锁</h4><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围</strong></p><h4 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h4><p>意向锁是一种表级锁，可以用来快速判断是否可对某个表使用表锁。意向锁之间是互相兼容的 </p><ul><li>意向共享锁：事务有意向表中的某些记录加共享锁，则必须先获得该表的IS锁</li><li>意向排他锁：事务有意向表中的某些记录加排他锁，则必须先获得该表的IX锁</li></ul><h4 id="快照读（一致性非锁定读）和当前读（一致性锁定读）的区别"><a href="#快照读（一致性非锁定读）和当前读（一致性锁定读）的区别" class="headerlink" title="快照读（一致性非锁定读）和当前读（一致性锁定读）的区别"></a>快照读（一致性非锁定读）和当前读（一致性锁定读）的区别</h4><p><strong>快照读</strong>的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景</p><p><strong>当前读</strong> 就是给行记录加 X 锁或 S 锁</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h5><p><strong>Hash表</strong></p><p>Hash表的优势在于O(1)的取值，但存在哈希冲突的问题，一般用拉链法解决（相同哈希结果的数据连在同一个链表中，后用红黑树代替链表）；作为索引不具备范围查找的功能，每次IO只能取一个值</p><p><strong>B树 &amp; B+树</strong></p><ul><li><p>B 树的所有节点既存放key也存放data，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</p></li></ul><h5 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h5><p>聚簇索引是索引结构和数据一起存放的索引，例如InnoDB的主键索引</p><ul><li>优点<ul><li>查询速度快：由于B+树本身就是平衡的，且叶子节点也都是有序的，定位到索引的同时，也就定位到了数据，相比于非聚簇，少了一次读取数据的IO操作</li><li>利于排序查找和范围查找</li></ul></li><li>缺点<ul><li>依赖于数据的有序性</li><li>更新代价大</li></ul></li></ul><p>非聚簇索引是索引结构和数据分开存放的索引，MyISAM使用的就是非聚簇索引；非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</p><ul><li>优点<ul><li>更新代价比聚簇小，因为叶子节点不存放数据</li></ul></li><li>缺点<ul><li>依赖于数据的有序性</li><li>可能需要回表：即根据查到的主键，再进行查询</li></ul></li></ul><h5 id="覆盖索引与联合索引"><a href="#覆盖索引与联合索引" class="headerlink" title="覆盖索引与联合索引"></a>覆盖索引与联合索引</h5><p>覆盖索引：一个索引包含所有需要查询的字段的值，则为覆盖索引；这种情况是不需要回表查询的</p><p>联合索引：使用表中的多个字段创建索引</p><h5 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h5><p>在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **<code>&gt;</code><strong>、</strong><code>&lt;</code>**）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><h5 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h5><h6 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h6><p>一种物理日志，InnoDB独有的功能，使MySQL具备了崩溃恢复的能力</p><p>MySQL中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里（刷盘时机由策略决定）</p><h6 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h6><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的；采用的是环形数组形式，从头开始写，写到末尾又回到头循环写</p><h5 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h5><p>binlog是逻辑日志，属于MySQL Server层，保证数据库的数据同步和一致性，记录所有涉及更新数据的逻辑操作，并且是顺序写</p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>在执行更新语句时，由于redo log可以在事务过程中写入，而binlog只能在提交事务时写入，因此可能会产生问题：</p><p>假设在redo log写完，binlog写入期间发生了异常，那么当MySQL重启后，redo log恢复出来的是修改后的新数据，而binlog由于没有记录到这次更新操作，因此会导致数据不一致的问题；为了解决这一问题，InnoDB采用了两阶段提交的方案</p><p>将redo log的写入拆分为两个步骤：<strong>prepare</strong>和<strong>commit</strong>，其中prepare阶段在事务执行过程中写入，commit阶段放在binlog写入之后完成，这样即使在binlog写入过程中发生异常，MySQL重启后只需检查redo log是否还处于prepare阶段，若redo log还处于prepare阶段，则将该事务回滚，以此保持数据的一致性</p><h5 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log 回滚日志"></a>undo log 回滚日志</h5><p>在 MySQL 中，恢复机制是通过undo log实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用undo log中的信息将数据回滚到修改之前的样子即可；并且，undo log会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询undo log来回滚之前未完成的事务</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><p>Redis中的key均为String类型，value包含五种基础数据类型，分别是：<strong>String、List、Set、Hash、Zset</strong></p><p><strong>String value</strong></p><p>String可以包含任何数据，例如数字、字符串、图片或者序列化对象等。</p><p><strong>应用场景：</strong>利用String value来做常用数据的缓存，redis做缓存层，mysql做持久化层，这样可以降低mysql的读写压力。</p><p><strong>List value</strong></p><p>Redis中的List是一种链表（以双端链表的形式来实现），其可以在队头队尾同时进行数据的压入弹出操作。</p><p><strong>应用场景</strong>：消息队列，例如微博的TimeLine</p><p><strong>Set value</strong></p><p>Redis中的Set是一种保存String的无序集合，其中的String变量无重复值。通过哈希表来实现，增删查的效率均为O(1)。</p><p><strong>应用场景：</strong>网站的点赞信息、网页元素的标签等。</p><p><strong>Hash value</strong></p><p>Redis中的Hash是一种k-v映射结构，其适用于存储对象。</p><p><strong>应用场景：</strong>是比String更加直观的一种存储方式。</p><p><strong>Zset value</strong></p><p>Redis中的Zset是一种有序集合，其和set一样不允许存在重复成员，不同的是Zset中每个成员会拥有一个分数，所有成员按照该分数来进行排序，不同成员的分数可以重复。</p><p>有序集合是通过两种数据结构实现：</p><ol><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的<strong>双向链表</strong>。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关；一般在：<strong>元素数量少于128和每个元素的长度小于64字节</strong>的时候才会采用压缩列表来实现Zset。</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li></ol><p><strong>应用场景：</strong>网站数据的排行榜等。</p><h5 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h5><p>Redis除了上述五种基础数据类型外，还包括三种特殊数据类型，分别是<strong>HyperLogLog基数统计、Bitmap位图、Geospatial地理位置</strong>。</p><p><strong>HyperLogLog基数统计</strong></p><p>这个结构可以非常省内存的去统计各种基数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。但这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值</p><p><strong>Bitmap位图</strong></p><p>操作二进制位来进行相关数据的记录，仅有0和1两个状态。比如：统计用户信息中的活跃与不活跃，登录与未登录，打卡与不打卡</p><p><strong>Geospatial地理位置</strong></p><p>可以推算地理位置的信息: 两地之间的距离, 方圆几里的人，获取成员的经纬度等。底层实现原理是Zset。</p><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Redis 5.0中增加了一个数据类型Stream，其借鉴了Kafka的设计，是一个支持多播的可持久化消息队列（Message Queue，MQ）</p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h5 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h5><p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。触发快照持久化有手动和自动两种方式。</p><p><strong>实际应用问题</strong></p><ul><li><p>一般Redis占据的内存较大，做快照的时间也可能较长，在快照时间内Redis很可能收到写数据的请求，那么在这种情况下如何保证Redis中的数据一致性？</p><p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p></li><li><p>在快照过程中，如果发生了服务的崩溃如何处理？</p><p>如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。</p></li><li><p>做快照的时间间隔越短越好？</p><p><strong>如果频繁地执行全量快照，会带来两方面的开销</strong>：</p><ul><li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁<strong>阻塞主线程</strong>了。</li></ul><p>因此可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。但这种方法需要使用另外的空间去记录哪些数据被修改了，所以一般采用RDB和AOF混合的持久化方式。</p></li></ul><h5 id="AOF写后日志"><a href="#AOF写后日志" class="headerlink" title="AOF写后日志"></a>AOF写后日志</h5><p><strong>实际应用问题</strong></p><ul><li><p>如何解决AOF日志不断增大的膨胀问题？</p><p>Redis会创建一个新的AOF文件，新旧AOF文件保存的数据没有区别，但新的AOF日志相较旧的AOF日志去除了冗余的中间命令。</p></li><li><p>AOF日志在重写的过程中会阻塞吗？</p><p>AOF日志的重写是通过fork创造的后台线程来进行的，因此阻塞只会在fork后台线程时发生。</p></li><li><p>重写AOF日志时，如果发生写操作如何应对？</p><p>在发生写操作时，Redis会将相应的命令存入AOF缓冲区，当负责重写的后台线程完成既定工作时，其会通知主线程，此时主线程则会将缓冲区内保存的写命令追加到重写日志中。</p></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>为了避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。Redis提供了主从复制的机制来实现数据的高可用性。</p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>主从库之间采用的是<strong>读写分离</strong>的方式。</p><ul><li><p>读操作：主库、从库都可以接收；</p></li><li><p>写操作：首先到主库执行，然后，主库将写操作同步给从库。</p></li></ul><h4 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h4><p>哨兵实现了如下所述的四个主要功能：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h5 id="哨兵集群的组建"><a href="#哨兵集群的组建" class="headerlink" title="哨兵集群的组建"></a>哨兵集群的组建</h5><p>哨兵通过在主库的频道上发布自己的IP和端口信息，其他哨兵通过订阅该频道从而获悉该哨兵的IP和端口，并建立网络连接。</p><h5 id="哨兵监控Redis库"><a href="#哨兵监控Redis库" class="headerlink" title="哨兵监控Redis库"></a>哨兵监控Redis库</h5><p>哨兵向主库发送INFO命令，主库则会将从库列表返回给该哨兵，那么该哨兵就可以和每个从库建立连接并进行监控。</p><h5 id="哨兵判断主库下线"><a href="#哨兵判断主库下线" class="headerlink" title="哨兵判断主库下线"></a>哨兵判断主库下线</h5><p>首先，哨兵可对主库做出“主观下线”的判断，并向其他哨兵发送信号；其他哨兵也会相应做出“主观下线”的判断，若所有的“主观下线”判断中“是”的数量不少于配置中的指标量，则可以认为主库已经达到“客观下线”。</p><h5 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h5><p>当主库“客观下线”后，需要有一个领头的哨兵节点来执行后续主从切换的动作。选举条件为：1. 拿到半数以上的赞成票；2. 得票数同时还需要不少于配置文件中的指标量（即主库达到“客观下线”的那个指标量）。</p><h5 id="新主库的选出"><a href="#新主库的选出" class="headerlink" title="新主库的选出"></a>新主库的选出</h5><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><h5 id="故障的转移"><a href="#故障的转移" class="headerlink" title="故障的转移"></a>故障的转移</h5><p>新主库选出后，最后哨兵leader要进行故障的转移，具体步骤如下：</p><ul><li><p>将某个slave节点脱离原从节点，升级成主节点；</p></li><li><p>将其他从节点指向新的主节点</p></li><li><p>通知客户端主节点已更换</p></li><li><p>将原主节点变成从节点，指向新的主节点</p></li></ul><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><ul><li>缓存穿透<ul><li><strong>问题来源</strong>：缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</li><li>解决方案<ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>布隆过滤器。bloomfilter就类似于一个HashSet，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小</li></ul></li></ul></li><li>缓存击穿<ul><li><strong>问题来源</strong>：缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</li><li><strong>解决方案</strong><ul><li>设置热点数据永远不过期。</li><li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li><li>加互斥锁</li></ul></li></ul></li><li>缓存雪崩<ul><li><strong>问题来源</strong>：缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机</strong>。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li><li><strong>解决方案</strong><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul></li></ul></li><li>缓存污染<ul><li><strong>问题来源</strong>：缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</li><li><strong>解决方案</strong><ul><li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li></ul></li></ul></li></ul><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>Consistency一致性：所有节点访问同一份最新的数据副本</li><li>Availability可用性：非故障的节点在合理的时间内返回合理的响应</li><li>Partition Tolerance分区容错性：分布式系统出现网络分区时，仍能够对外提供服务</li></ul><p>如果分布式系统发生了“分区”（某些节点由于故障不连通了，网络被分成了几块区域），则理论上只能支持CP或者AP架构，即P一定是要满足的。Nacos不仅支持AP也支持CP</p><h3 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h3><p>当分库之后，数据分布在不同服务器的DB上，DB的自增主键已经无法满足要求，因此需要生成分布式ID。</p><h4 id="分布式ID解决方案"><a href="#分布式ID解决方案" class="headerlink" title="分布式ID解决方案"></a>分布式ID解决方案</h4><ul><li>数据库<ul><li>关系型数据库自增主键</li><li>号段模式相比于自增主键，对于数据库的访问次数更少，DB压力更小</li><li>非关系型数据库使用Redis</li></ul></li><li>算法<ul><li>UUID（32个16进制）</li><li>雪花算法（64bit二进制数字）<ul><li>第0位符号位，1-41位时间戳，42-52位机房ID+机器ID，53-64位序列号</li></ul></li></ul></li><li>开源框架</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h4><ul><li>加锁<ul><li>用SETNX命令判断对应的锁是否存在，若不存在则加锁失败</li></ul></li><li>解锁<ul><li>为了保证释放锁的原子性，Redis会通过Lua脚本首先判断误删其他锁，没有问题则执行DEL命令释放锁</li></ul></li></ul><p>但存在这样的问题：<strong>释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问</strong></p><p>因此需要对锁设置一个过期时间，但又存在资源操作时间超过了过期时间导致服务中断的情况</p><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><p>Redisson提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>一台主数据库负责写，其他的从数据库负责读；主库和从库之间会进行数据同步，以保证从库中数据的准确性</p><h4 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h4><p>写完主库后，主库的新数据同步到从库需要一定时间，这段时间内会产生主从数据库的数据不一致问题</p><ul><li>强制将读请求路由到主库</li><li>延迟读取</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>代理方式<ul><li>在应用和数据中间加一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中</li></ul></li><li>组件方式<ul><li>引入第三方组件来帮助处理读写请求（sharding-jdbc）</li></ul></li></ul><h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><p>根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中，具体步骤如下</p><ul><li><p>主库将数据库中数据的变化写入到 binlog</p></li><li><p>从库连接主库</p></li><li><p>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</p></li><li><p>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</p></li><li><p>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中</p></li><li><p>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）</p></li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>为了解决MySQL的存储压力，可以使用分库分表的方案</p><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库；<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分</p><h4 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h4><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题</p><ul><li>哈希分片，求指定key的哈希值，根据哈希值确定分配的表，适合随机读写场景，不适合大量范围查询场景</li><li>范围分片，分成连续的若干段数据</li><li>融合分片</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列的应用场景：通过异步处理提高系统性能、削峰限流、降低耦合度</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><strong>如何保证消息不丢失</strong></p><ul><li>生产者丢失消息<ul><li>当send后通过回调函数的形式返回发送消息成功与否，同时设置合理的retry间隔时间</li></ul></li><li>消费者丢失消息<ul><li>真正消费完当前消息后手动提交offset的更新，但如果提交offset之前自己挂了，则会产生重复消费的问题</li></ul></li></ul><p><strong>如何保证消息不被重复消费</strong></p><ul><li>消费后做幂等校验</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
