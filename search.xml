<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Discord Bot JavaScript</title>
      <link href="/2023/06/16/Discord%20Bot%20JavaScript/"/>
      <url>/2023/06/16/Discord%20Bot%20JavaScript/</url>
      
        <content type="html"><![CDATA[<h1 id="Discord-Bot-JavaScript"><a href="#Discord-Bot-JavaScript" class="headerlink" title="Discord Bot JavaScript"></a>Discord Bot JavaScript</h1><p>用JavaScript实现一个Discord Bot，实现生成艺术二维码的功能。</p><blockquote><p>参考文档：<a href="https://discordjs.guide/">Discord的JavaScript开发文档</a></p><p>代码仓库：<a href="https://github.com/Mitsui921/DiscordBot">https://github.com/Mitsui921/DiscordBot</a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>开启Discord群组的开发者模式</p></li><li><p>前往<a href="https://discord.com/developers/applications">Discord开发者网站</a>新建一个应用</p></li><li><p>配置好Bot的权限列表，留存Bot的token-key，注意打开这些权限</p><img src="https://i.ibb.co/8j9Xdty/iq-Edplg-PAh-ZLj78.png" alt="Bot权限" style="zoom:50%;" /></li><li><p>生成OAuth2的URL，选中相应的URL生成域，生成URL并打开即可将Bot加入到群组中</p><img src="https://i.ibb.co/f9nTr6n/9l-EAv4-Uy-Xk-Bzpw-M.png" alt="URL生成域" style="zoom: 67%;" /></li></ul><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>通过JS对Bot的功能进行开发，可采用在线开发和本地开发两种模式。为了图方便，就用了在线IDE：<a href="https://replit.com/">Replit</a>开发的方式。</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>BotCommand<br>├── commands<br>│   └── generate.js<br>├── index.js<br>├── deploy-commands.js<br>├── config.json<br>├── package.json<br>└── package-lock.json</p><p><code>index.js</code>为入口，终端运行<code>node index.js</code>启动项目</p><h3 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h3><p>在根目录下新建一个<code>config.json</code>文件，分别填入对应的三个字符串，完成与机器人端的连接</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_BOT_TOKEN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;clientId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_APPLICATION_ID&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;guildId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_SERVER_ID&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="SlashCommands部署"><a href="#SlashCommands部署" class="headerlink" title="SlashCommands部署"></a>SlashCommands部署</h3><p>为了实现在聊天框打出<code>/</code>即可唤醒命令的功能，需要先定义这些命令。</p><p>在根目录下新建一个<code>commands</code>文件夹，保存所有的命令（后期随着命令的增加，也可以再增设分类的子文件夹）；</p><p>在<code>commands</code>文件夹下，新建一个<code>generate.js</code>，在里面实现“generate”斜杠命令的逻辑。</p><p>从官方开发文档获取<code>deploy-commands.js</code>，执行<code>node deploy-commands.js</code>即可将定义的命令部署到机器人端。</p><h3 id="命令逻辑实现"><a href="#命令逻辑实现" class="headerlink" title="命令逻辑实现"></a>命令逻辑实现</h3><p>命令的逻辑实现主要是在<code>index.js</code>以及<code>generate.js</code>两个文件中编写。</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li><strong>Step 1</strong>: 群组用户能够发起<code>generate</code>命令，该命令需包含三个参数：<code>prompt</code>、<code>url</code>、<code>weight</code>，分别表示Stable Diffusion算法模型的关键字、原始的二维码链接、权重</li><li><strong>Step 2</strong>: Bot接收该命令后，在执行过程中显示“响应中”状态</li><li><strong>Step 3</strong>: SD算法生成图片完成后，Bot需在群组中回复以下内容：<ul><li>@发起该命令的用户</li><li>生成的艺术二维码图片</li><li>产品文本信息与提示</li><li>“重新生成”按钮</li></ul></li><li><strong>Step 4</strong>: “重新生成”按钮需完成如下功能：<ul><li>群组内任意用户均可点击</li><li>点击按钮后弹出一个窗口，该窗口有三个填写栏，分别对应上述的三个参数，初始显示为上一次生成图像的三个参数值</li><li>用户可更改这些参数，并提交给Bot</li><li>Bot接收后重复Step3的功能</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discord </tag>
            
            <tag> Tools </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记</title>
      <link href="/2023/06/12/Docker/"/>
      <url>/2023/06/12/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>开篇文章记录一下学习Docker的过程和实际使用中碰到的坑。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Docker作为容器技术的一种具体应用，和平时常用的虚拟机技术存在一些区别。</p><h3 id="容器vs虚拟机"><a href="#容器vs虚拟机" class="headerlink" title="容器vs虚拟机"></a>容器vs虚拟机</h3><p>容器和虚拟机都是常用的资源虚拟化技术。在虚拟化的过程中，RAM、CPU、磁盘或者网络等系统单一资源可以虚拟化成多个资源。容器和虚拟机之间的主要区别在于，虚拟机将整个计算机虚拟化到硬件层面，而容器只虚拟化到操作系统级别以上的软件层面。因此，容器技术的迭代速度更快、生态系统比较完善，但可能存在共享主机漏洞；虚拟机技术则能实现完全隔离安全，但在迭代速度和存储成本上代价更大。</p><img src="https://i.ibb.co/vXmcV2p/U3x-VMksbn2-AQj-TW.png" alt="容器vs虚拟机" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 运维 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity笔记</title>
      <link href="/2023/06/08/Solidity/"/>
      <url>/2023/06/08/Solidity/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h1><p>开篇文章记录实习期间学习Solidity编程的相关内容。</p><blockquote><p>参考页面：</p><p><a href="https://learnblockchain.cn/docs/solidity/index.html">Solidity中文文档</a>（v0.8.17）</p><p><a href="https://docs.soliditylang.org/en/v0.8.20/">Solidity官方文档</a>（v0.8.20）</p></blockquote><hr><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在学习Solidity语言之前，需要了解一些前置知识，包括：</p><ul><li>区块链基础</li><li>以太坊虚拟机</li></ul><p>另外，若想要深入理解智能合约以及虚拟机是如何运行的，可以参考这两篇文章：<a href="https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/">完全理解以太坊智能合约</a>和<a href="https://learnblockchain.cn/2019/04/09/easy-evm/">深入浅出以太坊虚拟机</a>。</p><h3 id="智能合约示例"><a href="#智能合约示例" class="headerlink" title="智能合约示例"></a>智能合约示例</h3><h4 id="存储合约示例"><a href="#存储合约示例" class="headerlink" title="存储合约示例"></a>存储合约示例</h4><p>将一个数据保存到链上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="货币合约示例"><a href="#货币合约示例" class="headerlink" title="货币合约示例"></a>货币合约示例</h4><p>一个最简单的加密货币</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    // 关键字“public”让这些变量可以从外部读取</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    // 轻客户端可以通过事件针对变化作出高效的反应</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    // 这是构造函数，只有当合约创建时运行</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address receiver, uint amount) public &#123;</span><br><span class="line">        require(msg.sender == minter);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Errors allow you to provide information about</span><br><span class="line">    // why an operation failed. They are returned</span><br><span class="line">    // to the caller of the function.</span><br><span class="line">    error InsufficientBalance(uint requested, uint available);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function send(address receiver, uint amount) public &#123;</span><br><span class="line">        if (amount &gt; balances[msg.sender])</span><br><span class="line">            revert InsufficientBalance(&#123;</span><br><span class="line">                requested: amount,</span><br><span class="line">                available: balances[msg.sender]</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码可以等学习完语法回头再看。</p><hr><h2 id="Solidity详解"><a href="#Solidity详解" class="headerlink" title="Solidity详解"></a>Solidity详解</h2><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>相当于OOP语言中的类，具有可继承性，可以包含状态变量、函数、事件、错误、结构体等声明</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永久存储在合约存储中的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract TinyStorage &#123;</span><br><span class="line">uint storedXlbData; // 状态变量</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是代码的可执行单元，可以在合约内部或者外部定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.1 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">// Mybid function defined inside of a contract</span><br><span class="line">    function Mybid() public payable &#123; </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Helper function defined outside of a contract</span><br><span class="line">function helper(uint x) pure returns (uint) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Topia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 区块链 </tag>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊研究</title>
      <link href="/2023/06/07/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
      <url>/2023/06/07/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="以太坊研究"><a href="#以太坊研究" class="headerlink" title="以太坊研究"></a>以太坊研究</h1><p>开篇文章记录实习期间对以太坊相关技术的研究与学习进展。</p><p>整个技术概念和背景比较多，因此在记录的时候以工作&#x2F;研究的来源作为分类依据，可能在部分内容上有所重复。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上的去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。以太坊是区块链，区块链不是以太坊。</p><hr><h2 id="区块链基础"><a href="#区块链基础" class="headerlink" title="区块链基础"></a>区块链基础</h2><blockquote><p>参考页面：</p><p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/index.html">FISCO BCOS 技术文档</a></p></blockquote><h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p>区块链作为一个分布式系统，可以由不同的节点共同参与计算、共同见证交易的执行过程，并确认最终计算结果。协同这些松散耦合、互不信任的参与者达成信任关系，并保障一致性，持续性协作的过程，可以抽象为“共识”过程，所牵涉的算法和策略统称为共识机制。</p><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>节点的标识采用公私钥机制，生成一串唯一的NodeID，以保证它在网络上的唯一性。</p><p>根据对计算的参与程度和数据的存量，节点可分为共识节点和观察节点。共识节点会参与到整个共识过程，作为记账者打包区块、作为验证者验证区块以完成共识过程。观察节点不参与共识，同步数据，进行验证并保存，但可以作为数据服务者提供服务。</p><h4 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h4><p>共识算法需要解决几个核心问题：</p><ol><li>选出在整个系统中具有记账权的角色，做为leader发起一次记账。</li><li>参与者采用不可否认和不能篡改的算法，进行多层面验证后，采纳leader给出的记账。</li><li>通过数据同步和分布式一致性协作，保证所有参与者最终收到的结果都是一致且无错的。</li></ol><p>区块链领域常见的共识算法有公链常用的工作量证明（Proof of Work）、权益证明（Proof of Stake）、委托权益证明（Delegated Proof of Stake），以及联盟链常用的实用性拜占庭容错共识PBFT（Practical Byzantine Fault Tolerance），Raft等</p><hr><h2 id="以太坊白皮书"><a href="#以太坊白皮书" class="headerlink" title="以太坊白皮书"></a>以太坊白皮书</h2><blockquote><p>参考页面：</p><p><a href="https://ethereum.org/zh/whitepaper/">官方白皮书</a></p></blockquote><h3 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h3><p>以太坊通过“账户”来组成系统的状态，每个账户有一个20字节的地址，状态转换是指账户之间价值和信息的直接转移。一个以太坊账户包含四个字段：</p><ul><li>nonce，用于确保每笔交易只能处理一次的计数器</li><li>账户当前的以太币余额</li><li>账户的合约代码（不一定有）</li><li>账户的存储（默认空）</li></ul><p>以太币是以太坊内部的主要加密燃料，用于支付交易费。 通常有两类账户：由<strong>私钥</strong>控制的<strong>外部账户</strong>以及由其<strong>合约代码</strong>控制的<strong>合约账户</strong>。 外部账户没有代码，持有者可以通过创建和签署交易从外部账户发送消息；在合约账户中，每次合约账户收到消息时，其代码都会激活，允许该账户读取和写入内部存储，继而发送其他消息或创建合约。</p><p>这里面的合约是存在于以太坊执行环境中的”自治代理“。当被交易或消息“触发”时，合约总是执行特定的代码段，并直接控制自已的以太币余额和键&#x2F;值存储，以跟踪永久变量。</p><h3 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h3><ol><li><p>在以太坊中，术语“交易”用来指代已签名的数据包，数据包存储着将要从外部账户发送的消息。 交易包含如下参数：</p><ul><li><p>消息接收者</p></li><li><p>用于识别发送者身份的签名</p></li><li><p>从发送者转账到接收者的以太币金额</p></li><li><p>一个可选数据字段</p></li><li><p><code>STARTGAS</code> 值，表示允许交易运行的最大计算步骤数</p></li><li><p><code>GASPRICE</code> 值，表示发送者每个计算步骤支付的费用</p></li></ul><p><code>STARTGAS</code> 和<code>GASPRICE</code> 字段对于以太坊的反拒绝服务模型很重要，前者可以防止代码中出现无意或者恶意的无限循环或其他计算浪费，后者则会要求攻击者支付其攻击所消耗的资源对应的费用。</p></li><li><p>合约能够向其他合约发送“消息”。 消息是从未序列化的虚拟对象，只存在于以太坊执行环境中。 消息包含如下参数：</p><ul><li>消息发送者（隐含的）</li><li>消息接收者</li><li>随消息一起转账的以太币金额</li><li>一个可选数据字段</li><li><code>STARTGAS</code> 值</li></ul></li></ol><h3 id="以太坊转换函数"><a href="#以太坊转换函数" class="headerlink" title="以太坊转换函数"></a>以太坊转换函数</h3><img src="https://i.ibb.co/PW2ktVS/Wpv92-GNxh-Fwtgu-B.png" alt="以太坊状态转换" /><p>以太坊状态转换函数<code>APPLY(S,TX) -&gt; S&#39;</code>可如下定义：</p><ol><li>检查交易格式是否正确、签名是否有效以及Nonce值是否与发送者账户的Nonce值匹配；若否，返回错误</li><li>通过<code>STARTGAS*GASPRICE</code>计算出交易费用，并从签名中确认发送地址。从发送者的账户余额中减去费用，并增加发送者的Nonce值；若账户余额不足，则返回错误</li><li>初始化<code>GAS=STARTGAS</code>，并根据交易中的字节数量为每个字节扣除相应数量的燃料</li><li>将交易数值从发送者账户转移至接收账户；若接收账户不存在，则创建该账户；若接收账户是合约，则运行该合约的代码，直到代码执行完毕或者燃料耗尽</li><li>若由于发送者余额不足或代码运行耗尽了燃料，而导致转账失败，则回滚支付费用之外的所有状态变化，并将费用支付给矿工账户</li><li>若一切正常，则将剩余燃料的费用退还给发送者，并将为所消耗燃料而支付的费用发送给矿工</li></ol><p>Example：</p><p>假设合约的存储一开始为空，发送了一个价值为10个以太币的交易，消耗2000份燃料，燃料单价为0.001个以太币，数据包含64个字节，字节0-31表示数字2，字节32-63表示字符串CHARLIE，则状态转换函数的执行过程如下：</p><ol><li>检查交易是否有效、格式是否正确</li><li>检查交易发起者是否至少有2000*0.001&#x3D;2个以太币，若有，则从发送者账户中扣除2个以太币</li><li>初始化燃料&#x3D;2000份，假设交易长度为170个字节，每个字节消耗5份燃料，减去850份燃料，剩余1150份燃料</li><li>从发送者账户减去10个以太币并增加到合约账户</li><li>运行合约代码，假设运行代码消耗187份燃料，则剩余燃料为963份</li><li>向发送者账户增加963*0.001&#x3D;0.963个以太币，并返回产生的状态</li></ol><hr><h2 id="相关技术文档"><a href="#相关技术文档" class="headerlink" title="相关技术文档"></a>相关技术文档</h2><blockquote><p>参考页面：</p><p><a href="https://ethereum.org/zh/developers/docs/">官方开发文档</a></p></blockquote><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>区块是一批交易的组合，多个区块连接在一起形成区块链，并且每个区块包含上一个区块的哈希，这样可以有效地防止欺诈行为，因为当某个区块被篡改后，其后面的所有区块都会无效。</p><p>区块的存在是为了确保以太坊网络中的所有参与者保持同步状态并就交易的确切历史达成共识。交易和哈希被存放在一个区块内，并通过间歇提交的方式给所有参与者足够的时间来达成共识。</p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>为了维护交易历史，每个区块都被严格排序（创建的每个新区块都包含一个其父块的引用），区块内部保存的交易也严格排序；某位验证者在网络上构建完区块后，区块将传播到整个网络，所有的节点都会将该区块添加到其区块链的末尾，然后挑选新的验证者来创建下一个区块。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>一个区块分为区块头和区块体两个部分。</p><p>区块头包含的字段信息如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot：区块所属的时隙</span><br><span class="line">proposer<span class="emphasis">_index：提出区块的验证者的ID</span></span><br><span class="line"><span class="emphasis">parent_</span>root：父区块的哈希值</span><br><span class="line">state<span class="emphasis">_root：状态对象的根哈希</span></span><br></pre></td></tr></table></figure><p>区块体包含的字段信息如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">randao<span class="emphasis">_reveal：用于选择下一个区块提议者的值</span></span><br><span class="line"><span class="emphasis">eth1_</span>data：有关存款合约的信息</span><br><span class="line">graffiti：用于标记区块的任意数据</span><br><span class="line">proposer<span class="emphasis">_slashings：将要受到惩罚的验证者的列表</span></span><br><span class="line"><span class="emphasis">attester_</span>slashings：将要受到惩罚的验证者的列表</span><br><span class="line">attestations：支持当前区块的认证列表</span><br><span class="line">deposits：存入存款合约中的新存款的列表</span><br><span class="line">voluntary<span class="emphasis">_exits：将要退出网络的验证者的列表</span></span><br><span class="line"><span class="emphasis">sync_</span>aggregate：用于服务轻客户端的验证者子集</span><br><span class="line">execution<span class="emphasis">_payload：由执行客户端传送的交易</span></span><br></pre></td></tr></table></figure><h3 id="以太坊虚拟机EVM"><a href="#以太坊虚拟机EVM" class="headerlink" title="以太坊虚拟机EVM"></a>以太坊虚拟机EVM</h3><p>以太坊虚拟机是所有以太坊帐户和智能合约依存的环境。 当智能合约被编译成二进制文件后，被部署到以太坊上。用户通过调用智能合约的接口，来触发智能合约的执行操作。EVM执行智能合约的代码，修改当前以太坊网络上的数据（状态）。被修改的数据，会通过共识，确保一致性。</p><blockquote><p>参考页面：</p><p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">以太坊虚拟机图解</a></p><p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/virtual_machine/evm.html">FISCO BCOS技术文档</a></p></blockquote><p>EVM与节点的交互，抽象出EVMC接口标准（EVM Connector API）。EVMC主要定义了两种调用的接口：</p><ul><li>Instance接口：节点调用EVM的接口，定义了节点对虚拟机的操作，包括创建、销毁、设置等</li><li>Callback接口：EVM回调节点的接口，定义了EVM对节点的操作，主要是对状态的读写、区块信息的读写等</li></ul><p>EVM本身不保存状态数据，节点通过instance接口操作EVM，EVM反过来，调Callback接口，对节点的状态进行操作。</p><img src="https://i.ibb.co/QmqgQf4/Ady-Qf-Ioi-Tb-FJB7-P.png" alt="EVMC接口" style="zoom:70%;" /><h3 id="节点和客户端"><a href="#节点和客户端" class="headerlink" title="节点和客户端"></a>节点和客户端</h3><p>以太坊是一个由计算机组成的分布式网络，这些计算机即为节点；可验证区块和交易数据的软件在这些节点上运行，即成为客户端。</p><p>合并后的以太坊由两部分组成：执行层和共识层。这两层网络是由不同的客户端软件运行的。</p><ul><li>执行客户端：侦听网络中广播的新交易，在EVM中执行它们，并保存所有当前以太坊数据的最新状态和数据库。</li><li>共识客户端：实现了权益证明共识算法，使网络能够根据来自执行客户端的经验证数据达成一致。</li></ul><h3 id="共识机制-1"><a href="#共识机制-1" class="headerlink" title="共识机制"></a>共识机制</h3><p>以太坊采用的是权益证明的共识算法。</p><p><strong>权益证明</strong>：</p><ul><li>验证节点必须向存款合约中质押 32 个以太币，作为抵押品防止发生不良行为</li><li>在每个时隙（12 秒的时间间隔）中，会随机选择一个验证者作为区块提议者。 他们将交易打包并执行，然后确定一个新的“状态”。 他们将这些信息包装到一个区块中并传送给其他验证者。</li><li>其他获悉新区块的验证者再次执行区块中包含的交易，确定他们同意对全局状态提出的修改。 假设该区块是有效的，验证者就将该区块添加进各自的数据库。</li><li>如果验证者获悉在同一时隙内有两个冲突区块，他们会使用自己的分叉选择算法选择获得最多质押以太币支持的那一个区块。</li></ul><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>智能合约是一个运行在以太坊链上的程序，其本身也是一个合法账户，可以成为交易的对象。但无法被人操控，个人用户可以通过提交交易来执行智能合约的某一个函数与其进行交互，且该交互是不可逆的，即无法被删除或回滚。</p><p>任何人都可以编写智能合约并部署到区块链网络上，只需要有足够的以太币即可。</p><h4 id="智能合约语言"><a href="#智能合约语言" class="headerlink" title="智能合约语言"></a>智能合约语言</h4><p>主要用的是Solidity和Vyper，较为主流的是Solidity语言，以下是Solidity实现一个合约的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;= 0.7.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    // The keyword &quot;public&quot; makes variables</span><br><span class="line">    // accessible from other contracts</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    // Events allow clients to react to specific</span><br><span class="line">    // contract changes you declare</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    // Constructor code is only run when the contract</span><br><span class="line">    // is created</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Sends an amount of newly created coins to an address</span><br><span class="line">    // Can only be called by the contract creator</span><br><span class="line">    function mint(address receiver, uint amount) public &#123;</span><br><span class="line">        require(msg.sender == minter);</span><br><span class="line">        require(amount &lt; 1e60);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Sends an amount of existing coins</span><br><span class="line">    // from any caller to an address</span><br><span class="line">    function send(address receiver, uint amount) public &#123;</span><br><span class="line">        require(amount &lt;= balances[msg.sender], &quot;Insufficient balance.&quot;);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>address public minter</code> 和 <code>mapping (address =&gt; uint) public balances</code> 分别定义了一个公共地址变量和一个公共映射变量，可以从其他合约访问它们。</li><li><code>event Sent</code> 定义了一个事件，用于在某些特定情况下通知客户端。</li><li><code>constructor</code> 函数是合约创建时运行的构造函数。</li><li><code>function mint</code> 函数用于创建新的加密货币，并将其发送到指定的地址。只有合约创建者可以调用此函数。</li><li><code>function send</code> 函数用于从任何调用者向指定地址发送现有的加密货币。</li><li>两个函数中都使用了 <code>require</code> 语句进行条件检查，确保调用者有足够的余额或满足其他要求，否则函数将抛出异常。</li></ul><h4 id="智能合约结构"><a href="#智能合约结构" class="headerlink" title="智能合约结构"></a>智能合约结构</h4><p>合约的任何数据都必须指定分配到一个位置：要么是存储，要么是内存。具体内容可参考另一篇关于Solidity的文章（<a href="https://www.brokenmind.top/2023/06/08/Solidity/">Solidity笔记</a>）</p><ul><li><p>环境变量</p><p>除了用户自定义的变量，还有一些特殊的全局变量，用于提供有关区块链或当前交易的信息，例如：</p><ul><li><code>block.timestamp</code>：uint256类型，当前区块的时间戳</li><li><code>msg.sender</code>：address类型，当前调用消息的发送者</li></ul></li><li><p>View函数</p><p>View函数必须保证不会修改状态，以下操作被认为是修改状态：</p><ul><li>修改状态变量</li><li>产生事件</li><li>创建其他合约</li><li>使用<code>selfdestruct</code></li><li>通过调用发送以太币</li><li>调用任何未标记为view或者pure的函数</li><li>使用底层调用</li><li>使用包含某些操作码的内联程序组</li></ul></li><li><p>构造函数</p><p><code>constructor</code> 函数只在首次部署合约时执行一次。 与许多OOP语言中的 <code>constructor</code> 函数类似，状态变量会初始化到指定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化合约数据，设置 `owner`为合约的创建者。</span><br><span class="line">constructor() public &#123;</span><br><span class="line">    // 所有智能合约依赖外部交易来触发其函数。</span><br><span class="line">    // `msg` 是一个全局变量，包含了给定交易的相关数据，</span><br><span class="line">    // 例如发送者的地址和交易中包含的 ETH 数量</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义函数</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt;=0.6.0</span><br><span class="line"></span><br><span class="line">contract ExampleDapp&#123;</span><br><span class="line">    string dapp_name;</span><br><span class="line">    </span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        dapp_name = &quot;Example Dapp&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function read_name() public view returns(string)&#123;</span><br><span class="line">        return dapp_name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function update_name(string value) public&#123;</span><br><span class="line">        dapp_name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="智能合约库"><a href="#智能合约库" class="headerlink" title="智能合约库"></a>智能合约库</h4><p>通过<code>import</code>+路径的方式导入其他合约或者包</p>]]></content>
      
      
      <categories>
          
          <category> Topia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024秋招记录</title>
      <link href="/2023/06/06/2024%E7%A7%8B%E6%8B%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/06/06/2024%E7%A7%8B%E6%8B%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="2024秋招记录"><a href="#2024秋招记录" class="headerlink" title="2024秋招记录"></a>2024秋招记录</h1><blockquote><p>尽管只使用了轻轻的力，平静的日子还是像冰球一样一下子被抛了好远。</p></blockquote><p>打算开一篇文章记录一下自己今年秋招的面试复盘，暑期实习的面试其实也比较多，但怠惰了没去做记录。</p><hr><h2 id="私企"><a href="#私企" class="headerlink" title="私企"></a>私企</h2><h3 id="TP-LINK"><a href="#TP-LINK" class="headerlink" title="TP-LINK"></a>TP-LINK</h3><h4 id="提前批-软开-杭州"><a href="#提前批-软开-杭州" class="headerlink" title="提前批 - 软开 - 杭州"></a>提前批 - 软开 - 杭州</h4><ul><li>23年5月26日，测评笔试（行测+选择+简答+编程）</li><li>23年6月7日，一面 25min<ul><li>自我介绍</li><li>实习</li><li>单点登录</li><li>跨域</li><li>反向代理</li><li>session的存储</li><li>Spring注解，启动类注解源码</li><li>MyBatis中$和#的区别</li><li>OpenStack的组件</li></ul></li><li>23年6月13日，二面 25min<ul><li>自我介绍</li><li>挖项目</li><li>兴趣爱好</li></ul></li></ul><h3 id="三一"><a href="#三一" class="headerlink" title="三一"></a>三一</h3><h4 id="提前批-软开-昆山"><a href="#提前批-软开-昆山" class="headerlink" title="提前批 - 软开 - 昆山"></a>提前批 - 软开 - 昆山</h4><ul><li>23年6月9日，笔试</li></ul><hr><h2 id="国企"><a href="#国企" class="headerlink" title="国企"></a>国企</h2><hr>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lab1 SimpleDB</title>
      <link href="/2023/06/06/MIT%206.830%20Lab1/"/>
      <url>/2023/06/06/MIT%206.830%20Lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lab1"><a href="#MIT-6-830-Lab1" class="headerlink" title="MIT 6.830 Lab1"></a>MIT 6.830 Lab1</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>6.830的Lab1主要是实现一个数据库所需要的基本存储结构，以及相应的逻辑操作。</p><p>根据指导文档，SimpleDB目前需要实现如下的类和方法：</p><ul><li>实现<code>Tuple</code>和<code>TupleDesc</code>类，<code>Field</code>、<code>IntField</code>、<code>StringField</code>、<code>Type</code>类已经实现完毕。</li><li>实现<code>Catalog</code></li><li>实现<code>BufferPool</code>构造方法和<code>getPage()</code>方法</li><li>实现访问方法，<code>HeapPage</code>、<code>HeapFile</code>以及相关的ID类</li><li>实现顺序扫描的操作<code>SeqScan</code></li></ul><h2 id="SimpleDB-Architecture"><a href="#SimpleDB-Architecture" class="headerlink" title="SimpleDB Architecture"></a>SimpleDB Architecture</h2><p>SimpleDB（或者说一般的数据库）的基础存储逻辑是这样的：</p><ul><li><p>数据库中的表Table是以页Page为单位进行存储的，每个页中包含了若干个元组Tuple</p></li><li><p>Tuple和TupleDesc是Table中的最基本元素，Tuple包含若干个Field，是最基本的数据单元，TupleDesc是一个表的meta-data，即每个列的数据名称和类型</p></li><li><p>HeapPage和HeapFile分别是Page和DbFile接口的实现</p></li><li><p>BufferPool作为缓存池存储最近访问的Page，<code>getPage()</code>方法会优先从这里寻找目标Page，如果没有，则会调用File的<code>readPage()</code>去文件中读取相应Page，从disk中读到的Page会缓存进BufferPool中</p></li><li><p>SeqScan会对一个Table的所有Tuple做顺序扫描</p></li></ul><img src="https://i.ibb.co/WFTKfDB/r-NK1c-TFf-PQji-C46.png" alt="SimpleDB Architecture" style="zoom:40%;" /><h2 id="Tuples设计与实现"><a href="#Tuples设计与实现" class="headerlink" title="Tuples设计与实现"></a>Tuples设计与实现</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.830 Lecture Notes</title>
      <link href="/2023/06/05/MIT%206.830%20Database%20Systems/"/>
      <url>/2023/06/05/MIT%206.830%20Database%20Systems/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-830-Lecture-Notes"><a href="#MIT-6-830-Lecture-Notes" class="headerlink" title="MIT 6.830 Lecture Notes"></a>MIT 6.830 Lecture Notes</h1><p>MIT 6.830是一门数据库系统的课程，实现语言为Java，课程主页可点击<a href="http://dsg.csail.mit.edu/6.5830/index.php">此处</a>。</p><p>这个系列的文章主要记录学习6.830课程的笔记心得。</p><hr><h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Data modeling &amp; layout 数据模型<ul><li>结构化表示数据的系统方法</li><li>对于数据的持久性、一致性、共享和访问效率很重要</li></ul></li><li>Declarative Querying and Query Processing 查询<ul><li>访问数据的一种高级语言</li></ul></li></ul><h3 id="Consistency-x2F-Transaction-Concurrency-Control"><a href="#Consistency-x2F-Transaction-Concurrency-Control" class="headerlink" title="Consistency&#x2F;Transaction + Concurrency Control"></a>Consistency&#x2F;Transaction + Concurrency Control</h3><ul><li>Atomicity 原子性：某操作要么完成要么不做，不存在做了部分的情况</li><li>Consistency 一致性：事务的操作前后不影响数据的完整性</li><li>Isolation 隔离性：并发访问时，事务之间不会互相影响</li><li>Durability 持久性：事务完成后，其所做的修改将持久地保留在数据库中</li></ul><hr><h2 id="Lecture-2"><a href="#Lecture-2" class="headerlink" title="Lecture 2"></a>Lecture 2</h2><blockquote><p>Those who cannot remember the past are condemned to repeat it</p></blockquote><h3 id="Relational-Data-Model"><a href="#Relational-Data-Model" class="headerlink" title="Relational Data Model"></a>Relational Data Model</h3><ul><li>Key properties<ul><li>表示形式简单</li><li>不需要物理数据模型描述</li></ul></li><li>The Data Model<ul><li>所有数据表示为元组的表</li><li>表是无序集，无重复元组</li><li>数据库由一个或多个表构成</li><li>每个关系都有一个schema来描述列&#x2F;字段类型</li><li>每个字段都是基础数据类型</li></ul></li><li>Keys<ul><li>主键是唯一标识一条记录的字段属性，每个表有且仅有一个主键，必须非空</li><li>外键用来建立表与表之间的联系，表A的外键是表B的主键，外键可重复可空，一个表可有多个外键</li></ul></li></ul><hr><h2 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>Left Join：返回左表所有记录和右表中连接字段相等的记录</li><li>Right Join：返回右表所有记录和左表中连接字段相等的记录</li><li>Inner Join：只返回两个表中连接字段相等的记录</li><li>Outer Join：返回两个表中所有记录</li></ul><h3 id="SimpleDB"><a href="#SimpleDB" class="headerlink" title="SimpleDB"></a>SimpleDB</h3><ul><li><p>SimpleDB主要组成部分</p><ul><li><p>Heap Files (Lab1)</p></li><li><p>Buffer Pool (Lab 1-6)</p><ul><li>Basic Operators (Lab 1 &amp; 2)<ul><li>Scan, Filter, JOIN, Aggregate</li></ul></li></ul></li><li><p>Query Optimizer (Lab 3)</p></li><li><p>Transactions (Lab 4)</p></li><li><p>B-Tree Indexs (Lab 5)</p></li><li><p>Recovery (Lab 6)</p></li></ul></li><li><p>模型图</p><img src="https://i.ibb.co/BTtc8Sn/eu-Npbi-K9-Jtzo-UGa.png" alt="DB Module Diagram" style="zoom:40%;" /><ul><li>DB -&gt; Catalog：DB调用<code>getCatalog()</code>方法，后者返回一个列表，包含了DB所有的表</li><li>DB -&gt; BufferPool：DB调用<code>getBufferPool()</code>方法，后者返回所缓存的最近访问的页</li><li>Catalog：<code>&lt;DbFileID, Table&gt;</code>，其中Table：<code>&#123;DbFile file, String name, String primary_key&#125;</code></li><li>BufferPool：<code>&lt;PageID, Page&gt;</code>，其中Page：<code>&#123;PageID id, Tuple tuples[], Byte header[]&#125;</code></li><li>HeapFile：<code>&#123;File file, TupleDesc td, DbFileIterator it&#125;</code>，生成DbFile</li><li>HeapPage：<code>&#123;HeapPageId pid, TupleDesc td, Byte header[], Tuple tuples[]&#125;</code>，生成Page</li><li>Operators：生成DbIterator</li></ul></li><li><ul><li></li></ul></li></ul><hr><h2 id="Lecture-4"><a href="#Lecture-4" class="headerlink" title="Lecture 4"></a>Lecture 4</h2><h3 id="Functional-Dependency"><a href="#Functional-Dependency" class="headerlink" title="Functional Dependency"></a>Functional Dependency</h3><ul><li>一个数据库R的一组FD可以表示成：X -&gt; Y，其中X和Y是数据库R中的两组属性集合，其含义是：对于R中的任意两个元组，只要他们在集合X中的属性相等，那么他们在集合Y中的属性也相等。这里X称为<strong>决定因素</strong>，Y称为<strong>被决定因素</strong><ul><li>完全函数依赖：在一张表中，若X -&gt; Y，且对于X的任何一个真子集（假如属性组X包含超过一个属性的话），X’ -&gt; Y不成立，那么Y对X是<strong>完全函数依赖</strong></li><li>部分函数依赖：假如Y函数依赖于 X，但同时Y并不完全函数依赖于X，那么Y部分函数依赖于X</li><li>传递函数依赖：假设Z函数依赖于Y，Y函数依赖于X，同时Y不包含于X，且X不函数依赖于Y，则Z传递函数依赖于X</li></ul></li></ul><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>设K为某表中的一个属性或属性组，若除K之外的所有属性都<strong>完全函数依赖</strong>于K，则K为一个码。（码可以不唯一，但主码唯一）码中包含的所有属性即都为<strong>主属性</strong></p><h3 id="Normal-Form"><a href="#Normal-Form" class="headerlink" title="Normal Form"></a>Normal Form</h3><ul><li>1NF：最基本的要求，每个属性都不可再分</li><li>2NF：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</li><li>3NF：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</li><li>BCNF：BCNF在3NF的基础之上，消除了主属性对于码的部分与传递函数依赖</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非理性散场</title>
      <link href="/2023/04/23/%E9%9D%9E%E7%90%86%E6%80%A7%E6%95%A3%E5%9C%BA/"/>
      <url>/2023/04/23/%E9%9D%9E%E7%90%86%E6%80%A7%E6%95%A3%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong Password" data-whm="Wrong Hash Code">  <script id="hbeData" type="hbeData" data-hmacdigest="0e66c0b1dd06a7e2c248b5ed9b563524517d16fd0098a6f6fd8c4d8c24c06b67">1a19e4ad4addc8e5c84a496a2c5669b58b830e95c5b7ecf6edb7787dff9266c09ab38d714984c06f4b07962a8cb92d16a5231cf8cecd95ed49418dda50facc8e7683509c8f11db22fad654baceda95517128ad5d7f786f0b4c24fb3cfcc6ffc954a6c149f948d8b2c223f514a5cbceb2733ad2a3ce80ab5a7b559d0bf5e459d4e4e01ff26c076deb32ead76c556dac35762b68ca1a7573efa810b8d9fb8861ddb3972044adec0e6aef6e34a713e564fe4ec5c67a44fd7d97ac901442a6431d998e838944e7e9b0fea88e71023c9ca869994c27b6b382aaa2ce0039f76c472d4f27f6da62691eda610d3c73b6eb22bbde21a7a99b009a4b45657f249d5ee3767d296ccfa4338c3a3b9355ad62d59eacfd7e1ee8a3b02567434196249c7f4ae2e1111c8959cde8ed46945e8cfaf637016acc1c30648b582f0f8b8b3aa4b24f716bdb02ba15924474f9f3f47d4e645b606f061be22dbfcb67a5f8ae033621f9b779d17d1196ac08bb938b543b7dadf662ecb089021b660c5c907de6b129637a2bb207a24915f099ee5b1ec8de56b3e33e36cd1cf54bc341402b0eb2d253e6e397600bc9ff4e0decfc579b11c0bc284825306a1d2ab7e9aef34a1ad5333a0d4b49e70fd4fdfec630207afd311a90aa9839ff553ec5b7cd43c0a982cb69190572f264d33a6c4b22c3597ed46592e92cc9ff60b4ab0eab77def3640e2b36c6395ccdff64c3eaceec7c5ea313eaa14991a87afcaf77bf7db5f44a1078739b7c2744bcf3d778b088e62d5ddf23d2e981d7983e7a9319c832d987f3883c3c1559137f6b06321e647cd8a4cb63ca5947fa7e77b571ef1269f4244a098a14d8db2946a3d4c6acd2f0eb175d3689ec1f870b0046431f3866cfcd28ed6f484a9caf3a774fb5c233b990aa0bcdaa487e65b15306a8eeb6205a952c9b7ffa80000855a9befb243b0a603731572039a49d8207dbc94ec37a0839632ce6d65671e98cda453a64173fecf9fd25fdbd5490b360939ca485864fc305819c5397a76fcafc75ebc930bb4256c233cf726b8113861c710b4bf888d40dd911baeeb74841dbf98b5ace1fa6cd7691813c871b7d170b670cbcd4cc247cbf85f34c9c0f8570d1a6a244c71599c8e67a12d3dc44046072d86bee760e941a6aa09ab076b082f9130fbdbd4b5097af10ed104f94e038393502fbb29640924f6cca1c95830cb9d4e72bd3e00ab70883538004074ade940aeb33eacc41ae098f6d423fd1d7e86cdd48c6f928e09d46cc6c14e987b86936bd914f3726c9943f40c74ec54b93b11c08bd826aade0f65954331a8a9680b80bd45a7d533dd44741428efa36fec34a58855b1df0e48c27967772c648b1564583fb81cb5ed9d8516adeb656954cda3dc86850401cb2ddcff8838a1a476bc28bfeca85efa4445e8cd719001de7cf3c5f3253ee2e3cb6882b7eab13c7a153c87b680f60f72f2df4369836da48aeb13a579a7caf4d6b0f7ced1f31ea8d9bc9dc0fbe3f8b635c27886230ecf3f34df20d87db45a3040e3906c1aec5be707916e0afdb44748f49af55fef9c1bc5bb5c16c3958c82e86c6e0c4ca11b767c783fc2967a2a44fea535604dbc09768186437dbca544c9a49e7b9e6b95855860ada833a67ac6b16db33709e16e5ea85e4799b06d338564cc6c0aee0f36bf02dd2fca1145f38d19b57a48312c56be698612f4702e556f8e3ade4dca0dd434fac6dea73554002eb43c6ab6c8cf30fc7d159fa1543eba092704cf8c8f21744f02ced4cff998066a000e361a06e1a21133edfd7076b4f7f5248a4f426fa5229b373a2df157bd553f71bd5dfc57222784a500e70bfd9355c0ea85409e068db38df771fc7018d397489048229f87d917a49a7891fe1ddbbde716b556558527ad14c5f26936201d60e26ac1268d536e0b62d16dc02df97740d64dca841fd1b225fb720dba88aa25b59891f986cd8c2bcdec25b507e925d689c539d7e8b2aac52fce0132b9229b48b74fa5ed45dfef20e20df64cdca39b2f4a2c9094085e3ee20d96d3e1297987f231f16db064770aa3b6de51d167599c38c013bdea4d019c1de7f8a6bafe136e5727d7573d6fa230b75897bdf99789a7919226642716a801f15de6f15ee2d115911175a786896fb1c193f27a392d3e91eef930bed01e363cd2ae1f00045b94c8443f2d1f8ae56ae8ee16e3e881d7d098f1ed11b91a39460cd54d9f9c46ee0310fd64a0a38eaa86d43c5d4e301a406b71a50a8fac75a61748027f1fb88fce1d8319443af3a3614b4d8614abb60d5707eed9002b5c4149ed8c70f4e1998f35ad75b8fcc214b23ddecfaea72d1986302ef0305f978cd0dec926c5c48cea40b14762467d68f954c02f118f860e7bfff80be18a2aff18b55e5a636d33bcf9a1d31f599fefee2a13718deb48ae42815c30ce3ff62b0fe5fd452c9830bfc0e616779df04a3cc4bcd667ab894cee0dfcd5b61f28ddcf36c9f0a9df517eae8617957fc48e28557372ac23fe9c2c22103f29deabbeb2602d6ab776342772dec1a013df952ee963d68ec1b1c83b867c4881577fb6dcb63fa99b330eaf969a38511786db8e3b8c2054bdc8f6c7f9d1e742b11eb495ffc7e8e73e5ceb2d5f396b52c9f0bcba8da7465d41d238567175d50befd6c554d65903ef19ffcb213beab69f6c59e8b8d221684e18d0a9e99a53e6b3451f802225b689f5edda7c138bd2d63a8bacee0ef76237c69d4a49527b20b0bc0b0b475c12d4355714de2f6539280ca23355642ac19be60cd0b512fb4b6e7bd8ae0e4e20832d03ce6aaddd11a68cb45573a5f7ecaf8c5adddc3427248ea67ea5c2f920155422149a58973584d166716ca923923a03d3dbe6c62c92601876f12eaa6613c44f212500c8c9737a5a66c17d6c5ded4f3cda018ae6dc564f0c50a981b07529224c06b2988e393b79d4495ebc64f1ac5d8168f159cea2d0e35b18cf5a48a678a139a98d70fabb2304b66a7a7e9e364ac53ced59fbcb54f62940da6b284fadef209470e47e5d8732876b4c9a5e177648a4593fcc1e22efaca06ce0435b49768149c89e7b3e0ba479667d7fde3abf9383fcd4a2ecc0c5c2438d8b852eb055f59f53c5359db8b9fcf957da71ebad665757d0aa9175c4d5f52fc29d3264999d7e88df4aefc466fba7b57417da3b26970ddfa95eec390a896d3641ff86325ae6599c2fe11107aa3382095f1cfadfeb70b783fcbd45e8c08ba01c17aa8277f43d674159288fbbaa0cba0c26f9087bcbbc398c36b74351ab94d0b469adb71928ed12deeb1561171fe11f48ffb3491db4aacc050b6d28e46d0cc773f81a790663eb3d6874de49d85685ea687709e2220be95ac29558c1a95b3557ccfba79caec166613472a645a8f9dfdd98119d520d887a111a7546a8ae65d4e42ddd4e02a1465d0d4a287239f08f627584a962a6be22a4ad76ce1d563f4a04c060a74a24859ef6fd8a73acb5cc72faee1d85d3f43fad3b9c0c31b75f97cf32a0799d973d8280714edb2a6003a7a7f86d24c793b5e3f02c2afa2456d67bac9d648054fe2da2eb1411fe2c17a400b7e78a3842371aae7ed6f25668f700095cbe700981178fccdbc5aa9bb8f2a9eb2afcc9e08501f2d8c2fc5006e22f0c8f39d05d593b4e8e2fdda9ead1c4e44efd92cc9ce5ab7ef2a82aa5af93af90fa28e68b2a17dc9d75ca6c8b20a3434918abed3b3788bdb7034a47a067dd4dd77dc2f38fc4e2cc6523ac8b04066e186e71740f952905c8ade84ffc272bf1d09412b7dc8e571af6bd2d8c31a8ffdef665c3a0d198f2fddb3967bca0bc2dc6af0cb72e04ef7c56efef908e47a014ce3b98804201f7a068c8b4639e29b8ae253ab6ff1c1952be0ceb523dfc146ed2d5e15640887f9d50c16326adbb1e8eb44383eac3681a5a09035258ae735756cfbad84ce541c64ebbe23d40363e76b9b10d9518dbf5685596d3d2016ca6f2d0eaf9525a14c7787768bbbbc6701ef156c961a2ab8f9956578b412476ab753a7b969d0e9900f7ab0e198d0e7811425cf4cfefb18cae727326398ac6cefbb640c8f1dbef732f78964ad6b853fe5d58114b3b79fa5f5e53de10ad567c1e456f6506f400751bb52c053903a6c6c44739a99913c7cd56b9797706b6430c836decf6e3caf30eeeab8fc8e34e94fa578ce4a50860ee00a399373d29674bb034581bbc7e914986d11dacd83e2a6b6d742d16085e656baabdb4dbb9c1bb8c8420c091ad4ee846e2e7464515e12741233b8d8e1d94f369b3c2005d0c11d5314546bbc97626d67258b84fa903dce50f688a68d3c5cb65df76077f670a601e482ae0e6ef5caac54f516e539ff59e3d0429d59a84340c68ea46e55932a9c28edad808994886c1a8bee06591c101acaf1947533f5c47c2642e553d9b8695ec2f01420b6f88ff7bae099e40d77cf4e394c6f8b9bef48ab2091385d4e1c20f6324de309e9ec1ce93c8c7ac557cd4acfc7bf2e6b6eb1365b4576a3ee6327a40c5ae856b3bf0657b63d6828bf91dcf728c07ac8f64c3a1626723a2e6eb58dcf7869437b1f8dd58402e07950118f85f9f5b12e7912690d50e62716dbfe52519324ca75dc9d94d13ef0ec5184cf55c7fae0cd4c796ad299ceb2629684fdd14cab6130d1ff5cc12a98b9ec640340c06c30e0254abde2f78613224584f23f8b71870e8f3d64ee4da2ea0f34ceb66df581d0cb717bea238bb1bc7a1efca2c37ea941a6ea149821723caffbcf1733918681df83a97c6db5274e88b8104472159ff085c64ab69d2597ee6d9f5c311a699c025f3a5ce890c4aa20b99898f94cb52489cecd69cec36bd332d405dd20b8110c6cd6def3df6359dca60c036800ed6b146adaf624ec0132b79df11eae234c8a8d030963ad7b87b44802befc7940c8f6fde7271e345708de18ecd45ce043735daffbd139066f94022ca60806b93fbb649185a2f77e521bdbe0bd71b708feddf882a996e99fcb166f16245d2da512bf0e1646bc987514f641d176946177a84423eb0ca99886f52c11cc11f0b99e219642920ea7693f15085621d4898969698b0b8cf4f3d51d1e5df0ffdf09ceb3fb26d500921c01073a0080f7dd0b6035d06820f6fdf2dacdcb2d13b6594ad762b37300feb3fd11424c7a504be7d20dcbe71ef583768fe3d6dc4ddc87330358b9e6bf954f80fdf1cbe28155064810f71a50713cbdb652a062168a07d0865e956bdd1c906837a031bd73e0c12ac1c119bd4702886113d6737c4878fa0f9fc5a3268ee1c7770d1c7025226c069fcd42e334a7cc63fc88ca8852613929ede055f11ccfac3e772085b09e8726fdf192d5b5e485496ee7c6c8fb15781cbeec7bd869305bc1399e9d9499845877966be65ff73960e99ba352d487365c134b09d05932a2a17a728e7e45049243203904739e3105308b87a9b7716569e326e900f70f5cef744adce150d2e2551dc23582a9625aaef053014d4f9cbb8066608b294003f2f1db0c4c856a815e0607a9e09cae2ce34372eadb28008fe93d94aaae7776b3ff7ed6c593709ce73adaada58a0f110fb74bfa2e403970ec1dd0699b64b9371aa2c3c0029f0768db9bef2cd100bc4db80851183492b6d38c5ed5d66862ddddf0420d7cca9b224f4e74a50a87a586a15a52e6a9e62c33376c8c9ea6d1232c182d6b203fc2f08ca84c6c57db7822164ce914a1803c4e2953b71c465e26b7b71f775242640cdc3d8129ef6a061769226dbbe2f47c9bf517b85d0682e245c94d1f49f8854c6ce77df90ca64de232409602f021e3a071705e82afb5172a5cc699d4134886ef08c7f56f66a2aa167c935201dd7f2decbeca2576dc1080baf97daf3837f81fe4a8cc1b11b788a3939e1b0a1f3249f6f5db18e35cdee0b00d80ad5cad2e3f39367a7cd38ac9df793d2788e10c0e675e72380804f081126241fe9fd33d1ce1884526529971513810fd6c9e4108ef772148d2d61f03e6647ca1e5657a7a53ce0fc33e22e43efb6ff8843df5fcd02dd161d3948b8fd7660e155262b62d9c0a3a07f5ccc3a039c2f96fb622b92fcdfb146cd08da16548b6f3201fed7932fc88ea6ac43c01db14c0085cf621419c23ec361e743a58deb14306660d2d508e0bb6b4a3e46c5b720a640691d16ba767897d5b41932a5cdfe6e9b4d506df1f811cccac57e0f3c25f19790dfa137a2f1e68d9ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Password Needed</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 街灯晚河 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒雪的绉纱</title>
      <link href="/2023/04/04/%E5%AF%92%E9%9B%AA%E7%9A%84%E7%BB%89%E7%BA%B1/"/>
      <url>/2023/04/04/%E5%AF%92%E9%9B%AA%E7%9A%84%E7%BB%89%E7%BA%B1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong Password" data-whm="Wrong Hash Code">  <script id="hbeData" type="hbeData" data-hmacdigest="4ad9bec66423a628704bb30bbe1349f04f31ad3051c4ce6e8e69927776e37987">1a19e4ad4addc8e5c84a496a2c5669b58b830e95c5b7ecf6edb7787dff9266c02cd4c19d7da818cd4a89bf0c4317b32459cac75e44123a44915df547bc7352f07c254e33ec0e80692efe92f1049896791b3a9e8423426d876985f05c640afb6e3043a9f006153c422f6531e89a70288f10ed31f2c2cb1671211dc46d75b397181180c050fb4ba967d808030ad852e615dd6a5ba7ea4260877702206a4a6ce7189cdb739e66776e36ea68f4800116313aa5b1155ff59f579aabbff3478f3956d9f42c1df05d43ad502a42941fae8ec3438704ca5ee85ece30470fae296a72029b8245f6bb8836f1ed98cb2a555f4feebe3ac2216fe51c53fafe7e85c6aeaf556e2d71e231c1c89a11807576cf11c0126f9f8d104ad8335ff34df45c10131c7fdd9513a3e3f612c3983bd59f734ad913f0f3caa9535c0af205988a0a3c180c9953a419ec87ea4c8fc718ca0dbdd4e250af5f27c4f9f668274b685c539588287cede4c04c447546b4e74018948b915603d06708686ff5a95b3ea3bb6552be7d49c697994b29f96833889ac83acc547138edb0934b6212b31fbd4e80202a4531c7e1c64ab42d679e7baf1d8362873d615d9ff910b537220fa398eba4dcfefef6e2536a60810edd17c802800c52c07a567e29aa923e46995c7b5326a19ef97854ffaf4a24e79cb3eb810adf74838a3ec3e2b31b61dfde781d9f0b8a2adf9d1f7fd970c3abca5c63a79abc497cc94a08e686a656c4d0f29c569b623de604e5c4660b066db22a804b2c4289f13077bc24983c8e59c697bf4fb4ce3848bfd0fd08c8939db12958bc85c94ed1b14754604f7e84f774952f56f211d3c14413451d92791edb885be86b0fecfc46255aa754a7da471641e9721fd2b4e711df5f61fdfd7ba8f6b3a02a1f7473f2bed6a513f91f2c67669f92d44bf310c3c5dfa0b5540265ee691f65c24493231e383d481d8641f72e4368efbca77d09054f8a131477678f138ce322aa674638e806a4bda50d74457b0607c4dad176c95f90f092464a50c528f3aa4a71649ed74474a2194be62df6164a997ff7ef78082697f5c18e05ae79441a901682ce1ed691dad8e6d0edef69dec4ccafa57ca5d323480b83fb15f53eb0941d4cec9b0f5e1a11116570cde41fad4f408fb03a6502d1c95bd2a6ad28f17492bf066893442e4788e546a1f4b82da16af529c30cd9766cfef395c8ac02598db92815e2d17010e684f569ba657112899b7c651dd05b698626356f421dc7d81a323d68a52fb6a612bba2f53000198d92fe30a9e264f8003482540395581b1baafdc731583f7573d3c5b8388f6e644f0b5d9c0efa6c0fea785db3584eb2c4acb063b441fdae6d86bc376e89bef53915f57e943145b8f601e6b2784ba0293e26b0655475faeb1cf51835104d5eb5f379479e09caf01801c559477ff747705790e902050fcd3f7d1e1324d58970f568923d7ca029d46eedadc272f5bf9c6173963a14719e23ff54209c283de4e9670fcfcee17ac569e76d8900223e2633662dce16ca10632a8820c090e7c05b39f717f00cf61ef3eb97156c15422a23f12f14412924e9cfff15d104f4c8442bd01889b3d36bfc0add6dc4ef705737311707b15d635b3dcd45a23ea8e44a74d8c8a3dff40d84a9ee3070a2c0b1102cb94b5bf8d75d0bbb14ea3da525877c005282627c29b9491d5f74ebf565212505b21abb690c0504500a51dc475f1342fc924b82ba20094bd79ac6ec91b65f317d5bff103e6c5c731bf23d7559b1a62e181e0b3e1fbc971f3d53322029742ddf8846217d1492bbca9fbdaec6c8d61d9a8ac21a775a64363d23ce68389bb40b753a1187482da2b109537c823c10eb719410dbbbe154424b29dc577d17efec7dffe57704e599c3713d5c696500c48354f1eb808c479bd36a39b3df5636884ce8078226c654c25a4dcd02d967e5c21bb780d3145b1ef264490e7e9c6e617c663d76bbbfc4d049d09a18f741b20740830c784efa150e37d76c074a19dad956713ed8920db10c5e7bf51986acff6b9f490fce26d07a5bfe76cce246c2bb06e328d268f105f5e006e4a9b13ca19b1df5e0b0a133fb0b28d8f84078feacdc0515bab377e267e211f8be4c67f30f2603679e56b81e9544469efdd0630963e3271289f5fe4db57d69fa994caa4d2e425fe4f003edb8abd44dc5c09a092f5e9c5343232097723eef3cac8119b02dd0476693f79d5b9d002d35c4a73d5c34bd71dc83b83f01408b2adeff2e32f635e226c8ef33c9f077bfb23cc39aef7fd33005f39d66be280fe3e851d413f7c4691ac675ceb8bf08cbbcf1d02636888d1e05bbf12713d6e4c486169c3bb15509983f8a2e3ddc5090615e6246dfc98dab8c451e69a50de3f4a885738a6e824c1d6a205847213fe79a9fc341e588fa199e1a538bc94ebe5d98cb2f6ac7bce5da3d0b84a7b3c14465df0d0b14509d1a77dca109ef60ebaaca763096189f2cb7038f067e384aa373c25e200d6dd6c7c84bf1bd4f67067ce68f94d3ecb71f07bdfa513d22a8dd911fe2f2567e1fad49dfcd49ed0af0394bcfb458344885fa936f7a201420631889aad0a36187570912302e9059b2a8bca01b2d790f95fde18656cdb5e74d78843d48bdbedfd4089678d96064aff57c5bb8d7c40616e739d92d5e2c86a9dba97ad4284f2970ffee5b364d13400e474a861b86e6887f6dc38517204af29fe8308eb599c86f098778ce454376665d2b4805ca6786121fc3ad4ebf2259822482c8503743f8e031ad2d01f445647568c29f5ff9611ced102ad99273ecc27c5384920eb7b2bf3ce8d3284ea477610b24371e93afe9d87e64f11a56600cf7ea28486fe7772038b6bcf0830a30c107cab4d302549c79802d7a6aab113e9a3ae9cf5a4b99176fc92f2c3c73bc122d9c67d90074559e67377690632e300989d89ca9cf1813b9ab1c34efe13ae190e69ff978128be83ace9e22b75b47693828b794a02eddabfbdd084681cef7b8fcbfd9d74da93ec7b97602ee12bd7a6aab5a3b806bc426345aecfd63f063a5d1a922d7fe65ce13b1237e4b805e33e70ccb30b2b26ec8d56bcf3af507eb1de229ce899e7e3dc30ff9e9fc8610ae25cba17dc1ad6e316fda7b633b7bcd43b1b9f3d7a82a0d1f795495efce75ac674553def4ac3cc60e34a8058a2347dd2801b47c3b1463d6aa6bd647b881ce0cd8b5b1ead19cc8679d9a349eae457819d7f79bfd8c5beb09ef5741a24ad54530bd7f89906d642907a3b4093ddc9857919e9056b37a2e275dc35de8146888aae4339312f9007582b16e7b4ac1f43802298b21d6be79fb0088f41c3ea1585f07c04c04ea723d75860e6d1b5d4f63222f3fd35cc78bbc6e53afb9e10d6e982d940bf7f39eac17c48e061f3b86d03de42fd13f7c615119c8108edf13b6847932984010a784f2de4d7604e0faf88884bec19541c71ccf8f04bbc3e633bdee5078901a74356164b09f3a4829cd34dfc3aa8ad9d446106a65da86b66e3c8fba83e110ccf42d3143ad507d2fe880589b30a6944c1e12e6f06e130afb6e11e49508dad7cfed8ab244d02ec1da2868aa6ee2302a54437b3392a46966543eff5cd50bbfb91905f9a414594fb59ef5cb0b126d756cb0e844845c81e365c746056b416abc265282ca329724945ebc300a48846bd83a195f041b367804be48af623fa5a1b2be51c8265da5a92eb3e2767995ba5d5b7f29e85f48894dfce5781ad75671107b6dd0b779151923def27367c3db21fe72d49c02abc9c286ad6f5bc93c2e3e656afe25fefa26c2a32890d101cc4d37075ca043eb75c7ac8bc7c24e6a1bd76f2bde9796c7b4a700cd4125fb91d8ea2e56bbdd284b04a3140538d08766220864c582a0b528aaa68edfb674d984dd16fd4f4844005925cc93a5147a679b882a42e8d2943e1834ca1f1dbc998a676c6d56c85dccd2a72a0ee85d56e598231f34b1eabbb26f007ae0776c1fce260d5f3631e8316bde4c6cf2bea00610cea4e905f1ff341b71ba72fe2a2a0f4edefbe8f6f73a1c7a6ffc7a171e5cbe28d5850f8993b3468782bafc63a65d249a31cad2dea063e892f02803e7d46ec42b36f4f25fea8c47d99b3d28c2cda3f0b2bae56ffaf0cc9ebf2464860c525960f44723a4e4c81e9dfe793db75086a5ddc66ffd32fe4f4183d2e97339dd8d7aa339b137b542042e54b885560ce38e69210b7ff7177176207ee47d5d049278adb9cc21e47ebca0f8b7f339032c7953e0046ba409e9c582519aaf1d10c5fac7c7cb060e26ff106ecc169da054056988f132a5a24c5ac5ce2975b94b35499329b1f06654a2d4e0015c86d80e32d29fa9aea78af39f0a1294f06238cfd36376f98b47922dfe3186d1af7ab05e03711e85a7d7346f3616c6c300f004e8b0ea5a1eb0bc7a596df57f289ad6f660e5f695219ebab1dd08e63959b5117c4570a16f9568c241069151f683012401c9e07ae16573775be505f9cff4058384144e30c6b5aa3c4a52b88d4a8fdabcfdeff13d45ed7242e26baed3ae7a2caaf1497aad5c33c5ecdaa196929db88b34ec7116dc2d21bf89b9078abe53034c6dce27b5896c460bf65c065aaf07ca46ad5ba71dd3a5139dd6f26c5ccc748498cfb0c69c623044ef951f9f2af3f3b395ba283bf1aa864860581df0454a8e034eb6d7b8c8555982fd55f1594df40ef1f809cb04e6dd8af89cfa85fb071771cd7bae7a3f1cb21676d0020c4903997bd24362d31238b563d750f0920584e38f656f6199debaaa807f28fc2b473db4747d95ef5c5cb22e168a8833dcda15ce0065b856d4dddb4fb3243245a1a68f337f40ad10aed5f93f07c668c28a0089984f7ddb5c99c65a42a78aff80c58bebda7c7b19cdcc046604cbb5da4627e375308b590f0656818a98556d8af3b4320362b10afa7b6c4eed779180dc6f31cd1b0a0d34ccd85bf01570fbc145c9124371e64b4eba742919194b66ea3194188452203b682f2f625571e2d988628ccb6aaa85d3b3188bc93c966b97875809cb62da225498b76d52a887ec145614ba7ff542f140fd69ec22c4bcc7201ec09a6b55a8c0518b95aca84ce4bb26c1975126b1d933c5ceb62b6f61b8879f7892d607b4d22eacb966281e70a2ad57b646490195ac2eb3aba696fca910eea44646a7ae22b2b2e320df6d2086f34d9f1995fdcf4edcbcbc0da416ee9bfed1b18f17d9a5f3f6465e26da2a2c151a259da4acc056c1f5bddd30663d13ef65176e6f22bf5049e37577654a843a8c608c6ec9baf5381d862be9d7ac36c7c65f8a4d8359f95db4a54b7d3ae19a34ebb48e7e6b709741d0e240cc8ca8cefcfec01f2d8acd179e554c23669c619998e5b227415484728b2ca7a2fcf37e0a9881c8098c1a28430c82b516df226d74b1b5261b0bfd2f3d240473f129407932f4c6ce2211f81d177044bf430c63e5492cf3f1d9ec30d1418392f254c3569f21d4b3050c6a562bc75da5e0bd34beeb50d6b81a19d81aaf0ec6c817695b414fc8fba86b9e70369fabd226388b9b06ced07a09e620fdbae6cabb66d2098df056e652fa670f010d809a43784893876c18689784cac17948309caee35a9bf256320f55393bc583978bba0da4643a33d6958b9154baf5e1a81dfff0018bf1442b9f94425f3b356afd1138f1a06740464bbbf5fcff02ebee56cd3b22d6e0968783b59e63be5a50450046a53cb75110dca15f368b8541c2032b4efb07e5f6edf4a0c1a3a9de8e37841f6dff2b489b93a7e3e8b302983954eb87ccdd9ca049f397e460a8ea0dca676ad10ab94a1ec7a779db2e38a40bb342df9f9ee3b3413afbdc2d803e975818f57496b87a9177e390d935bfeee3e404b8953aa272e1cba999b07bb6d069912b1e1851c25c06422c438d7a1ca53655b91b0267ed15ab2919516093b26565311f0fba25984f65ee13e031189427be5b6034404227edcc2abc083ed7ac6f08e7c02d0942f67155a088229ed735bdac01224d14cdfc3d2d321ef2e75605b38b0e376857831a2e748bb13263bfaf582bb7b76f8fa5248ec2aafad4deec366b0e5552346bab7306c191ef4f3b8f9f13965446500e1ff357fbb2ab24e76597eddb1e83716a692f1b09a40b7bd8c32ee70bd2cac5a6c6db4ce302c049ff40d760eda8e70ed1658252ef77db683467593056124a743f279be65b4f21cdf5a8fcea982cc75c29eda64044a07e4ef59ddc7b2fe26150661cbf5ceeb0d602380b5b2e7c9c36a113210a61e0108ed9c601b6b19bb2b0dca93f91f58a224c6b558093078f508551a27b88fa560b0912c30fde34800aa7cb7af4b3312ee1f0b0cdc8c81b8f9388ff7647895dd7384e7f4bf4d2b505cef01b1b8e7a42513168f9ce27e3f9b6df388ae8533b6d9e2a66a1110d8f6fc0a5b10d09e65c5330a74056e47beb1abd3c62c9241ce6253cff0a114063f33a09dada0a66219299c613b0a5b45a619b6f2d9659a7d25588c91d6d7dfc682661b2c77bcb27fe541a27d4e099285f30bd499206372edd3117324205e9ae25853ad8386372820bd5732b1b33ae8c626e544b58a0f74bc1fc8f0dd93e1f75c7f0fb46d13047f951a160eddd240813589a23258f2b05cd7a1d20fd5686eca9ef4d1e9f9ab1bccc85f781b2b5780e1dc5efd6e5629c6351dcb0b51c3e1a702264dbbb657e8790361dfd60069a9ff7127fc8ccdb9a463f86a7cb8b118f675105b13eaec04156aca5b860f9f41935f573671289357c02630ba3d8d7ab81d9b8269241a406f7d56a7c9ae8e20d7176060055e1fa3787d0fc87662dd87fe08880022bfed7c0760a77b3fda7bbc8f090c5e00097ee0c81705516c22cb02fe7dd17b7d59754093479ec9b0a260fbb6cb27e36a148376abc9ab69d7b23debd0493ecee94aeee4643ad0b36868397d87bc031cdfe89fdf959bad0ef3e7742a2e6b61b9fc1baf880ceb6b2d646f9997bbffa4675751631b9ec09d9bf88dea223e193ccb18083b1698367ec04d4e9ba3815a6d65f99c55981a3a286472128e68ff39aba9d6fdd92cbc79e6695534945389a81233ae21deeea8641033fa431cb3e3493510b980f8b778abf0db4fd2171970543449ebfdac18dd0be606ae68892e525588d129fcab4e356f6a807e46703bfea1a1cfda68e0c01cd7dcd8bf4f68c3bae0deec00e537d1f1b85dec46517bcc1b7becbb11b04ca3508c98489da9330b4d5ade0867094fa204aa51adeaee902e2053cf36a09efa5cd78c0d5ec43cfa31f22c37e6af620d04a370cde78e27fd97d45cc1a288ec12dda113cc58ad154063951ccbe93755a518c40c13d3440a7f2aa1daa29804b485fcad342ff6733840a07f5d57133433634406f4695dc9e2e28ce54481044e074018b7e02b4362c39fb955b6a7e842f143026c35ff3c3004251c98328dd3870fa68a4f1118eabd7d2179a5f47525bf064c00aa7045b4f9e77c44df6f568bc241b4365835d54f6a35aa9825392286ac5ff775763ea8c3e03a7e2e08d4ad693646bc37890bb32e1092ef7152b8097b15173b1e7878ee440e434a17b25aecfcbf6811303604fb14b7e98071d829b3edd499d30c4530df5f8150f7845a86e76e5da476244aafc4ba6c00e17813f6ce063a91208d61da1299c82ce51cecf1945130b9b832d9a49f8cec7288a4d02ad8923ce1247621f8491db8d18cb59780deaa2725d9564d5f2a4e9234f1c04bb3e97be78d93d37af7b6e3dff21b19a7a2cb929a637b9d5546b03d99675fdcf3bee50e91a83251b5a716d603a42537dd962928878f6371aaa0a17e5bf75ef6441e202dfb2609dbb09fc402f846e2023ecf7b330ac605ae12b1cd4efde58ac93f7ebe18fe8854222b10412bcb311dd676be8ed5e96721d560bedf8b37c2f4610b447b19a5083049d15915472986471a5a2395a3af60ffd95160f4bd8ee54c117f2c5955e43762d86a7cf1fd70fb22749bcdfaf3c08a51b9760a46ded1b7f44d55b10f48116395623e26f95aa2be3e2e83c6213a7147c32370f9e9c4671c91d7e6da192d4b82c79ead895155686a03b8d8193cecf0420acf104fe359b299b744d522229d939db02ceb0854da1697bf592e2e84471e100d6caeab39a914780639acdd0cc40887a66c4f38fdb6ae6a6f18f48610dd599a1f0aacd85988f3a759a65674d6ca16704490f57b7a6ffb5ab5c14e73ec684120c44f0b9d77164093ffc02cd6d13a753337fcf8c228f09e7cb3a1f0b972ec49c64192cd299897a013490f7db25a5ed21af661e46705533a567c4830f30092dd8188e9ed9fa487a303ef27387ef3e2518fdf4e044be78462a528928b5f68c96b834ab3235fd86f1d0108378fc01f4925b670446e0944acbc0524b9cc31bef0137ca7a32fa606cda14a5e25ec959d22eb08224750bc6d2a33b7b4ca99531f707e64cc9e463b7b009c3568b77781eba58e9660529d47b0314737e806c64c3212460748281155453ddffd9312ae88a705a13216cbf7b9748699f4a8a6c5613048d9af163d20869ee681c0537cc52002d155088a85806fad2b0eee7dcdda76c823f43c949fd2206eb6a8e68cff686bfc5f1d86e1e3a3706193dc7b5441bca35b47c6a12f7a059983a4f2cab7413aac0765e155deadf2a5dbb536bed2419e3a8e67e723188f78f2670e362972f20ff2795213766b831e667da0718660c198bf850f67d89f703dcc0ff9c5202e6c8d9dbd7fefe2ab1871cf2fc8fc77b478ccc37719212c6ccffebb64d689a49e19d2f7340c18100b291245f53eb6807dd6d6350974b3864f9a386cac742543d97f0bd500dbaed2cd4f3f3589967efafd71ccc03fdfe88e1285548b02b16881fd2a413ff3dbc3c9af1eaa419e44764ab65422a645b5d84cd0e21fe4bce395e042c6746be0095ff432fed9b72ad2f1d80ff7ac4dae1bc92e40ee6ae1fc9ff03d2d178237163b7a57b129cc5518a9612aa359c4df64c9204f01de168101251b27da836aef1158e5a12af1df7b4d82022d66d181feca4ae26a329ebfb1172ccb500003c88cf43ac2c7336753f5a1e18a60440f41bc254e7745611fcaabecb81b6a54899ebe978464e2539ae20a6f5303a367fb33d158d8637556baba59e3c0fe207bb29068ef7a10129004f1a0a31ee24eb87553430509d89327185ffaf0e14703c254c12e7ab2a99d42cee9418ebb7b36e60acb09c7aa8d33b5490798cc525c872f2d281f3ee694b2301c5b9242d910c003bc9b9cd4cb066342311f39d7531a50ac73a5658577f77db388d1522b0e5a327ba22725bbe582282d84e9c7f6c0549e0165f26b6f12b603edaca618db0a662351d7b5d413ab1208ce281b3f86739bec44ef7a99d4933c695d2a09b7480afb6d14c329f8ac62439d67e1319692e0a9b4e87344766bf12934eaf4de3bc71d66dec55b97c1d21ca527ea9fa573e76917320ab486c6d745ab8dabb39b59ae3e5fcb153fe46eb342aa79469256b10cdc2bdc37e09239f7f1f18290c7e24de86a6533e41f955437e71a5a5a0a3694dc4bcede21ab493fdbc907c511cbc734cad9fec5c8de555890c3ac23791a127ba0f1ba10dd17a496817a74cc344ed903ce2bcbaeda53c97f8811a330b2132ea00aeef5e00b611a0b083f4a5a6be93cc3333dd5659782087daf4eea4c8dea78882ab7b697ad80e7e55a337db6cfe61b9667c2bdeb55eb4d6032ec5e39c576348953876fed0abc44d831794ab0bfc9bc469757714c4f704b990037011a33933259683475aed821e9aa051b8d6ba939adddf9cd083c05ada8a87caa0777043d4450c425e66d23a32dd37312a08ffb241b5f6f5cb5cb4514980af535455c45a914e59f1158b40e823e1052262a7bbedc49a0a7daaf83c96fef0b69d2ef8f64eaa2128d06a9d9abfa2cbb086913bd8b7a26d14a0edd22f442f01b18953b903f447f24ec4e9fa03c86f056f5e8965fd83e1b15523bd3796df4157122de2cd09694e08412473065096d979d600791945780be53ac170cb229640f8daa3fa42118e0469430b0d17704a5a7972d3817af4b6c4767fe1e3646078826b016290ec68353e5536ace953c6af9adbd55846a2adec08d755f0291c57ad698f6d18fe8af7e093e809fbff35e9885cac174ef8dec1d9167cf8aff05306568d62e7c8474ad6934a70eb28056088dfd6d6c0c58e93bd0b48fb26e67f77c40c0bd076b908c156160aaf715912ed875d48de28851e0fda6b9dcd8a0771373ebdfcdd3a3ea89f70864dcea494a21f3c6dc279bab549fc1961cb93141c0f97076ad391be98210ce23600e88d50328834b0d00325e2599b421e09ba4ccde352effd5a2d25a03e11f792638354c4eb6869594269746b0fea137f75d5d5fd994676ecee7d46d3fc9ce0dd6ecf47226cfe2b2a120ce5191a6e43bfc1438768dd38aa8e3a78b5aacee570d1aa89efe2f3994d45ec50b39fdb8c41c90d57256b38a92e7c6748937b5a5b46872eb69099216c821477e5a4c1013843ad6dd10e5d12bfb936de615ff37b392b72aaddb71215a8f2ac7d5fbb9e5867ede92f381a49040086b4f56de1c12f1bf1326dcf4b568d5b806870052f0805f23ac481cf1f0aa648bef7435456f2668aa442638ec9ad1b01c09fe0c7ff288d6b16cb8057e961cea48956948a8bb32b48e23495d3af77291f398d7489c32fae7f5a7493685791d1db89827c512844585b41fc1c09d9ffce1b7071159a33b1fc28f97274e45a21295e436673503f34742e732cce8e9526a6b00d208c47e4ae88b842adbe7495fdfd227c0e470c1ae9112100872cdbe86cef4e906f3a9b101df5c0b8447fc07bf61d73da932fcb067487ca35957243762267bf6047d18e712910ecc409b8960a7192db3a64e146002c9d0d199be7cd91ad9e977ee0189cd2a7017cc67d8c845f8b1eca779cd4a73aceb2795dac42705f92fefd076bfde7719f024d79ef89c02fa2f37afdc01f2e5f56d032100969e03b6f7524cad58da541b80e1fe3c122601ee115998b40b454731dbdaa62f61e7c6fc14b31d56317bd8b914a2f09e378f0e5a7f00d772f826465206d1fc6360f6660ccf80c57ff0e296b8abdd349722640542c8c742e4d03b55df8615fe98609000cca978ad1ef9916da6bb92da8a50cada4d02135c083b8b30e35074570b0f1656a6f4b0fefcac031637df367869f571d9940690bfd44076505bed943dc05b16687cdf56925642a7dbc67c6353fa66266ea0199e8ae4fe9202f39f6285af461a1310724e3b4ebfa603b18e6412c176e60e4d5bb94d82d90cb305e4550c0afb169a4bb1b61b227488609d8272128ea9b4418f2c1d83fc9875612ca740c22434daaab2d5746c66ed1340bec049867329ac81d527a809ba74945478c82893d6a349b98b9fa4e07192ad1d554fb5f734c7e3486445c2c1f90d331537ebc384a81e438cff4ece68a78c87f2d1fa15c158a766f232c1ab738ed973d6d2494eafd6b8030e4bf51460982612b5d321e923d99b244cbbd7cc8b319075faf79204d3d2bb4a2725413d60fe2ca0334692fdd17812c600ef35d9d7a218d4570a04d61863dde4965847d7407758bfba3b37ebc90aa089e4e3a9b5b61b2f5858faf9811bcaddfd066f51727f90855d8a4396292383a786865f8b14249775eafc536f9c7a2d519038fd5e448d4c31ec7bf029840655a65ade1b1436336bd0e0aaed44030b979204a66577a1ea5ead758ae3be70e3999ceb0bfe39acfd336c4e7a813c218012c1cefa266ac2a5b2de2074e9d6fe680c4b1d704954582590948067996e4abfa2193fb8be4ae5153738516899061631332df30021cad3e9aa7bbd22c2298047c1daf5fbb37259eb5eb5c821de24e5169ccb829125f73e33bb67c498ffc97a02dbef9b5a6b50d8e41eb6cc677aef3f2875535cf84c6fcf5e51785a124284929556d6bc58d8e91ffd5729ac297cfb825a529500980e55279cbc548c09e57d36524326a2dc355071f5a14da2c96a678a9d28c096433f541685bfeb7e7fc933c2053f0a478722d5a2f2f54dcc48e8343c1812e742c4972929d776f8b76fa325b51af80ca5c0a5434d5a93b6be19f1116334deb31c76746015b1538779ac785e05b482c4ad370923729a544b9a672083e7dcb81236e022fdce51a46b9be0b0baaeea76e3b0e8abc772ce6a0be3ad948796b213e1fb425046c18e2631e2eeb90a9fd2dadd4849878c86c96cfc0f6c90e8906d1e95aef3032295a081e16e1b3729e5737a233c8d530004fbe9745f12d99df41c8413385dcaed7b0eefd90a3313c3334dd696ff4007ab53fe2d81e4fde668e15eb1a014bc2012b5ffd6178a56f6cba9845f7e29a61e84053d61ed9503c2d3e1ad08a3b1431089cc36def53d99e8160d9a3e44a8c16cba745f3a964b45ed7ce2e377e8c05b18295597969bc4aa9816d4f913ca95208fef1c507e10b8f299f997aa9f8a9960c96a2e5e5f3fe78db244c4a430eb5d29759a15f35ef34e8c423fb5e0468ef64775f1d51b9a5baa76e87e502828cbbb4635619fe434e2f1ab039ae21131ff1f12d6d3fb80079b4a7361ebcb0dce2be62312c67de5401948311ee68baca31fe8e1e01eccbdf5f0f0f80816418849266cc1d41de37b2a0163aae440af38b61a2eedcd8a192a6102f9bfdf4dcdf6a64501c800466fd5ab779c5beaf28f286b6fd1595ec12f1a65d68d2f95cc26f4b200106e467eb81811800edea1df6b2328d145e50887f60f1564ca94aa82b884bb209279091f9b5eb4e80ee1fb709887eba19365822e3c7aea5adb6e20d445444e74db8671cb89cf7bc430b9556aaf882cff1a76ede86e18da1b5d2005807e3403a0d77d1ed75b372a8abb2e45d73ac391c1ec646365be56d9d4ce8ddb2202628b55ec68e4586ef4cf75c39988b1c02495fe63ac43e9ef5adccb710c397d68125a1972e02ecb80552ba9b0775433b1faabb2f7fef668bbfe576b3783d4e5279fe665b0811d9a6bd97667627c74915ca6c745aa7a09a0385a46d613d7cd616a4ad181b91f1ecd17a348f55aa66ee85653d66b35616d80758c4b25d62a808785980f9a9edb015c5ef9b17b02ef4ebb88febfd3b41bfcfa57ddded8264dd08278d489567ebebcf2fd20625aabd7cf8bcfe0c20b4c3cf924b5b0f74c7199b1fee9f35089090bedcdc40a3eacb99f082d8e00aacf64f027d1a64d6f89c06d1142777af58c02fc80b97562714b8e90176c2dd548250e539232ef9cbfb35883ac538fd821be6963fffadb355115d6b3ba65624c9dedd6793722a0a1e6f89eaf42d1ca1ce9068a8322e39964342c98dfeda40669b309d9972a5d5c80dd57027b9feb3d5bc52453c4529a0bd2cd7a636cdaa9f66552ec77426231d3fca280055d4805d8642cb1fd910a5e969bca7aadd877b2cda92703534dfe0746d225d1cc19c416572ab32f9f52b36bf35cbce554bfeedd2de93cc6ad5c8f6d7e7e526c24a2de396f11f9c52641f97d72fa4ba69bad0efad833158492e46db006400de194309218fd87a0e5423a0733d459dca780a22e33e15f3c2625b65fd3e17a06f55e15fff9033b3703183e1602b088a12def24443353b2c41df4467cad96addff0e61a2f57379686e6f30630adfd7b24fba9455cd1c8ac45c073047747da20361b90af1a5804ffb42236cdcff58e7aaecf1ecaa0bbdab1dae5730f6f6da6b46abf3930b525c67f5662c502eabc3d180261a3cfceb266a23e7e5a2c366c568b2ce115f9008ee36e72d2848dd7ca131dc41c2994f2303d3f74ddf3dbfcb8e93d0a2b421f5d42979409c7fdf1ee88a73ea732907031a771cdeac51a095c0dd73f85fbfe46e1331686c157557c0860eb65c7bb9e1dab0dfff99e9176886eea7d0fb553ee3cbbe2b535c226477fdacf17bbaea240ead03479ca371ce5ec40dc449094068d9a1fd3e37734b2c8457dcdc6bdb8e9f59cbc2853407e5338ee23210587ddf7f7fdfa12bac63ab0a8bdb444eef5926d71006228d253b3546d79cde66a8c1459b5f956679762cd7035f4449cd11858631815d0f4234aa363b403f27a0eca184fc4edffe3291171c884bb6035cdcc1a223949e1431476b12c94f63001f7a9ba5571f82ef8367de83a0b1aead3e11b0cc4126e581c0064a9b9ae551c2a380a3de794854e85da0cb1fb002b6fbd5c3393db5295a0fcb2b608e8ea5b6f1284103c051af562f77c537aa50f0d0ea0c759a96549f45013795f6aaf4c7d17a676908d5fa2395a9b5120a7e61cbb26c9303fb9a8dfb687627ace9e43748a68373ce105c4fb5305899a9f00230195bb120ef72eced57623204c539d1822004dbd17e76d3c1dd401b93fa3be1213ddcc05fff95521c811bf03217392a4f67039e543c0492b28ffb8878cf58d1db0e42039c2f226790fcf9f3adacc7ba4097d009c3cbd1d84e72ae103406270894d7d14b583543e61c1ee307242bb8366dfe4d899091973bdd7e94b50f071eb114f9ddd48f590d795114d33381a185391edbff5505e276df0413b9b7c59ede4b94b8d85df1675b9c8261a14bb733e575f2b2260a8736d9233482a435434f62e8d4d9be882094cc6abd6de57d0ecfe6cb217cbd4df6bbb3554584540ec41ab5fcefba4f16c609f1c09a00bd175e28670b20f8b127c34d4ad19a39e20d5d440bc6f08891926b1ee5ab9609307b6ef4cbce4861716b25b60b1037a488b63ed4598bcb82042bd81511e75e6bb16a1c6eb2e82c5fd2b7a04c7a70013045902bd5dd4a8234dbc7c2eb5411a0191445390aa4b4184547f8e138a80c772e632d68f53bb1eb9f8cba17f3d34104a3f76748b73aaa862a2fd89b9f8abe7cd231f57d0dc49231c761fdf9537cbdc8e1629a67eb10253b535bfef48207544dcd9976d8601fb875f9250c94dd06e1885beba7f7f643277a4118387d1212a0819774b2faf5651c87568a48ad1ffc77656e81a79096497827538437a4f3e2e20063bc6bf8ed8abf43b46355ac3e90a2f9ed3e21452cfd2cdc6056956d95f97ec068911d354e3021502ffadefd35886b23da782cf13ad08db385cb03b9b06c8d9c57fab42d2cb0ef2a12c00499924345987b5755d1e241237b08eaec443c1ac17958c8546c06057049cde56027c72aab7c2857cf1b11d8b6784364732e8a6e61874f1529dd4ce94c87bf3e9861d396ffa68f709c1ea15423b9f00cc4dba0903c4657477aa3597aa97186f3f0dbba0177ace3ceec75c975740cec455b1e77eaa07dd3cdb723b369f4853ffc36009c50d2b9d5295f2e86d029c613d497f2d67311a9d7ba79979057f182d0b96d224d5fdde5c14dbce60431fd5a92a0e1708d2548f04b57b3e01325666b9416644ba469eab4f2bf7928f5c4111df46bd05c533198526c4bc5141e29bd19e899702dcd14d9ee988aea6e10fd1ac4240e2a7d6c78163bb3574bc296b6b6aca44d1ad047399c1820a381779c8e4f1ba522aaa2fa4004447935deb506bbac0869f6f98cb5c3e1667b292cae2e87d05ab9bfc90250e015fd03d1b2addd096252db7ea5dd1dfc49847a0a8442d05ccc2e4e880662be77eebc0e5ab017acc1edb1d012d602857ef0e5a615ab936ba8a58c49f81bc3adc302c80a45d3e8f3fb210f79856d9cb673b4eee4a9bece44514145761a8db405b6ee7055a5315fbe1f23312ccca97dec7293cf45d82c1900a0c4497163ad870a579bc13baf740133d7dcf0a0a3ac246eebfd099ce4db5229f827bf961be327002e80a5e3f9bf15f6c6a6ad9e9087d42f36c9e8e849e37dd5ee9a40ab939663704162ec73344f23cf517e457f451ed27f46a442afd7f08aa242627982644533a3c74be8beb90fae28cf788a71084574a8ee5036a8495bcdf9757fb3e3848933cf31daf7dd3d17723972232de08bf2a69d98bfabe375306b01e85fa9d2f7e468d03bd60d24e3a46ab2ef1e7c14b36cd23452342e98a06eae35a428a66148758507f1a04e35c660e9e8c9ccf21f7ac34837490b14efde87752f399fc8826fd8c2a15ef851e14bf89876d6cf76e09b98f735cd0be2f2b60908de5112336f7396b6ef5a1309eeefc2911897c8cdc82e420f306c474b11313314a4e77ff1eb55727fdc445b5967ade1394d3d3531a8716feb572ae795072121c0b6de24df4b4f9a64c70d3f01d20dfbedfa8fec67022704d0c45cd8b8527f25d17558e866b6213eec025423003891d52d5801990afd84264c705286ae51f7d1d2020f2bd3269aa3b2aafd9e3086738a584c3704f65ed8e07d1a0742f563a850f2a976b7b8e0a1416695751d2e0452f36ce14393d4669333f657a44e490607e411bd35996c13a4306ffaefd2bb6c1194d45bfb9fdbcbf762ee2caa83d0153e9087a85f80b26ce236d8808b3c08114e79e0989eecbd7e76c5d664ebd9c41560a6174975f477b0787f3f3660aa50b6f3dd9ad92634cfcc414862b3e0be9fa51ce74cf10e550d767e9981a4e8457e3d67dd5ae31be7bc8a80ace75542e2111a770e1e7a5290a2a38873f34473e6b391d5dc3ddc23f78b421835619646f034313374610ffe73eb262e386713f25f19118682112c6d51bf76ee3c79f2aa3a1e15a159cd00550757f86b65e4dd3a73d40eee092aa13edbf44660ce34a98d50c62913bdbaa4eb45c310e5d08641540957ff08a1c386a7f392f54a7d944afb46daaf9d9434a5de906a52ff85ac0eea3df50ad9bb0aeaaa7728891404798476d82262832da213494750ba29e89bd2cff7386bba3de8f9f19a77abb5528fa3b316bbc6e045276590e44810382ee343cad80b6b737303fe74c936d9fbbc0794b317a49830c7071a6138e4ade784f2b95aab8dfccc67b1a5a1cc6ea2fc47de7ba87354b2052b571f26920af1b3e90828316928276fbb638f1388be032d2ce7acfe528009ac4c5afd3f09432e5c45ec5894109fabbbebe154ee42ab0155b2fdfc0381613a5e06c80b9b790fbef9ef335d1b229700318a0c06e0bc7a48415c2a4b25025a107ddbfad9db5ef75bf23dc404fcf3073fb44f319dfeae3ac70b96154714115bbe40b290ceff6a0ec4d6705cd2cb25b4b56193f8e1b44efec310e42a1884ba63b04782d89abc89b1d9ff3a8549a3895a234cf8b3044c43f8b9eef432da76acf80f7d51d1308fe27402843055cb26f61ecf3db24ba238e39b4f230440a9f937e14e1c10299310b9ff3513e05fec31624797a0029ca0fa70f0f138de256be5d0bbeed85a75ce296c86e867b1adc8cb56b6addb44c0a641cb2069a48d639d2654433307aa2a34f0f171a39eed26b4517ca7806c118caeb2cb0cf825ee98c5e88d3476a606a070aa422398d4de99289685198d80cbd522eba4a112c60dd6b885efb5bbad19779ea3d38a104d7ab5ce86723a946903a2eba3a2b04a0100f2a2c42cf1010e26878695783c31657463a271a9694d9bc9e29bc9683908620fe5d74cd291a74119469328f87e09e5ecc3666f091d798de233c21c05c1f53c73ca12a1be1cff0f7de130e832a62fd61f6f9db19e4fc0984b1d7df17469bdad34a17937a67ca32b548b7a93906d939dd18f7ffa465ed3fdd1251ba8b6c9b1617a5b012e468a8ed61c9811f01a3dd601a4ae848ea08a622d4b350a9abf779c58b037bbdc697363d4209a24843965a92050a2d9e7095eb1b7b2f36076f0f1509e1e6a1aa0f60f0da80c7f42757cd5a12d3c88312e1d0ff8de737c852e813f550714c56b65b0cfa3610d3cc855d757daa55c5c26e141007ba99c8149f3da260ca040a4ec95c8c29da3b011fe6ff5168fb6800435fbefe236467ea4fe29f5655730bbe630d322687e92780c768e53c2d45ec09e7de7d8280c967deed40c229ad4dd5267f8d61d17286351b662ea65b95ac9eea70cf6806466fce4f9408f7df3a7d3964e049e0c03e0b3ce3d5a48d6b3f9c1b7f3b5971e24b74e5367494d2f39ecc6fc28ab1c76ab63d2d20a521ebf3ef621c325f2719adec9a8a54a9db872c6e0f8451575fb55cfa2da6a3f33c075afe2b1e475fac341f5b234193e43c41428b0ce948ef32cead77e0a07890739e73479c7542d31a74c83fe5bd209ea837f82c2cfe6a5e37c8d0698922f6020ad1dfe6577b34d16cfb2deeef7972e962e582f0d2f208919b3f1bc77b5a7522618c36d072fd951597d18172bc81288070cd7530368f573a9d01b554897136b2aa188c6c221b2f9a7832c2d3596051a898a6079d88abb56baac94afe8b4107ed98c33e3d1bca7311404fc14d70ee7dc0288442571f2b3ca031a12cb840dacd429c6cf793c3f0827fecdee04d63c9fc3e5739fafc09b97069df06ecab73c4e059d9ce4b902e6ad11120dce9f215e019117dbb9b306750ff8aa8a6f66945b94c417c8b866faba5be0a7141ec849f0ae84d632e1a96e18480bf90f36028c412131561ee361ba1a051013ab6d918508bdfedfa1531d02a5e88a2c89d2cf7182193e180d4fde5bac5c6a143181c58184d6b676fbc118fdfe8de84e8cda1ba0b2cf2c75657441d596728c19e91ad2d282baf635cb28f7d0f1c11df218f66e9a3da7dbbb4f22c60dce1d07317786cfe67bad456cfc58cde861b71064813b243364060beeb44e3682449e3fb34f92bd08bf26205856337e141e1d13a3b9a344a3526f872fd3c199230900690219aec751e26ecf685dc4c98410daeb99556b825141d93f2e015050d586f0135683d3d450faa6b5f2840d43515c32677e6fc6018d8ec37b869b98c9950c66ad5ec50d50d8553ed7180feb156711574df9ded3b3ec09917239c665c946e84c6cb3ac47a762985ff30179af6cacae1254531b8414028a5e78dc2b40b7d48782a8ac84488e7be9f5d7cfb6d3bed4668ca8149d49d54930429137fdcba217c2fec2606c693c04e0744ac3e8b514e30ebe306527c0d323565ec0ea847d7975539d4f7e44fbb22230735385ef032e46adec3a45abe42fe04e2522ab9ba9bfcf54839a46524e0d0237ab382e570d5d84298895095074e6702dac406ccf91aa2b21db478dc86e10efda84384c8ba44b638a3ef7de346749eef8c8db273e0b334a16381fdd68091ee49047c4fb712af7a76bf8242c2acf5034f2b72f69839cf0be704798e982031b9d329997524d3d0a70c73449d48ab6f566579a0046a0d39258ced4fb84289625f5a93f0d8ec5b5b2adc9ec49f8fc2e6921006b1cdbc48d388f587536eb841eaf5886153edac995684f0112204f647a7e08bddfe02cfa07333d928b275a38add8ee28e864341daae15bb311bb2c409fd9b1795347b5af92532762094d986b16df9a5fcb811c0d673c0e9d3324602e30a978a0f9e724af5fb73d570b87d73f2a8e133bad85cca5e1d4b1092a8b7a4e6055536678ddad76a209fb02d4275f8e81dc21ee7e7ba9981dcd1ba4b3129ab9de142f5eda01d9d0e1cc52f62586f05a71780f76c5ff0577f9738f18a14943183e320a686d5912287dd3c7db08d08f0a76fa69d5bc87ea5ca10229d23689095f7e32bb34209284d3602a62e72aea74920a1013b277a2b677764a992d2e0e177d23e2b8ad159420db3166cd17bd5b5bccf78ea4e32f00fbda395784348ef7a0bb52758697c940c086dddb8e4fab59bb0166a6c567f66a1d5d07e4080565c2773159efca9ecabb1a8ee71119ec4aec79c6ec138905f28d15f927a6963abb38521c91db8b03ba794d2d68083585a94338644750e12a573d0ad5b7cc531299adc196978e9a46117c489bd36cdd4e68fca1c4171934e40896ef7084c85f55fd706ddce4c2063ea9c7cfda1c9688a59c6645a49ce9f214135391ec2eb05c7763150691e6f6a3f2073a5561df021e974a3436ca4ff1d5e647ccad6f5827d64b28ec09250407404856a430f86595b753adb998e037b6efd3cc29f035290c45156e344f65619ce430cc3f217ed895feaf9bb083a54c54d71306ecb2b6653f34c712b938cbef020d4f85f6277fc21d73a69af43f99132527fcfb0f70bcee5193f54d58999217e311013e75628332c3a5f78e949577545d8913266103435ff2b70b3579171daf65462c0f6cad18a2c4058dfaca45c36aa1a21e5391dcb1a96a3e79cdcc2a62bd17e5f29e18f98f3e118eaf10aa125f396091e5cda3bca238c1838ccada450f654518421a45202a4ccbc7a88776cfc6b4ac336265ee5c577fc8d005540a5795cdbce32ca6777a5bdf9e0a7cbb9330739983e5fd74b3610624f620b2f241e61d7714efad0894dae92f26ea51a31429763dfad296b2f7df2a9399205547796a5552e175df3fbd0f0fed6d4ba0807469c7804a1dd02d64026ce9885dc931bfea04e793add7bb882a6a42210ac8c102d69333dc75f6753bd0255d7f98f544f09db013a20c25ec313a7cbff3eb39948c42b1888a0d5e2c4c7e6a48a74db395f35fd3e0115eb8db3c5808e0568c1b67cc8dece65ad9130ec633553b1897ece1fb0d0b8f1be17a89e6f05fd6e2a42fbc0f0e28fcdc048195503f8792b0d32da776ed3bd4d03d293e5c1927c9fbb22285daa1a4c6537f33c5a8870ba04a01d5f41976fcd98f1e0decc7a3a1ba533033bb9581dbdd87dadc917b35cbad90e9cf0436a2ec18de163304634ba3f95b9b8536e7eab15663c551efb4939fe6fefc639bfdfbcab959ed44193742ed17aec0364ce10e5707360fa6b70c1d608386676e1acf95e56855c6745798558eb81a4c2e507de71c919a6b60ec0b2181c0deecccc7f1c223bfc208c0218637c14ef69d833b32d17888271806516ba538d274afde5b81576692d7e9b1600019739a3ecf9d8928b4ec6868ee8540d5a0316c82e9056a748115cb0a14b00b772e9246aefd5f7aefd93d24b62b2834df0c6c4db85b9a7ef2c151f867414a5f1e2b93b42c067b2ceb809bab5636b68acf24611c6e9f2db9417b0a4c7514eab59b4add74acfb55f0cb7aa2305caadee3db2bcb2a024181d5303bb7045745ad25d1a1ec484235012f8ad41fe787f3aa06a2d7e3bf368f87a5746a7e27c0d6e71b9eb90a9a33f1e4ef8b1b9de8420320fca690db4e05a5a46f6ae83c154b7d146f5674535b1862cc1a879c3d27806be320525bc241a93d018898a642c370729f432f92951141174781d79c395b97f1548e5ee1320c58a1801d4612e20cafff52c183beab6f6d5726c7afbb4767c8162aa96c563bb53c70001519356df75a51a639af6ba719d7200036f33ae5fd7494de99949a4632f801224d658ba633f1aa73a3671a3b9a4d374974c0ae6231fe4e344efc1b6fa9569418aa66215840521b9b3ef7f30175be67ce7b31f1fce44cddfa48886ef8e519fed166de3e9891aa057a17c5043c4a3bc5ca505f110da268281bb5c90f53503b8ab02340f03029000ac83cc27edc0f6f1fcb680f63ea6d02177ca99f988197c25022161a701bba1affb77a0780c80424694e2c9735f34b0e254f5ce78d8ed00be8bcff972908b2a907d6470538d17b17c23efb00e73f8fb916887aad6dc97da029fc1585cf4df48d5de7acf785f7e435f3081e6e313efe36b86823f5b30af9e574d40e06fb297aad3c66342988893b3041dc35378e80364ef2401340e538ddadb3b5483597bcb57849dbda0f7b0f2aaa272d12c5d966e030fbe590a7e7bbccc7ea51a7ee16af7e7c8c4d922a3fb0d2e49b36b99898081410d8b973fea4899906c43aa73625f50fc1706a0e5a9596ebda946729af74d8630e80314a30d0e8f7da96a83eec5c8c8b70aca50eb4ab3d41a0b51d17aac420867e0e0059cbe1f2094e68c07283fd4b76a765340216e5257e6b8f8b375d1011cf32d8f75d62d323a71a4031b5d706acee2063503d88572ae6b5db848e6a75dd7fcda39c6927ab0610aee8acc0565a7501735a885d1d30e14eccfed3798053f7b710599f44c69573b138aeeaf81fd4aa0391ac63d841a4c950ec26419bc634cedd2f7fb4a01375844b0815600d0010b1832de93270a1f6bbecf4566f1eadf81a0c24e8f91710053913f6b9be64dec3d793a2c31dcdf408d5b3db993b81d1fbf1220e057a1dbe0d0c58517c487a263a4a6f1cb6c7c2e5900ec3475909037b431a412d62a60d6cb477b518790b3b1886ec655d5249f96f36b1e71ca575c56251612276416db7b963de7c5870b67dd83f3ada5d0e0a5f6e041bf6b7bc462552dd39cff66e667da20a8809d034611f8bac5684e3e52e904a3f68d739d8bd226e0f78dbcb7d3d4a18e318b5f7d8f11cdaf43c094e9593d4fcb9ad69a0207c3c8543908104a1218c66db151935548698ea17322b4892c55fa67215559007f12757e38389901b7980cce50c85bad283e05a297c564ca61201ba9a585c1560ffa458df3a47957cad9f81f6800677e97363129fb8e2c4754fc8ff951b386efa1b5ffa9ae5c9b8d439824ccce14c1cf75be8e9cbdfdd6d977a00f533998f2775f170613716891386655451e127516b904c60440abe9289b6f7689f42a8bf0c3eed3a89c01446ab6ff36e24b0022b0a3b0e39d74c3a5eecc123eede02606c25cce07c20ff63221aafb9ab1cf0e07c18f2d61c4a8f9e4159b22dc983f93f45f9b029cdf4b699455b754ea04eb5bde895b2b6aaeda28753fc7b5b5b1be1a02435003fe46d62f245cfacfd08de32fbd8114c9de15a713113161065544b301f1abcc3a726003a8f3c300374522c592a33fea104d653817c901f4cb1b1ff1f7c5f1dcf44893d41c5b0c9376f6731107cfe4ae632a09eaa0d226d00ad1f59cc94a283d4c890f859366eec6dea43818f0f7d16ecf39fc39f646ffc0752295b941879a912940c7ca7bd1c3fa88630e0394d5073271463ab4f604a0de476d56ef1b25fc772cdaa58f974cd5fc1c365fb0a072ca17b6950f1e1be22cc66df88151539251da0ad50e47dd1ff0090142fc945bf303fe209dc8a0eb42c3a429ccde5490c83ecb63d8aa36651b0379bb8ffb895a13bc9c10213776086015e894e77624a8c56a0b15337d95d5158580ac528966b300010b942026948da9f121ce475e2f4be830881effaa37a029d6744aaf995dddc2477749ca87d2dd86838cee7023d6504be2017917d2eb7e31bf6ea39741720801911372502c1a60f7aaaff8ebbdc5e8c27606bcbfe78be05250bce0b099ee77eb89dc29d903d8ac15048039600b46fedd1c4e205113d6d815efcffc389548f6752004aeca4ab724599b3de8d6473f955c99504f5ee9133b87e438a4228f5ef07060271bc137f864f4c739d8e68728821152183e03151dc39ada8a0fd381790c482998e8044c9aba67962bff8d1f3ffcc6bb2470782d4d7d9b7c842a8529deb81025305ed447a3c11d711d5211425d6fa4c9f4efae77d8f7348330afd20039f8c7722f29176b8bfd4a751a051846d583c2b111633e8c40190af5e4124a9b3442e223e3b022fe794c4b89102a02422ac14dfc33d28f45fd92574b1e28c60cb1045a69f9619bde726cb8b788b5849f9dd3a43503be7fb1d82e78b36a28a595ca49a0b08ee4126f1f27326a0b9578574350bd56aa5ab51b2f47a35a450e99bb3a215ba0b61d17737e9ee16eaf9de01aef74838d0508892533310cada188df123eb0be8da3af04bf016a4cdaa0ebb9dd6119c743ce76e61ba8e3aeb0bf82756725fd365f9c4beb02cc41cf654dbca2260885562e9f280da89bb4658626481fe869cb5fe4a49ef0ffa0910fa2701d327d57504d6826873c2da7a830ac3241a2e4a701db8470df8c14337847e0cff64c02619f7d3fd6b6ea32791c988133cf308d6d6a0589ae0c33766be0943142e21063767f0aaba602fac62401f76370b63c6913087d73d56d28a2ecdf8bc902701380a19973d587bf6d30216772d8b5e1e98ac472e551caf3a7ac0387f527c3c15c79b1b62678edd39d212c8479b2d52157fa0011bb110c3632a747c896bf3feecb4a9b2c2df151d406de7bbeb82cde4449b905ecb360117b9a009626ab90535435219571774b19e49cf6376086e42eeee871987f7e249902385554d5fea030b9ff64ff06fd82d2d9aa27eee7becd2822a16e154107ddd580948ea5d604890b508a0a48e2e73edd245c7ec1ab32ee5eb87365197736f400b95e601efa63be7cbcb7ae66eefc31dbafa7d707318a130eeea7ac9ad7187aa089e4aafa6e29ea91a8a3e08c8f24eb4ccdbcd4e7d4a013e5064853649c58ddb129b9d40bddcd689819a7e0765e6d59d6f260d3f4322177eaf1c740a11ab834b835dcf93174203e19b5324d21d10647ded44998d99b5a289c342646433c633c1401493c027300b82ec34b945979cfcd923885dc68522ac844d9d6a17cd815a8a803f544c1bdefc059476d6417454dd7c93851c60e203d9e73bd165039173ff7d759f6aa9d984b683cd1f28405f90cac08f23a67bf0b54844f4b5020c0a9b1f230ae9a97e9c13bdeab2e20f29169b5400e959c59f9b36ab164bcbd7f835ffc73ee8873df4e8a7eb627c1de9b02d943c44feabe964fe503ea8f13d4d05fd2e9414db74fe04eb6f2132e1e92383b2a77cf337d7bb69d67460433ff85e1713d4fa423c14a6c677532843913ec96b3d033e00c2738a33c9f117a902a40f03febc5f45826f7adeb5f2dbd55b8c9c408227d4c5d0e9dcb3e1cadd1b7f526fefa84a0759a51569936a86760ae4ca3acac3c997af487afe24738360cb7d35d2d5272db6df9e9792dff4fc706997c68a312a48e19dc5c00d42d208666160c4a52ad44e1af044b1bad09b91fcb27345d12a8624cfbb1972123a634036c2fe2561e19b5f834ddd2a10ca7db594cca5aa67450efc5fdb07d9c419940c9f3835955c77ca9c84a7f696a25ee750a877c3c6c673634c4a6673bfb33e90aac50832c7c1a93dca648dd0d5f0be5cf83b91d5761f07b4a739d5255a8e61c59b8d2ad30c6ef3c703faad2bb1202901660ae3eb50c021612dc0cfe77fcc0736dc4cac423f942296eed67a519b4de86e1308eff7ac08863786176456bc72ca35abdf7feb5bd3d4f064211095d0bab7499babab5baf2db389e9127f10b1ee172e2d7240906bd049dd36ed7d702918bcee36cbb014486a98770d84d560beaaafe27b8c0d9af50dfe81151260b02b854fb4ec331d554cdb9a8895a9d2ace835a7f8268aac4226a9432d884a585a11fc898a3dc01476ffa0ade916e37cb42eeaf807c8ab7f613f728e5c7cf4965aa2ebe4a11e5c50dfbe8d957ea1f802538924c212cab769838b9a5ae53d54d7016a0b5003918699dbcaf7a186e32b156e9e9ed8cee6d382952cd394b6d570f4e658eb27acc3f93d34ea60ed603aee456959aea71381a3d3c3b508f8d46a0bb952967b0acb7881928e1afacb9d0b83f40aa38555eeb91ffc2bf9e90981f5cd455b4cf2f4bb754f87eec79afe0cf6f8e33845fa507cec8356835d191e1b46d5cebaf67312b59df54b409c8ade6cdbf3ca6e9c1769bf01d9a564276381c2ef24f4d2bfc7475f39e26c77a6c2a85b85f4b2809225fc15a0c30ef28386813c36050d5efc3408b254a5b8bd3867a52fa56c89141aa07aeb9e451048058130406cf24815d63f4e77a3640584e48db16838270fda013e4709df6010158faeb088a8f43f665f7991bd944d625b991f76ad0934c9a06a6b8bf4c9bf27b969ebbb0dad7a56dc579257b624e64d69528ee51f05db6546a577f3ac29ec0e918fba9696247116246800fbeae8a46b0d41a727337f75627f1d6649a73ccc377bf7dd23bc1d0d1cf8b852856b24cb64b6d8ffa7348fd1571ad042e72c6f7f904ecb7fb2dad6cccc2c37ba133ee9d5076588aee645316f561e0c7505e09d69022aeae397803e8fbf96f8d3e5b659f54de2f5811a6ac751e8cacd39e1a245054b0059354074e6586fff9239e5ee03ee70ccf276df03529733036aa6ca56839ce757fdd73b9557e5bc97f3ba15cedb0283c351249952be42af285badd9061fda4d5b5dfb8f42363a9db775dc212942560957c86c7ed77a67f7f76a44b3b0773035674a2b13841130ac7f01f2d9913d1c39d49493806379de52ae8432b284f1aa6a4f3b26ad6bbfc41dc2f8354a103802d5312d6e2b62ff426635079fa66b71b82622fd9b44ee387d75041558f7ec5a978dd88e7bcae5be9a15c3762166118745dd15af312ca313e3bb017bc5a7e5f616733e65994ee959d8af5e2eec9fb53e8eb36b554835c8fe470e0a51caf439fdbeca70a3d12a2e54252ce4115f8a2423170f4122194e277b2dbd4398151ecf54518a82fdc2d2975c0e2ea7f63089a5cf6ad5eec877a095cc9ba72e96bea9bc34657f464273b0fe7fcca8e45f7ab114a502a79941a27ea3db92e029f53c215bdec2af1845e70f9d57689af555ce27dadb8d46d822235f4c2576e835c0a9cd035204c32ece0c5e896b144c7c8f6e3b1a2fb813e731c01b3eaa5d1964f1b1ca850bddafdd0daffa330ecff80131313d454ebea5e3caca25aafdd18a6e927133601f069341329aa65df2df4d4cb42d1c308662c00e556c4ceeb0ff852e91c7374840a530cb43759330f19f9d1274e8b82d642c4daf26aee34fc7571e893866a126f65fa6f39c61d0dd737cba1be9532db2c840d293bbdf7b65f89bc4a024c7cd94bc5d7640cb58c52f14c895f663d9b3c365b3273793b4686ad574269b73239ff4c109a1a60a6cffd81c6ffa77690b960513ceae55e0ec1df9ddaa57156605c8743ab1c9b9fd7aa1db7e94e522783324c9ed2fa0e2544f0d13b50b3bb3f00ebb07e5e3d12e24f4662941c6bd59f453cbfae1b4252692afa9780ae9cfd8ba8ec447793fdc9d2a9af24de9e2f14e2bd3054fa738cba1132d51adb76c658b55648cbba13109f2fe6dbc3558febfe97352fe0a1e868c44fc112638421eba231e8177a6d33ecbfdcc101122f9be58eb01bb909b06f99064dabf52c24565181bcc38879817604a86b37f00715847d544bf504425f545f11134d0e6e4b494dcb05347f3370d4db13b482b1b5c34211262b23ecb0d56c666f572b78d077c59105f2d0928a5c8e9ad43784b7849074f537afcbad0cdbe7c121a9c969bdb0eb59d97d6794ad3b476debfc2a184c4607ca755a2c3db9d089f27f35bb702e2bfe597f8ba700c2b68e034b06268b63b5bf6adebdb6299d6980aae449f9f30030db7b81339b6c68d0b3c9eb45393e8255487c84f6b346e6e5f150223ff2c86d73b9d72e16a58cc3946f1736288494a7dd557369ef9dc7aaffa007c9db2a2a76a65467bd948310dffbfb7c1086c0d06bccf95f3e264d4a367901a053e0b76acc8b1d16c32ec7727e66d13e1f7a0f76a2d444490572b08dfd70ac851650ce5ae5ffd98d29122a2e6d096d60e60d150695060bca68cb817c149177020270ce51fbf70138fbdd9a8faf4d4573f10cb0a2280aa13a351a038cbe2975d2306c627a03b51a3e11a517018f31180ce260841776f13b41d0734fe3f7611938e909f9d1f989c9b98592b2136aa0f20aa30b302c2a894bd4ae2c0f08a97161470037a9cee57aea814043cf41ca303115b08ba35734319c9dba278e751dc7579aae181bc2f2027accdf526347bddec5f882ae7f4e4f1b54017933713e11751b89dc6766c3e88e3da1b86ef5b273895f8b21d7ab49a382716b3ea80df0bb3414d7f269367aeca02276b257438de06c00c7f02da4a3ecb9ab760bddf48e1231a498edb51f3ace93ed817ee389ec6d59b4bc4b65ee6d09f85406fe68f6996e9de522a94ae140fe8865dca64e99b7da188de6277bcb5730733db88e28b25528857f74f05062d0f482b6fa5e1092f2cea24bd1b21b5b7cdfbf86432e1db459890c196d8131930cb957d103104e2cf5ca3ad308d17979d420136f8668e38687572cda7db47e31ad50557857b1848a49f2b4573bb601270e19136dca097c1ba52f65ac451cd21a2a250ccdf2fe2bfdf051e96ee23f363ba41de0f07c410ddb80ac308807eae7431c84d60e41bdcec8de7f8240a24644efe9aeb93372e9ad7fe926693c8c6b7b6cce059aafdbdeb17f728bbbc952203dbf183d67b4d6072e7953ab41d9faee102d59fcb53af1a3a79f8507fbdfaa6ff5c03cf9f6bec1319dac1473d044e687908f8cf56929908a3e1129dcc198e290cb8fd77e215d4411c9bae9d2a38aa754f68cbd76729ef63f193f79eb9b5a18c6ba55729c42a0af432e15b1f59c63660a1b32fa11032654335c28e2ce8d1660b0e695cf5f0d8d2c7a8c683bb08f9e3d209522e139bbf13cced6db15ebb03218cdcd393ab2e12895bf5a160c25aae276be852ebd8705da462ce2f62160cef78930ab9d2febd42844bbe80c16d0a314a5a7417e2686a555f6e59d6444087062ce7f862f3c3d63689526e75fb75968391b8f3df6e47b46bf0a09b9365de696081817c47a3dfb33be4ea44d999376e639ade3c5610a9423773e07507e4322d1a9b313733f4422dca50b675d2b10c4df01c85a5859169423df0dcc3bb5dc31c1ce29dd5f04740765b9e6752a930d886cf423d4804194f17f3cd3d036ab7d6304ff262b0c09cd4770bb313f572763a0a70cf774b77c922f3c8f32ded9e23573504f37d26cc66e235b6f1efcb7c64b489a7f7a26fb047553043b839eb679f2e4bac6204f83258dd722f64376aeb56d7de226e9e97534ab86bbcd567fc21fc82b504bcd3ee793b50ca50dc2a03370d03eafaaba346f522094f35764e6ae2e919564372e0db26d514031e436bafb0882655b3daeef08a25b06ee2a49b5c6411fe9a456ca448e3d1ed11b06996d3b4ca7650d9bda0dc717fe34bf10fc776074e293356b6af1adeebb5d39e0620cdf6aef2afffbd17315b929f81dd614e8c5a9da1c92dce494bf63b1bd69fadd6d8dbc916cc8e2733d5359aff2ec6995094b707f598763354b1c50227e12af78cbeb3ec748b317c9bf6d896fdd66e1a799556bf061831deb951d2bbbfeff57fc106491acc6591017d80b04226cc8ef083421c280e14bf6c8bdb2aa247b666ada6edb76c79095494e31025a69dcc51bf083d029ada229ae78f89aaabec2bb3493ff01f30054a3ba9f1e196a2d8b19eb6d036e193895c566707bd5ec1489fdc31f627df6dc90bd9e27f38dc14c2b4dad9390bac3e322cb164b4b82494f25f6f46a9b8c78983a4fe8db9ca378a0c0ef628614ba477e36e9c41fea3d7e4955ffddeefd9b9de185ba5e3993602b126bf6e1fc3debfef5b28f3b384b8a6849a6b10316e4bc00269fad1a2fd0866df7479164e98d83a152f6d7573f5aee76f64b7ac4b3cd908c5d42f04e9253f398cc73b25fa118bac5519159990f9f2ea014e9df94a45db2375e34076a533264af3de9fc28813661c9efdb561768ee247094e34529a1f12e181eac4ead00ad1b46658bc3897ce019e77c119cc000405b8cb0b1038098310c7a25e518b8a9bbd54746e65e99e70b6a4cc1dc1997b92e93ab4d7fb6bf1f7664ac9608ff7afe16bffe80b1b4eb57944835ad534804aa48a61bfdcdc72e4786413fe9d8d497915c848940e3e4d68b0f248d68f670ba1568d3395948ba1f1f23617dc780f0949298c9539aedbeade129e9fb778d4b8a162c63354057fee3312ee998592140d330357742632214e7e01ed29f4ff9d584ae7ac48ed154fb3e0b6bffd50aa664afeb8769b6a8acbef8a7a07add7453990202dabf0ee13ac8aae5a0220774e773e93788b14e50c1e9ed0bf1d03a1ccbfde97ac81e583e09a312618c0c134747fc2f554074235756f4152d627fc908326562f26f866e5ed4ce80b1c54659856ce1f4cdb1811766b50a6458d57957460914d3c0d2cf5a8c3612ae54a927c6996df37e551f52ad4f65d00b2297ce7b44312d65da98300af3952d49faf5492b249f0f37e28555a638f9b3776e6e15624fd6368bbc4577169545f19e881267975683865b03142f0fb38d827df42b6fbb11d38a5fac201d2a24cfcf9e1b10fcc3455391a3de160b7b5a2bc835749a0127af7060efcb5589fd2e87674d24b6e36f34a46d8bd4c2013e3cf9169ec0ceaeb47ed155a48f88c4de65fa3213884027dd9956be541bb2afa85f899af760c829c0e531503a9d6ac2897216770adbab718982914a522c6e5d860d7816ca6769f2300662889529bc6bd4c7d7ab31944c86912fed662e4289b02cfd5c095657739d58f17d7ebad7f69a338c360b81e3934113da12d3ff1a2c5deacbc1e55dc3ba361bd0bc32ce8266a1c6124eecd7847cda8ec3645f4d96dfa0b9b1e97b322f74a6d6c2e2e52232c398006978f9cafc8b8edfc07b3f7cc46d275929cc98c1ccc02b4169b04e6f627201d49477eae54bc467bdee9cee77b0134fc5710b8fe8fb780e250d27d5dc050f37411e7c9eb01e2601de9f7dc4763ea67966d930ccc3bb22609b5e0a07081a6c507bc02d6add5bebf66638d0470a07a96ac36360d3bfd4c6162beb82f0f6bbe4a4368200f216ee0ef797fbb22909a0bae45128db68cc31f078a297da3aaa7917e0704562dd1d37b693d3ac06c44d5de66464533083673d273e13e82d1af662d9e727d43eef5d11c2ee96b7382f339fbd61193447142d38c7a289627656c1b398149aaa11e92c7aa110caf24ae50e7f7baa23dccd1a527e4cb9d08ed3299ac25c0f633fb79d40df4720444e4cdd73c2638f66bc7e1edcb06ef949464b1cb0bd7e5a246556313516c1c5e2dd507b9378c85c746480f709ca97ff782c45cca79314c46290f6441ff14b4fb5ba1bed69784938bb38ddcdad72a80daf1c639278ff2a14067ebd877d3d437c6155f819947733efe69981def79732fa5c8dab8e996c7be7bd2f05dc8b48f73ae3d1d2ba92723d0d019015d8673c9b8da6e957ff2d26f7e0b89b275a38465a61b6dbca24d75f2da876677e02318e17c7d0850abaa7726041e6fd8f8089c31950a60c4a82b03335382c430ca126064941d488e2c0058e581ea7403d1d10d75a81750179e178cfe6b000e376ac276a1624b89fdf90c693d7e2897aa5961925adf51e1cf5d52c3e4777a40205451becc3ed971203a7590f66496a8dc1d9c1d1b2990d6b075f5e2fb473ec2cf4c28fd7d2207b1ea932db37f09e8bf7e0086573a1fc3973482144b575e362ccce8803b91f04e1ef200c0256cedc915205e47b86a4cdd6b72a741f5824a473287551dbc37421348bbf63e541741c7e70434da307d9574dbcde1d4c3a83ba4ce53fa84b3a81ae66e93bb6289b96eceabd8bceadab2925152f1e5017c46e90acfb1a8f966ec1cb3e99af883ab4d893633fcaca1a224181e735c0026919ad79e02595778b429cc56dd6ebe22f4dce67247758b9fcb483508d75ff835b22e4d2c47647d91e4ba44a2ce4b67b7435fa8a65e72e68f98e6692697fb769b3a5efa7702152df888ef9d36ce5c41397865f62ba9853403091f5eda1e4cdf0e1ea5de2962588ab345faf2f1d66619676ae37fb92a6ef902a3201d6c34978488804e729c3092412ddd51f0bd7bdfc25d900a565fdbfb287363b736c105a8b6ca273ba0d131a6902f324c71243f6eb42ef49c2d83e68a3f2e209ccc159ca1250c7c1457596f29521885164887e20c981bcadb3bb6fb3d6a66fcf9babf72985245b9af5023ad07729c4b12b828289396ca1c3677f3de538c4f91793f04156d822ba66c550db6678859c3c79dd195c8cdd6f34d4bd14cacc5b08bccd910e87db9299ddf181ce137a640c1b09a4e9bafdad503a62b8ebdbba7db24ecde3e9d7b31487263b1c0c0bc5468dbdc8723b6d0deada5912b2fc03038ceb8c28c6f468ba4066ea581a67541c053b7b7ad95b2154f2f7a4ad74ccfdf413a24766dcdef1d3169ce8ccb1ff6a2af5075f757ba52149be1c64f095c579481b93215de314cee2eb6ab73dd74dc4b3e2fd8f6cfc8ebdfd92c8bead029fcd4ff1b9bda3ed938944973c75d47e07662d01586fdb074dd0c6ff60b8eaddf917161e524a616b2b859fa00689d150743742e8f9c0a34cadb29fea1a40c127415c0ba07dbb225f7be59def6eb7a308feef7cc44a7476ad5cc2a77832b6f18d05f3910b9e685c3df9f2c6d0123b18685a74ea53d8817ba69bd70905f49c4da3898f9bfca513f6f4b1799bff1e0a98519b8cc6b1a3ffda0ca5ff1b6fb2b2e0f72cff840b494871e80832bc96fcfeee89ea5e53885440ff4ecde90f58f774bfdc9d3f15840b843d75801036dab4ab20d01103b1cdf92d6825a6e7b54dc1341ad474cebc064b7827183a6ad012bb80539014fae9bb991fd5685ca1d13101ca7110d556e2018211c9381a156d7cf0e9b93838979184dab18d4bb94a7f6034fc79976b9791a44ffe178dd234e4c8b3bd010149c1bb07b6aca189d99b2b65bb3b4da908948f63795f5d86330797c3d12ae7bad72829a736930273a31445632b32a107b6e40b587bcfa8a975feb81d921971df2d628919e9e08f3f022756781bcbb6940f60c4dec6304519734c497599ad8b1946b1eacb9a314ad2f867461d8d1a248fbd3033b375f888a5aa7bd720ba8a56e6b9be7a3849ce333e9720e67024e138cea84db546286c0c62bef5bdb6393728bf295b8efd178477d85f7a553ad31210da95d71656cb2e1e935b579ded99e672ae630df2f37ef0afc5b4d3e0a93650dc121bf2a3ff6e166a05732ffe51912ce2df0ee2d37f398803a7d88fafb4267ec7764687cd0235b00417611868c7b0d1570b2b9414744a6f1bf70b7f762f78c62c7e57cd361b06fe6ee8cb1843875aa775b2234186131b76e76a4f356af05f1cb7ec1b1fa8ebec734bf99efa6876e839afb06563600b28b04fcc6c267a2a250eedfff967c05fc5330c387d5e88874fea06f6a5114185f76a143b190565372808ac3cffb724e85f5f06adc5ef4467a739220b025cc55987b535a86e7e20a42775d9ffee6cbecd921424ff7c9c4205508fb2c0848b81ff5ebd22fdff3c98c42811bb1fceea8ed14d30c4763c86a0ca4d0eb2e0b967c0c86bab4446960101a1401102bf1b72ba4a12000db12131a6a52b2daaff63420dbbf7ec5b34327c6b6066efa88f1144748a213a461bdac8a325ffd49c44a662288f3b429783d821030ba5043bf5f6260cc83260ccc9fa80eec65189d356b2bbc4d6e34a20aae0a7a7e4375467843e6cf216395b9d469cc1a5de6b8826755235084e165af0f7ef3d6dbbf9431e502d201f88b193ff51463f8bec12f7d1ca22a00cf9dfdd66fab93c413eccb70a68f6f2b849bcc453a79e9a3e4c89473e05c9da7a031738d94a473eb80118c88be7d97854256c3b8a8958303eafcc03e7c52740ece204d948c90fa7d01010abeb6e1d7ac70b07aa4228719d9d5e0bdcb559d51abc57541fbbb17c56c7db742ffe7822223d625f0507e1ea8df6b4b535790eaae9cc10378078e2be1565fdf57ab59a7ce89f92b53b6aa8050317f76e0dce1a911f9bb0d971ab2e5b56b8c3c8d1e36eb2ddf2e0df3c50c6dc3f2834d5876fd8df53c99e4826971e51bc9ade5f7038d3a8fd5b8c320152be8f7dcb779359e47ce4c8ff02163699559d02d52197ba2011dabd94b25f7ae533504c3f9ef58fe37b9ed24b1886e5cdb78fb430e88c5a98d1d97e10ad724ca3c8832806288ff783a972e55f9b87139e07070333f79bb7caa7cdfcf6538708e0e25515aadefebe5aefb2350d55b7606a67ca030cff864e85054cde55d9f1ed6a413b8f6fe42387a72b459ccc73e5b8cdd15991da17368e46e8fc4b5b3be8813937b6b77b84eaf162443b4f6cd2d9106043e12a17ef028dd013e8d63fbed1c9664c9833aa85f1e6b40fb94635b2745774c8af03968c50c7335f1f8d0e82f7e3fa98ef6fa997184bd479021dca8d66e5bc2baebeeb58bac5f07bae10dbccb3e31ccfd3df291a8088c620e4972936c158301a1cfa2b9ba93cafcccfda669ad3d2089c657502bc5ed352cfcbc8c6cb73ac7df56f7f8fd1f5813d2b43448808b8c039d25cb730ba44d7e0035fb5da6c63fa841d6727ffa20615889b93ad64f9b8d8ec76c18cbc882863e7847d2a63d519a097a09c1d155fc87a9b70bd232ecdd04cd94de00abc3aedd68e7a838d7d4b25257e25abfb88d07fecff887077877ab586aeee91733c41d363dc41fd7217ff7a6198396fe9c71e788ee1f7f3e2a7ecdcb070f15e9c3d5de481c0db44e89cae54178dc22aacafc290361cf8f99fc6be22d415fd51503953a3021c3fd116441e91a5553625670c85f043d0043974787e9f7ab949f79044a96b26fa5a69269cf475a86126ba92c7d30f10ae8f7150bd52a859df46c53420e425b8302f4adc55afcc7f6723a0e9d38c5e94bb7e51a88bb938b12dc26e9575105771490857638d2e9381c522e0b9fa3d816224ad97057d0931ce72309de1c054f757d7d70646e210227ccdf721597dd35809088b3558195209a536db7615501cb305b13f3b8b6053d6e4a182a872e11ef0bf0b285f1e069474209d7ffddd545b0998a5f35d8de04e49598d0ae776f999b1f1722f89f16d167a1b129faa021b95f0da0b517682868fa3af8804c5fba770ffa47d8e4feea83032042c00ee83033a58ba633b920bdcafadce0b6f2749a01094892929d79f65c6b45246603299f8637b29bacfd8b2e1b20fb567c124810aae628f961c3692787c07a726c989f42508765858d4048394d74ec59ffa8c1af0066923133ed78153b7be60bfc21b5f72bc992908fc8c2e73ddf7578a68350f7c45353241eb8ac16bee5af9a5f8bfafb5882bf9e51856b58ebf958cfe3fecb0ecc5c7381484c0618cd3d86bb7f3cf792114633a3c6c75b353de28f3bcc77c3be147a7177748c2d6895f39aae8a68d9da3075c81e4947dc7bdbbfd0fa59ae1032bd840424d9cbf2d7679dc6e6c858602d8b47992a757fe623b664a3dfcf7bd6445237fabb054e5f38653af61d4b1aee2c49af7b88cd06deacfe6136f73cd2f0525cc91ffc0ddff00b092560b3a304e1d84028da2e6d8254b06af27cc6cd91d6dfc351fa0bb3f00fa16cafeae1b55849710181822e35c154f53887ae48b367ed674ebb84a7ed0513c6a5edef99bf17f5801c123043e68e17c678e06e6d9d0496466e20b152ac5add0712e5067874c8ee11c823726b1508240b268f02a2e126975da3243eb87ecb8cdc945466382951d08ab0fb5e836963368ffc69e68f863d758b1f66fb29451963ba9f3ba7cf59b73cf09f8c148f0b45770b8b55d9e1af9cd26c0478e2388ae20805cb0b9cceaa7504a23c22746747220a8cc485ce36b010691a14dc35967a9b8b3083a35af07d3110ef80ee04fb109a7e67bb498d51887648d676e1663735bb80b32be4724137e0e9a3bc62c77cd6c4af4b527d9722df0dff54706dc2c75da697117591bf96f9dd27e422635339712d8052d12a68c0d92ce65cdb8e9895c87237cc5dee8d618c76ad8c5d9066bc0e9bd3fef097036e90435c99ec845d7070d0dc6663e7c0564d89666d00f7ba5e37826991496849323770aaf46f21ca47aadb791b162fa7f95155330b526bcb5504122ead3d9747d2359deb13b55f70c6ed7c7a65dc50637db611ee2b0f5565c5146023a1946faaa50eee0eb7302a03c478a4a9a73b5ca9d34596b6fdbe9a7e65f49ddb53ba07e69f2dc164a43bf361891d50243032092a57cea79631f6122c870fbe78f81e5e52f613b250d7e2c6a92bf0e1f1c6a1f54d781d4c32c6b51a0ffbdc147c80e09625013fe0ff4f5cd7c50eb77d2d75fdfedb711539eba2e9d6669e46de436a51c3d91d39c09467f61101747b9ccce84858db1e5b8761003c1219a2e5a76562ba5bef2d97235e61141a8af4b1328b83c0ba5666f949bb39ee54944c17757fa6a12723741cf67bffb0d886aca8053585d1280ee01b3483383dd511f8b9fe39c31eb5818b682055b1d443d3bf76e9f72a1456c5a35e6b0fd15fd9adb0a25142bd44762def81ff6b249b79dc51586b403aea03c2fa78e6fd8d2cdcb5aefb8c8869c8994c697943a902b253f15a637abb0c694d828001494ec0bbd99b0d79fbe1dd2371976b4f957aef84c0d230af6cef1bd5dbd9bdcf969c4df5c4b94a03d26e2deb37d6a86dbfde185978693509cbfbd8958520139b4aa5566e5070f9402a0364c570166aeac0a0bf29a47ad50ab2f75a81e65e8c5f3c97a731509141b933c0922976dc1a0175237bbf5adfed9d03f2c6d073a90914889fd62901f76f6bbae963826ff001d914e30a05b3559638d987f4a46b776c80ada01377a20c3c316e29f989c134fcc902989762133b7165010b6d25c770927a6aeaf51114e83dea3308e1c30e6d0f0317d2e104cfec7211af65020f411362cf15e5ce1fbc11a6b1cb7e67d732a05268f057a9a1c23a5a3a9fb40af73c162ac1bbb6935a0ef73ffb02db4ea6d5d415e52098447605a1c297452983a946155c0b10844eed845bc17fb4d777583d8efc61acb6a7c8f796960a72cd643f9e329b07914059f4c526144ef7de8121cf35076ef4d46c678bc7c6f609836aee1ee02df90bf37429cedb50137b2c896324e35912a1ce8b0320666e8e4bb9d14355b941f15b7684197484b9a82443c8e7469c0f9f4fcc88fdd6b50faf3ab2cfbda8d6d864dc39a602811c2096d5c7006a81ed286c265f044a4664bebc140873f7a3dd4e04731fd4bb70e8ee5774d86b2ae87930cdea8246a113ca9b188d68b9c8a229b3ce71d61436fea4662c060829d07b82fdccabb46d366d8137d5abf0ac8d2b860fb3a4c4691192519b79dfb3fa5b4c0692be4b9f976660f7e27955f1e5573c0f43bdd81f702532bf5477094bd57730ce79d026ab3085ed5b8176fcff72ee12fb5026708d61f26f3b41ed1c336823a6db161e7f62a3a270c8330eb9be74278fae47effbc0893f604b3aeb3f9d6b489c7adf77ce4afae6593c2868e83571f03077b2519202fba6a41fe16f361d77caf9627c92dba081d69c494e7c20b0a2e33c876a991f4d6a2b634a47731d78843b7331207cbf78a33b4de486c275606e4ca23d5b812a47f6c07c381fb9eb8d62ddc1e014efb1e90f4d60150b56d56613e48551ff96086fb91d4a0a97cbec6fdc891426af4eb46ba7ee0a620677d2ef3b68e755a1b81be5ee14e3d972190ec89aa7d1ce7900647e636023a7aa16fda2b9813b3bffcf8d230eaec221856ffe8064c3a9bea66c72f6439fc3008f18f89aa28e49fd623f09964fd38d79b91732750d1edc07aad2d7ebb714abe06a198521cd8b0de6388b0f83c7c973c58b9e029d270157d2622162747e5045c15dfa5796f8484a49b759907d29414c881490cbc53eb105fd2990ea1ad00b95480d6e950b5f28a9e5bb7e916c5a5ac0709d133e387e802aeb26cd227ff0f8287be0f2e014694578722bdfa1e8aaaa2ad0ec4934f7c0cc31b5f72bf554638057ef579063cde0bc15572fa0dc2ec0b41be7b3d896b03a767055275a2081f4283cc61d8cc1d6bab971f22961a5b1ca9bc4dcfd9ca78f688f06d3f6bbf0c5e342a7171aa163f7c47d6ae9c9e0e5815f40742552800b21da78646aabc4b5acf674d368d0e86942af1eba8e4ee8d5ee0eef04c3472410b1ad2552cf4ed302b495f098a46509b3114927fc6ef01ffd07e6cebd5d583429a03e07c58c788c9e56346a6c8679acffa9b370f754a00c7e09cfe702f9af4238d8e3872ee6c109616ba423d55f8896033eaef2a90b167355fb621717edb819d36ff82dd067fb469015ee73eb7384321713a5c8474175dbfb0369b51cc9cdd24d819bab891bc76cafa3a87afff80b5d6d2bccb8676b8c19e5b4ab08760b16de3556ec2571e412b87c077938e59b0755331d7fff3a99e7701e9ffe0286e263581595c1365e01d911d1ef524079c3fb8369507f47a30c187d574a71c2ce445c8ce8d317885f4776d99b7106516ea14ee66171f760c086eac1f47761dfdc3f54ea74938a73b706905ceb95d19431b8ec87208a6755d946d24e56df4a749987a33ee6d6e7e23b9b0be00500f3eeeba80f157403b11c712b71cb63f031c14ea16bb711599857025b7f2942b683448aa3839cee700d7ad8b131d10f8c24ac7ba075e848fa8bddd5828870a75766ea4cc693f13f466ca0cef4e4f447299e158da689f97abf4569d9b464e885ac2b87b1cd9002e1de5bf86d6b47875febe38041d4772dcd1c1bb026115daf7eae3e9bbb7b5c4ea4f8fa78eb2f5051da0d121cf9b61357d8985b194e6bc766a870fdfd62212cecae17a5483cf37534537b327e22e8dc1a9103be5c8cce088f9a1f1072a17c63537c9c480904f453689ea82ec7131759f3e13d7ce917c36e097cbe8e92e86fa15cf1bc60e2ed31f4cad1e34149ac01c8d582e17d4f1f0934c296cef1394497361a55576c5080766115356f2a3541e1fbb038d4902588aa7b517286a3f1c37415df19c28829dce45bf8416f58b40ee5cd425034fbca341b820ee66f29af9bb1e04563cc4d14e68bcfcc547a6e56300df46446ab86780d6441513f9d434e405d81d9297ea2de66ebdaf3231ffcfd19536aeddb0bfe664890190dc34dacc471715b86ae7c145f8dcb57838389d4403abf1857bcf56524fc70d325c17070a4e4a72355b15367e6c3309ecbae60188c35271e07f11ee3fef6f9463fadf3c424900d5b6ea722743e5f1c232f1ab3832f13631016dc9c97bf9a1c5ad7c74a03cb48d6a49a91dc5c2359cef31ddd6e3887c981d9364480f28a0496da427f1ffc7a7f39ef571e5082de1c898c9a93812c6a7bee34f56c8bacd16d952c8a03b1bcaa55b78492ee83c5b0c4fdc4ced346096d0b0942c7a3a4b062a6d2deba24a0f5e3f689b47d8619ba9619d1f45f1d122b816a9ef86daa93f6a0b47a659466ca79551e57ec382e31c1c6ad273def91356b25cf57cd57094e1f186f24b13865ccd136d5b768b29f172d6f19ba7f64bd885c55f4fc6ac62ef02261ca96b2d57b66c74ef45e3a5d38090772afb3519b4a8f8a95397ebda6f878fb52975d03c4b34cd124269663b7c73cf6f14387b3048c19834441bee0024b801f4112f346725a06cdb3861abc8ecf52c4d05759858712767eb20099128bb6ae2ac66f141cb5102beb7527a78869ecd15869bb373bff9ced8dcc37114ab8c7a9d5e6aab11fa23cbb79cbfb26b9e1cbe54080122898e0879867e6dd8da991148b40e4b1c77697e618041537369cacee5df71356e17b273d932cec3a7d9318a0acbd818b399dc01dfba0b1f3e7d0719ac50d6827cf10e14bd1049d43bcc2d6d6a7d410c2cbf86cb4001ef3223dd3ee510366f8ce14ce3e4eec3323427d8fd25916c8457499bb59d8110ca3fed19e9f60c2c62f8b9d776cbc309e3c47e3634d9ad57d05f884d22a9d67fb2c97371ea80c404990ea7cdb035f5c5c6e13c794136c75bb363d158e69f23b47d02441484d53f4d74bf4fe868fc8932480213dcdd58309445681cfc4b02211454c0430e912a4e8451c8ba3d361d740aa15901387173b816688808aac594b57eb1225d641e45dc8cd0cb75028cdcbd6debbdab541beada98147978f5cce478ee09815db8ffe8d75bd754c29452f307f7ea7e466cb626da601263463a705a5e9d6a49c23c2d875cfa488f5c58467ae1a057b3cbadd7416cff29e6d33b2d950b80b5b4590c3b72474ea9ca2b34ce33e6a94f4b7185d708a4781c8b695aa9451db25910a0f2c5ddb2221a1dab8cfaaf209f6d2d89cc91e44508af1f9fcc4b4ab4b4c56ab257acffc9d669c5943e88206b0b2b930da2e72bdf916874ef7b2395144a941adcbd51d0680f8eeda72618e38a6cc8ea70e6cc0891b6f691ee42852db3f686b3262100365f3bce2cc0a1e3cdde018fc7365209319a5c2d6b76fcf5c66eb65fdb8a8c008fa032640c788b4763314d0f771acb2977d4a942301358b1702199289802fda44b41329ad895ece59f3c98ae99ea038759ba2202998cea3d7a1726040bce6cc69fa379e7cf1d8e3a05f41e88915c2580c237a73d6364b9d83a07eaa76fec132562f50317b27cdbad2b35af71ef90a4510b508e21159ead998c08ecf1bb331a56ad5df250b71f75744eca97384d3eea756b3c9998f3c6720118826f7fbb6896a035e3b84a4eed4bee0dab58a9f6da8966f0cd72c4f3d1fa0259ee38f7242682af4b8c279abcf1aa1801acbc5b90b6037fe2d13e9cc32f734851430b8b1d6487f863718415d80baf53dc5b9a443ec329b7d4411d6b0599abde7c411e0e7f580f9439b2326f1d040b89a1e47f043abe83fc3b48555fb7fcc52d2dbf0984e2455ab1a6215f966e7214c82f728c212e5b9e9bb3208df810d201e0e044333046204b4a2899d7af1776f9ea7990bbf9e06a0c639cbe968a04d04e53f4a52937c58e26205641e367c9c01201f5427ff832bd23035af8dbd83539f4d349f511da7b67966a3090ca2126a5a50a0e2c7f2acf6961cb0b4a5a8b1192c187e207362e5111fdc5b304aa6b6bc91b97744891f84c76e88007980c20f64928c9b7f50ae8e36f11ff83678a57aae36959a809ee0b535b2544214cd39d5b854351eadc64a075fb190369698a5872c89fe785d12c69a3261256fa94efdea53dd0e32ef275006728b603327918b8c183da628c463f3874ee2677d6afe479b5b9a554040daad911258753f52dedfea8696a15189d616660ce31ca3ca48ef68eb48b729225285992875b66b0e45b005a3acf5b25cb07d97622a03af127a25a5c149ce74c3acdff05323bb5dbdf48b67f1614665b2d9fd02b5aaad20f9f8c18dd250e4d8a23febf19388fb41f13ea5179abc85cdc829c438c9ebfd1fe86edfa5a03d34b5078e64e653efa12e8e62f45d87fce42cd230685ce7ac580513e4318c9133554dcf5f6dd06d9040712d57b89cd2c247115bad8301a7384378c17ec99c3035a381ce1e095af4b1fd57ea6473f88790d006118d8fe990e19ec838b5f36c9ec44832ef9299466d694ef0ff95d96877e8362a98e9523bfa4aa6512eaa309e02a0ffa2666a5d6ecfbfbf188d07270a236018dd39d096b954a1d7c51fad408a77ed4aa3b3b12fc15d2444fd533b510de2c6115dd4843b78063de79f3a350e834b1958a48164ff21b782dc8ce1d36b53415a587ab3aa9804d6a8d60cee13013117de58eeb711db402df3e03d335dd9dab87dcb9da35bff7000f038319af97366d031e37e13c1f3ed536491506acd9a28704b5aa4f038a3671a406c6d3cb30a6f1cfd9792c6a013eea2d267db23fcb34a12a95bc3c9256e334f5c19cde40c6e693bd223525d39a850bd0b4a24104c9cb1472194a64fe942be983330bbba6bb3ec16c7bedd48a86fce095e184c07a9d0e551cde0ae2c4667190529aa6aefbd0e655db6b77a26747a7909070982dc68796c51ffca9d05b78abe60fcfb94a9a20bfbb59681e62d4d7dbfadba960f6ba35ec7897307c1a79eae759ceff58da127b21140177beeb71a00eb2d8e1e82f5d6da406c03ac0c636507552ffe64b974f085de2e81e797eae456352e3c14d39720d6baa165446e55a9ee7f8b96024fdd45a4bc22e5f4a0eb1b7bc3583665559f62d6ac272fc23607d0e91b331841652dedf2e6fab89a446b93adf871809a490d7b0dc7ba71ad059751cb65fc97edd75eaeb4733853e8c24adaa5e46acf77a63094f63b21543da423a4241544ccef94688d454eeec9d9366cf30021f288c35eb86abdf3cc641dba770c0b1b31c116658bd35219d4d3c2a023f16447751248d88221e6cd9daaf11cfc76d561806f2880a2850316783ee9a91c4fd7365f74457019c3eba59c3473520905734f8fa8f879731a6dfaea44036cafd6e196f4158e6dcb122c214bc51ad1ca7bd11213cfd4693a1e4534332a143fc38db95d973bda61f009eb475e80818e86b450f51e1254897dde5f01c2287204bb9a928dad0fe3f421c9fe5bb75524295f0baedbf12df93d331df2c0d8bf4d0c37674f1fb9797c3e53c9e24dedf82e8b35a76e259f10c41b1f2c57b3f44f637b56b431bcc8bfc1af9589f7b4359c1d33766e8f340bbcd0151473ca2636556c63fd8d193201efd807055bf1da2b606b1f48434e11c9d7a671bfbb224d69342a4cb3ad9298a2c385ce5b7d8f8d9d4d50552041982f21b659688fe7433f924a412f9f410e8c4e67e923cdd95c6ca2ae68dd06e7270b3aea2eea0625e241235a7912a23941a011b340cb406e43e5d0bf3a9d2654aeb21eb35637e585dad0d62d1fa987c3e3d86d378def823c220af7b431ac4db577d2c8d9c9e078f7e6188a87255595aeac0978d366246f1e5a486501af47bbdf31eda7a065681a3c99d6f2dd555ab902a4dc11064c25974cdbee2b6b0e4a2b11ab384485d5ca2e66f535fd208ee01b8200597822eefc76762cad6c547fea95bdc25dca55dbd76cdeab22d2446347b4ef2edd1c1d6a2a12b36424d3dfe1517b4f9af8d835c1fc253db2c2318ab7d74e6c768fcb8c37284516fdf63b744de7cebdc9514a80c947f168acbe83acf847987846b3790d02c2c6d1a3638506164ca43a762b15bb8caeb1dac1970a86570f992701d6685aab9ea47c58c47c6ed8da5fe4090521af747e619e342b07f6e4e763bcc82921cc3d476b8e039a0565ecae7fcd01cf6b2095bc003499c9cbe9c7fc8fb0e437c2897885ceb263207a808f3c791587e5b611023e4ec7359f99b0138d6b069950a24ff54fb9caa68f7db4411465d07c1b1bb731de43417aca7e3823495193d0d481ceacd4635acc5f459ab35087565d5b6c51136ecbd1e49724adde47e6c85179e377109884b3b9f964196bb8b29995794508f5d34e314a6eb60cb3e5d76c5d869f2e1230fc17371252a484ea8b2ce18b0c87f708a613c287914495102b5e297dc578e5fefce5b761f88dcde18e122ac46b0b984b2b4c4a3b79b8c0b45d43548f71677178ce4e7958626b9eca2ac71b74aa5cbfaf2862dfc504bd5294f615c6e06996be7d17327b0ab931bcbed9f337d82b4f2792e6c08573aa8f7fd6e9fa5ab46eed8255ccd2929af7c0da347a094bb6e816d310d57e114126a87d80922a13ec52e4fea5e250745d68ae76223d690d411641371fe0ff409bcd5a59d4d0c931d997cf9931d90e2fdd4293e878e3c124976da3073bbc70769be49222ae9e9e268493ae752542460cbf0f09b6c23f894d0eff6d9d59bfd02c54c15355854ffd12d0d19c5d94c100f0a4f694532fa237cff5fd10785993e51283e6a71fe203dbbdb466a74b0768468bf0ae939549fad2a8b242e9adb99cf1b741b35842d5f452f381851207132c4ad45e0e37c8f8de0808c13d52511dfc804f5aee0e640abc53a8350b1021a872c712b04fb599b4d31466f1d4823de82570901921cd1e06c55b5c268790d83671343cd9a9882b82ca64794a0369d7334507be1331878c758a040398e303cfd0a7103f3bb533bd8f2c0ebd3983d28e20e980831216195b44c78384c3411f4ba464ed860e0f301928e3c471329869f1b2b9f4cc22be8b724b19ae6cf4f15d1092f1dce0a0590f01fc0dc6a914db14e9935ffa268dfce4dcea1cbe14f890a64d810702cb919cb1d4e7663ed28a2453f415317582b0f36ed8d656decd6364badad26afce5aa0bc3714dd426dd2c0b6933a57ba187224abfc4e035f21365d8e2e7858fa458dd73d6de962499aaf7d1c9f4ca3ecb359ef4c7fcc36f831793475f2e4e67debf9b75e121fd6752a77787608394cc99af475432529ff48a8cdf18e08d1151dc5d04c104bcbe5fc5dc699f2dd2980fdde35dfc7986b657955b97e436e596d994290d3ecc31ca093f8ecb4408726da030c20fea6b054155c3c12d4160e1427844f5905bc8d34384cadd7a40c4c3b113f34d714929a54848ffbecf23c00a1f549d7a9d7a0d6fdba57316afa362d7b302401cd747b5e7614f3948d2672fafc45310417de1790676fbf2e5660e982d436c53bd694eda14cdb15080abd743c0548a706be0e1fee443a64e0587e521b362e27c9bad76f8e58afa486de792ad5c2d5e14348c97f43b4ac17a770412e820178a40655f2aea30b75a99385b2f0de95bf3497d2249aeb6b0c75d3593d32dab02435b4325ce84ea9460f41e20e0665594915a4f11001d5cc1a4f2fdab7543c0c6230455f2b66d970e477a6f90ab85a4777a98aa0d40ebf75ffa4b698a5ea4664d7a4851f3f040db8dd9fadac6eb416a27efb334d663daa8c53882ecb2693de51227aad10001ec19205254fb0e84842a62c07e1bf6d394534507631de36cbde7db7e3e9038cfef7ffdf2564612818a5ef257a8352042403dcf612eec14d36e26364a543900c5a70e3e00326fb187780225c4fb2260ca3258b02642705a0f44a4e5c579516528ec5faded5f57fb241ced46d1f7ecf6709eef921d1fa0585c3dcf7bf06ba1723ae59ab9e0a20e86ea897eab4ac115757e15e8625013d64c074bb26879eb2d41a937a33f8b19ea60e9f04d2c2aa5fe933b7068bec6ca16d9e99186f8ca781e8f528f23cbdaa37a8b02d2398c6899b094cad6b146dfe35a074bcafd321fa6c3f9b6bc5876df5832ec16b80d0e677b82289dce795ad7fb4d32e0b39d2148297e47fbfdb788246bc929dbd9d1227cf998c7cfc4e3465468a5234172987e62d201f514410c3abb89b59f669cd757a2520a31d56c39b27f8088675dbeefd6d452da7dd9c39bf14851c2469bcb9492d10def0797391fa5dafe342234f3fd72e221747912adcdfa178abc07c0f467fa40126313cf2f8c48ee6940d6ad3bbde9d3f009914785a4217513ce55645afd57dc9ab8cc57b872a631540989b61e5b0f48c7e7bbad5f184f12d810abea5812a2ba21fffc3ea2085aeed34d41ddd5506474062a52102dbfa775c3afa843f7429af7a9188853e9ec36734970402dc075bde1d8b3081800a7208ba6f858c396dd1bda0ab3f62fb1c13cd28c2f6612bc253bf541d85e59b150a76d63530bf9cffae4ac877fdda9def07a17f3066c9ca1e48089dcbeb47027ccff59a70b6edc197cdca195a9b0ff0e764d2563efb9830b1b1e91beed884106f0c95ac0d13b6f51a060ce048887126556ca45191b09ab15da16aaa0c43ded61510096de19bd64ee600eec1ba7f1aea9e2e657518c87170c1914b3ad620cd567caf235c3586277942de4aec501084993f6028cc9a47e5c3e6ca1cacc26921a61457ad416063297d67a6ac846c2b0466cb140c8d285b2b1166040aaf1d027a97e62827ee2fc19250e5d4ac3bf679f095c203084c5e2fad6e4df48f88533bb793390ffdafd6dcdb1e041332b25f61dd02662d73a3c2846a92c2f8c630c11dddb1e8077e8b468b32f07296822a4daa334761e6526874dfec9dcdb2ecafc437c81a7710033fec6bb647bb7251ddecc2009ff6f8e5dd56ce0cc2574d5ec2ec5c34dc93189358a46f827e2190823a48f76e9338f0306d3ebbf7b63dff0485914451031728029ffb2cc0a3859a44bac30997062a316f5b75e79c9855004e5eba8b289099ef458f438f55bf0572c2df71ee13f9848f6d59673c66d77996ed9d2fc36ffafb3869b3d56165ba29b27ee2abed400a397e3981afd3e52c6a987906c20bfd80819a8bc9f79af21b09de4f205e9131cadf47a64802a63e4e65e39b80cc87bd4ba51f6d770c8fe9aa93afc07e6d6371051159d8a7fd70c1fb7f63e956beeadb5e5396cd6973e7ab9585bfaa6b4940e3293607ad2970b8b4ad5c8e3359c09eeef4a49099d19bf952ff7635a909f28ae2c0bbe1139ec638ad72479bc63886eaecac5104e980b98ebf2e4bc9b3d421454e69147ee7c2adc20422a1c0b7a6ce629fb89175e9c4c2b44c6211bfa2fa6d35b989052b757cb82bfb30cb324aa05ac36f0b7d23eff10ee89c67c62a2a35cfb366472ee4458df4ed1265c82f68f25e4091512270f14d5c6ebfbd2b2a915778bc9011aa676803b2d33867acfed1d18562c9b919ba3c7859155267ea5cf45ea855a927ff59726128d0f1d9bf5725010b64891aacb45432c967fde0ba05cdb2b78eef452921a8ab2b80467390809a9db2e233d60f8959181bd46153dfa6b1fca56f2ad4fb532e71e388082ccfffb619c31dd568bbd4445242397163d87b00e55c0cde342ef05e5818a6215418f4e34522da2f7095bd12a25f1095262a209434138fd6b74d064093c5fb764e8df3a058d97c6fe4a11773cc956e823e850e245c375fb9bc18e0b4d850fc4846e7d054345e32b8ecdcba62aed7a58888c1493bb08f7f2f13f35829b60faa80492f54b913a47fe74b13fc15ed66c84fd39838d052ea728d68433664c4c9bfb1b4d10d5a3e7ffba26472f40355b1a86923d1b13db897625a8a602b2265d55b55addad7b53eaf4c3527d069487c0338bf21e45ac0499aac393ccaae6ac26b21fe5f622113e05c938f9373d5a5a97716fd107f096bfe9c32271cbd8076445ad9d21c352fff35c0e8af0a0b28513698b1462c7f54e2ba1035a41b8806ed1b3bcd5e1c91a8b46430191f65dfaa889b71eb9d68586ffa50614569ea47dfa0b5322252d4c7c22023677417d6b80da901c2b206c73b42a16939eb0bba1334e1fa1eaeeeb99cb6fb22fd75fdd81fcd8153cb7fc64bfaaf37277d447423e9edaa9c7f2ae373e27b556a875e0d32bef07d13cfa79492bdf0aa0c5f13ee8475e73e4fe466e86db0c8559ee22b7e668cfa6cb6bf100c806467acc539785159869262f559d7e22ca4ecb2907429791de4118bf296bdb69b3305d69b0e5895956c34092a9a7f8290a298c0700189cd86df878c94630888880ef34e7d89706593501da49c421f4dbce4412ff5d6bdb3a97496ffaaba0cb87a58fe6bd973e37b3fcdc5d11fe37b23070704a1ee0be28b934bf0e013b1fd07e0aec0c6408c16d150841a5dacc57cc4ce9bc20241ef56027e7785d03f3d01e89487d6427982e98899b2494f6ee87b457a437d3be2c0582f7b1d18672a1240084df64ab92425423c8de67a67f04cdd9bc5eb3347efb4245335d673735765953f857aed02e511cdcf704b16f5f1cb37d3b6ce20314197b466fc2be81a89a580624f91710499d448ed961c872aa93585502bbfbe75d9c786791191fb453c0baca30763e30015b5fb75a5e04392b16ba77a1c03c8e4dc4add9cf51b581f13dc910c7059a83b71eca72c627fde6b1be698c7dabe79ea74c3bdaa72bbe716e86d29055c9415e649bbaa508d8ec355887d57c8c017bf644bf28db34506345b36dfa87b66764d6f83f36182b01c0f05964284e2c83b5ffdb9134e4dfb305b5b5d85fc9263cc94a75a1882042f6b4ce56ea8f7a73565968f4b595554868a41cc26db1c319b099226a760962c004cca4e661b4cec2d9986ed63fc385901eb018b3e1d4dcd666a7e56d9dfe62a5a360a7ee27c8de7ee9b3243e0ba11dd92ddfce1278ef5771f53357096024edacc09c9999d78f6a5550e60bf03d06f5c500039e075e7d6373bf8ac40f14ea0fbb542185e8276348df2c8dca1240cee2bf2b211dd96ea4dda2d6da6b1d7f7ad49c191335c4d2467abb3a1a2c6646b85f259d48ccd82ebf8b31599f6b6db027f808d4bc9b3614488582e2fbf515f4998d9a8f3eae6b6e399d883c9de9f1d0ffa0620a7e8a1842468675f50b6a4878b818ba7565f44bb9888ca9b572b318258ea97946dc6aa8666f8c3254a7945878ef696a4afade79b48c5a17c3d00672af7932fa84ec74cf61a2731c1042d9253cc7ec43bfe7d3a26a9be931f515c35cae74d464563b259b701b65c014aef00261a681a8f39ad9264bb9d11d3577a2a81883a3e9fefe7834c0a4cf4f0a90ec0d6aacb727bb07bdc49f971fe303bd4bce2d6b81593afc672441e0b66d40893e177583a63dd695813969b2fb520c52a9469ee40007ed86b9d15b78004debff627a2f72903ecddf2e883f20b9d3b1d88155431729ab8c67bfd89d968a55ec8f5419ae6cdd28e8d0f000797c797d839e213739c06c49f788910e71de63b8f400827e0121c5b97ef3e4cf49919a0ae701d6d62ff24899da622240188966c07c7c213a5ec204610edc78b066810bd240542627ac5967f9e841295eb7e4907b5579137969114006e48719695c8e642df897055829ee3d0fba7f61973d756b9b69d01779f4644448eec5eb259fd8e6808eb1abfdc7b266f5e01e7feb0fc0b020abaa329fa708c182e28a3225675622c493b61b8f5b131f669ded7695c74f816aeae98a7a974393b619150e04445827e6d2e23740c1cda4560819cd885b09c405e9c6e746d5697b5ce3d0bd24c1a97c0ed1f2328c4f428b17ea6854ae9ae3bde2e0ae8cf7af744cbc51c54b5bc97c8911e70891858191cbbf5348265b2ce826b12a19f39ef0781c12df8949ef7134d4cc0936dcdc9d270e10d6bfb0f77b59ac709a59929e863e56758a1db81ce06da370d98cc62359f226b433fd2a3c9aed18435b1b762d65bd5278a19da4a70b65c71d92b2263f0a3cba7b6460fabb7b5d4e89afa8bbb806da6792256a6462528192a7dd88d2329a360281990737ef8a0f309ac31afcf772eae4750b94f3f29d7bf875b4d2de063feff3855a5eb537aa76c0f8151f214fcc18828c071e846728f5dfe2b81df8f0407a16dab73bffd21bb1be05134626ee22c3765d4d8073c941358b4ac417cff8d88f678dad677ee9c7334f00ffa8aa2210cef6d2cebb2ea026676dc6a451208e090a25172220d1b85d76af90ab7f2969cdeaec2cff958753b08b5b4cbcf4cbdc781ce221d51ff6f4e1e0fad57eef8614d6b3c3c86ee4f0ecc592feda3dac7d49ae18da3fb0df882e85bf007513d50dfc28a252ad2bd4d6611beafced993a739319e5976e03715b142eb364861cfb2614acf456e9e8516e6c6dc0ecaa06fa007d9655f5451595a3fca2b4f8444e1a5771af4ccd17430f678f92522675f8262dbebba4806bf0779cdf433384208c5931328f629f3ab754c4abfbe350107df1d74af8f4b1a187bfb2718d54718573fef1c1a5c1070744f4a168af9a2fced345d2cef24ed7dd9f85eca22d1f4b892e2006e7ad6e60f148abec9e7cd94e2211c187cfb2b3aadade2ef1852b7a2840b7d31957f85aa14db0b4c5583d84fc2bfeb8d7335ea8e058bdaf0d3e8d628925090e465fd37de56affec78cd9baf1e687a0b405a0527463426f6b8300ed19355badd6fe65c595985ee4ea942b5e7d46d194ef42a26b4bd781f742a6ec07c203811848a39367e94fb2c9ce9944bf2021c7537c49591cdfdc9a3aa378f8c3d7afe6e2476ec2a74dd183773a1d01694afaf9ca22addc12ccfd4211e45ffb9171a1d2532c0cfd4cdd0d3549a13b70309f04635cddf1e5cfbc44e4236e0697d63a81131075bbb67f151996051f25d110e784fb54bd4939428f2c9e9b2ee29b7c657f4c2de674845eedfa20843be9e76992b1691afe0add46efbe30a3bd8b204ef92012234282ad52baf66c280ec94626fb1019d61d5ebf7bd14fb42ff1731517038ab799b8dcae97d93717a6548d3641aec27aefa99c53c880b20582827a96a91ac93fcc707a65ebc10bc346a86dd3ba5767b1a9f2b0f28cbe7af9b937768a2c8d16e85ac558991e23e4f01c7e08302149e89724b8d818ba9a5f110c63e0df4588d5a24677a387ed569fe3c33c0b4bd91b0e52e8616d275e0097255c7f24bb3108bd6c724002477560634b479a16a8414d20f6b264d3b59ab2719955e9f4410dba30822d9e25e499c5107ef112c93ee2f41afe2a710bfafeca5efda4325c8ca95318bf7efa59cb2e0f2dfc1ffc77f9173e8d8fd881db030eeac1cb218682be64f4c268ca048eb434a35b5e28423a67fe0792ceb997eda8fd692164fe88e95cd11ce0dad9eb173a8af050567ec7f3b4f405c24267c29af0ee50c3fb02df1577be7164c7504ced7b8000ca9b3d147719ecf5151ed0f914c4a63713448bc3667a49f91199867853c9dd3257cecaa04bcb7f06cbaed71c664b76e7d96fa6619eea23b535a4794ca3ef392ab609f3e11f555d51142a64cc183ea62d7013de8317a51c718dcf071148e85f1b57932c3cf1325fd9e40aa4563d8ac8f51f86b2b140d500e049402b7bd97c90a065f26a1bbd534bc358966a0b8cced65508b8c408ee17d409fa40c242bf8dfc2fedbd10646c2ee622a6db3720c02b20b16f7ca5828cc11601e83165a18d0579c10c7de7b3a52a76eeef307f06421fb74c56251ac3a28f06a0ef36a2f38cecb3ad5cc6426965dd6b225fd98677b2d5d7618e07d611d8c647d3d7d16db576d03f3b2df421cc8316ad170195cc93061532f7d284ae1f7424d9bc4ee36536dde783e590d331d17cf9d151f1e7e538a5227ff3217876d9a429868395a0b4bdc544fb598428fc640d886fae8c02837e81f9d7e3720bcc63ca1b73a0980ec963ff0494805a989b071b21af4077a0e3b109a05d620f40019140e3f1467adb92acd67ced6f51223a5551b3f1675420efa2fa7cee1fc6c0b77e510e0022ea43ea99b26894ae24a298011294e3022478e9a7dc3018ae6e5010da63d9e138c3e68a53e905d1fa1719a89e47543ee291922d9ed7c07fc4de08cfe2c495c106c4a81502f6f56e523b335feb0f7f59f4a3f526b5d25dbd0e999d1b2d70e7c459f523cba76b11a4472138f8315ab02490696d9f4aade78f4a21bd1d483eb8161b91aabca21b465138eeeb923d86911daf95057b5e1753f2fd002de0d9528159fed6ede78ba143743892cc9f7cbbc820c40937d0b263c1d8ecd403585efe0dbd701f7e41a8090afeea1ef1fd9cd5496f5069eefacd38da958031ffe701429f2b852cd395aa0b9f21364960f1901d16c5cd43f4cc2e40d81ba91e38a71ce0a87c521c186d6c1c7cf7fd7f7a997b9cbc15350169f4103f796c33940da1a1db8136aec0ebc987684f93aac69c8ae66541e9d033cb2905c7530f6600f05f4e6e9bcd5ba6d4fd036b4a9fe981cd07f8025eff72bf6fa585d446ded25699dfab25a28c5b26d4dce3464fcd01187303e2c712cf1ba8a24422dd8615c0d1b2d2424bd0e85c8353bc9cbfd39de4a119ed3486bd19fb5c8d698c7b40bb83b44adb3492833503e42a08ec567c5aa166e5cc88353de274d74c65bfe16935ede76c63e4838f3dddd66f20d220dae1da52c7910ee156ff4073bf40ea166695f152e354eb5d7e2e10a9158ecdacc3c41e7dd7c20b8055e40d8b68a22a7bd3bf18888fb23f6f15a0cd425a062213f45823b3aaebb36051258a53c7d39415df65c09eac860b755411914e4a26b0681be28e8179d351e2ba72f31a5e222ca3952a2e66880c75cb9094bc4eaf2644b401727c95d297ef7e076eedd74c39d0b608cf08e05ab566b115532409e98bcd6dcc124c0481b342222ac1fe351ac7d40747b0887ff9f9f0c2fef21b2b77d4501acbebf944bf81c513c2750f26ac3b417ea8d2e8b42a25c8b315bf7c78b59e080425936b2b291b7d07765dc2b68e883991b382704e6b60eedfb829d4402f9fc21df9445b9789eab02386453ca3d2c9930e67feb5961d4431ab59db4195df5476dbd65b9c9b8ed526370d69fe251f1924e2eca77caac61d9a887f7c7b5235b33e4d2f4f0b3179b6698eb209dd441184e9eaa8a5b318b57a40e0e8a09e771f5e87b9e19c2617be178bf1fa85c2b9624f410dc1d4e88d74b62eb6a18b2cec49f7feb51d092af8c9c6643ebb6f89598840d56438abfe906398918d2131eefc4aab88d6bafd63a13ac24adaab708ab9157912398391b2893e13b052c48aeb4d6b5d43584c6716a1e2a2565ce5bc1751ac17208fcd1c6437ca9027fe3bef48d30c2b0c421753a48661e60b673d1e3af70009a1c0c007664c0106b28a85979ec068f0f997ffc1869f9f382aeb2c2778ab75202b13cfe93f7ac2922b2f5d78d2bec04dba1d49c46baabbc5f301c089b693beb2c33bf4278a5cf384ca0ada272b3bc845d49bf0411aa2f367a97aa34b5ffd7e5e8c429f351ec9ae016229ee86b35402d0a90a6c5208e976eeab9a754d39f20a2324dcfc648a169058346d3c03ec50722d11bff2ae1bc3dce2812c34cdc9d5959f3aa643bde9ef8ca6cbe92b35d943b4b51a15a6e7a49c63c78cce8b51f898956fb2d5c1723a5b2624d6c64c809f3083ba1162f6942c1e3b97252031c91e3758c77ce011603cbd03407a045d997a296943adc3b72817087383ae3a374274ab3bb62e90d266bdebc787ff5985dfc31b75c28465bec74e1ae94dc87d14e3cf04a2c45d11a9d8f337f89e496f4bd6e17245ad5ca7b98c8d5a7c8aeeb12600e9a8ca28caa7ccb15412a1da5e1eb56b27d233e4aff637b3506753b1c1d4933a381d205e8229b985af07ab998e72c7489e277a69e165d6f956c5b52667b0e1c66f1ee1d376d3d06a085dc798ab24c81e011224175575c3cdae69e9e73922f8bdd2b03f76eba50854dac6e9cd47288292a91e6232058f8e3973ae3bd3988101d47ec72962f7178ba0ffd5aef956d76b4149316473dd5ca0c6da195eac3e380f57ebfdbbebbf677735fcb03e39f6356ac75c598f38137326b7de2ef8c85296a26512df440741156368f74bb33c954bddcd2afdc2cfd70e41077ee78bdc99e69c989bca981748eebfc9e7ef2f5ab9e6356f0dca839927ff7bb9a84eb12f305d99f96042bf28cde10775a33705d3966eab80ad41f365501170bb1c7b2cb8ebbef8023b225fe2ef1fc943b8931773d22d5b94bc0b4afad8a5e56b9bc2571bdd25eec2e710f1b23966eac0c6e123259c774bf7ab71ce6d84f5d86f17f0c9b1527740287a818ca68b6298c0c4abe7cd440a154c3fb12fd31dedde1646401772fc656df38a8c20713a5ba042cca23b9c4ba3a0db6ef5a8d8a20b401bcb77bd327d0636a939ac0c731fe814f9b56c0b9dee8db0253e7492b2460e042f010d83e12082eda0ad449ca3fe5dca9d7bae9c9b782537ab0c776066de4ecd2acdc744adbb72f00436ffed04034bb2fd018cc449e01758847e327e854c9f150dbd8ea402d181ccef96c83753409807e9432054e55fb9f02c4febc851417</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Password Needed</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 街灯晚河 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试汇总</title>
      <link href="/2023/04/03/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
      <url>/2023/04/03/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h2 id="Java-Base"><a href="#Java-Base" class="headerlink" title="Java Base"></a>Java Base</h2><h3 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，多用于实现多态</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名相同，参数的类型、个数、顺序不同，方法的返回值与访问修饰符可以不同</p><h4 id="重写（遵循两同两小一大）"><a href="#重写（遵循两同两小一大）" class="headerlink" title="重写（遵循两同两小一大）"></a>重写（遵循两同两小一大）</h4><ul><li><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p></li><li><p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p></li><li><p>构造方法无法被重写</p></li><li><p>如果方法的返回类型是<code>void</code>和基本数据类型，则返回值重写时不可修改；但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li></ul><h3 id="、equals-、hashCode"><a href="#、equals-、hashCode" class="headerlink" title="==、equals()、hashCode()"></a><code>==</code>、<code>equals()</code>、<code>hashCode()</code></h3><ul><li>对于基本数据类型，<code>==</code>比较的是变量的值</li><li>对于引用数据类型，<code>==</code>比较的是对象的内存地址</li></ul><p><code>equals()</code>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。</p><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。由于哈希碰撞的原因，不同的对象也有可能得到相同的<code>hashCode</code>值，如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p><h4 id="为什么重写equals-必须重写hashCode"><a href="#为什么重写equals-必须重写hashCode" class="headerlink" title="为什么重写equals()必须重写hashCode()"></a>为什么重写<code>equals()</code>必须重写<code>hashCode()</code></h4><p>如果只重写<code>equals()</code>而不重写<code>hashCode()</code>，那么<code>equals()</code>判断是相等的两个对象，<code>hashCode()</code>有可能不同；例如，HashSet进行去重添加时，会先通过<code>hashCode()</code>判断，那么没有重写的<code>hashCode()</code>就会返回<code>false</code>，即认为这两个对象是不同的，最终导致Set加入了重复元素。</p><h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a><code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>的区别</h3><ul><li>可变性<ul><li>String是不可变的，StringBuilder和StringBuffer可变</li></ul></li><li>线程安全性<ul><li>String和StringBuffer是线程安全的，StringBuilder是线程不安全的</li></ul></li><li>性能<ul><li>StringBuilder性能比StringBuffer略好</li></ul></li></ul><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li></ul><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet、LinkedHashSet、TreeSet的区别"><a href="#HashSet、LinkedHashSet、TreeSet的区别" class="headerlink" title="HashSet、LinkedHashSet、TreeSet的区别"></a>HashSet、LinkedHashSet、TreeSet的区别</h4><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p></li><li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h4><ul><li><p><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</p></li><li><p><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</p></li><li><p><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</p></li><li><p><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><ul><li><strong>线程安全性</strong>：HashMap是非线程安全的，HashTable是线程安全的（内部方法经过synchronized修饰）</li><li><strong>对Null key和Null value的支持</strong>：HashMap可以存储null的key和value，但null作为key只能有一个，作为value可有多个；HashTable不允许存在null key和null value</li><li><strong>底层数据结构</strong>：HashMap采用数组+链表&#x2F;数组+红黑树（链表长度超过阈值时，会转换为红黑树），HashTable采用数组+链表</li></ul><h4 id="HashMap和TreeMap的区别"><a href="#HashMap和TreeMap的区别" class="headerlink" title="HashMap和TreeMap的区别"></a>HashMap和TreeMap的区别</h4><ul><li><strong>底层数据结构</strong>：HashMap采用数组+链表&#x2F;数组+红黑树，TreeMap采用红黑树</li><li><strong>功能</strong>：TreeMap由于实现了NavigableMap接口和SortedMap接口，因此相较于HashMap增加了对集合内元素的搜索能力和对元素根据key排序的能力</li></ul><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><ul><li>NEW 初始状态，线程被创建出来但还没被调用start()</li><li>RUNNABLE 运行状态，线程被调用了start()，则变为READY可运行状态，等获得了CPU时间片后，处于RUNNING运行中状态</li><li>BLOCKED 阻塞状态，需要等待锁释放</li><li>WAITING 等待状态，需要其他线程做出一些特定动作（通知或者中断）</li><li>TIME_WAITING 超时等待状态，等待指定时间后返回而不是WAITING那样一直等待</li><li>TERMINATED 终止状态，线程执行完毕</li></ul><h4 id="死锁的产生和避免"><a href="#死锁的产生和避免" class="headerlink" title="死锁的产生和避免"></a>死锁的产生和避免</h4><ul><li><p>死锁产生的必要条件</p><ul><li>互斥：该资源任意一个时刻只能有一个线程占有</li><li>请求与保持：一个线程请求新资源的同时，不释放已占有的资源</li><li>不剥夺：占用中的资源只能由对应线程主动释放，无法被其他线程抢占</li><li>循环等待：若干线程形成一种环形的等待资源关系</li></ul></li><li><p>死锁的预防</p><ul><li>破坏请求与保持：一次性申请所有的资源</li><li>破坏不剥夺：线程在申请新资源时，释放自己占有的当前资源</li><li>破坏循环等待：按照某一顺序申请资源，释放资源则按照逆序</li></ul></li></ul><h4 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h4><p><strong>同</strong>：两者都可以暂停线程的执行</p><p><strong>异</strong>：</p><ul><li>sleep()没有释放锁，wait()释放了锁</li><li>wait()默认需要notify()或者notifyAll()来唤醒目标线程，sleep()执行完成后，目标线程会自动苏醒，或者也可以用wait(long timeout)，这样超时后线程也会自动苏醒</li><li>sleep()是Thread类的静态本地方法，wait()是Object类的本地方法</li></ul><h5 id="为什么wait-定义在Object类中，而sleep-定义在Thread类中"><a href="#为什么wait-定义在Object类中，而sleep-定义在Thread类中" class="headerlink" title="为什么wait()定义在Object类中，而sleep()定义在Thread类中"></a>为什么wait()定义在Object类中，而sleep()定义在Thread类中</h5><p>因为wait()是让获得对象锁的线程等待，自动释放当前线程占有的对象锁，所以操作的目标是Object而不是当前的Thread；</p><p>sleep()是让当前线程暂停执行，不涉及到Object，也不需要获得对象锁</p><h5 id="可以直接调用Thread类的run-方法吗"><a href="#可以直接调用Thread类的run-方法吗" class="headerlink" title="可以直接调用Thread类的run()方法吗"></a>可以直接调用Thread类的run()方法吗</h5><p>调用start()方法，会启动一个线程并使其进入Ready状态，当得到CPU时间片后即开始运行；因此真正的多线程工作方式是：start()执行线程的准备工作，然后自动执行run()方法；若直接调用run()，则当前方法会被当成一个main线程下的普通方法去执行，而不是在某个线程中执行</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><ul><li><p>volatile关键字可以保证变量的可见性，即该变量是共享且不稳定的，每次使用它都到主存中读取</p></li><li><p>volatile关键字可以防止JVM的指令重排序（通过插入特定的内存屏障来实现），例如单例模式的双重检验锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断对象是否已经实例过，没有实例过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>uniqueInstance = new Singleton()</code>这句代码是分成三步执行的：</p><ul><li>为<code>uniqueInstance</code>分配内存空间</li><li>初始化<code>uniqueInstance</code></li><li>将<code>uniqueInstance</code>指向分配的内存地址</li></ul><p>由于JVM有指令重排的特性，这三步的顺序可能发生调换，在多线程环境下可能会发生一个线程获得了尚未初始化的实例这类问题</p></li><li><p>volatile关键字无法保证原子性</p><ul><li>可用synchronized、AtomicInteger、ReentrantLock实现</li></ul></li></ul><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><h4 id="synchronized使用方式"><a href="#synchronized使用方式" class="headerlink" title="synchronized使用方式"></a>synchronized使用方式</h4><ul><li><p>修饰实例方法（锁当前对象实例）</p><p>进入同步代码前需要获得当前对象实例的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法（锁当前类）</p><p>因为静态方法是属于当前类而不是对象的，所以进入同步代码前需要获得当前类的锁。但静态synchronized方法和非静态synchronized方法可以互相调用，这是因为两者加锁的目标不同（一个是当前类，一个是当前对象实例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰代码块（锁指定的对象&#x2F;类）</p><p>对括号内的对象&#x2F;类加锁</p><ul><li><code>synchronized(object)</code>锁<code>object</code>对象</li><li><code>synchronized(类.class)</code>锁该类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指向同步代码块的起始位置，monitorexit指向同步代码块的结束位置；当执行monitorenter时，线程会试图获取对象监视器monitor的持有权；此时会去判断该锁的计数器是否为0，若为0，则获取锁成功，并将计数器+1；锁的拥有者可以通过monitorexit指令来释放锁，释放后将计数器-1</p><p>synchronized修饰方法时并没有monitorenter和monitorexit指令，而是通过ACC_SYNCHRONIZED标识；JVM借助该标识来辨别一个方法是否是同步方法</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是一个可重入且独占的锁，底层由AQS来实现</p><h3 id="各机制之间的对比"><a href="#各机制之间的对比" class="headerlink" title="各机制之间的对比"></a>各机制之间的对比</h3><h4 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h4><ul><li>volatile是线程同步的轻量级实现，所以性能相对于synchronized较好</li><li>volatile只能作用于变量之上，synchronized可修饰方法和代码块</li><li>volatile可以保证可见性，synchronized可以保证可见性和原子性</li></ul><h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><ul><li>两者都是可重入锁，即递归锁，指的是线程可以再次获取自己的内部锁，这样当出现线程递归申请锁的时候，不会产生死锁现象</li><li>synchronized依赖于JVM层面实现，ReentrantLock依赖于JDK层面实现</li><li>ReentrantLock实现了等待可中断，即正在等待的线程可以放弃等待，改为处理其他事情；synchronized等待不可中断</li><li>ReentrantLock可指定锁的公平性，synchronized只能是非公平锁；公平锁指的是先等待的线程先获得锁</li><li>ReentrantLock可绑定多个Condition，synchronized只能通过wait和notify绑定一个条件</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal类主要解决的就是让每个线程绑定自己的值</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>当有任务需要处理时，可从线程池中取出线程，处理完后线程不会销毁，而是等待下一个任务；池化思想的目的是为了减少每次获取资源的消耗，提高资源利用率</p><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><ul><li>通过<code>ThreadPoolExecutor</code>构造函数来创建</li><li>通过<code>Executor</code>框架的工具类<code>Executors</code>来创建</li></ul><h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul><li><code>corePoolSize</code>：任务队列未达到队列容量时，最大可以同时运行的线程数量</li><li><code>maximumPoolSize</code>：任务队列中存放的任务达到队列容量时，当前可同时运行的线程数变为最大线程数</li><li><code>workQueue</code>：新任务来的时候先判断当前运行的线程数是否达到核心线程数，若达到，则新任务会被放在队列中</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是<code>AbstractQueueSynchronizer</code>，即抽象队列同步器；这个抽象类主要用来构建锁和同步锁</p><p><strong>AQS的原理</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将该共享资源锁定；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。AQS用了<strong>CLH队列锁</strong>来实现该机制，即将暂时获取不到锁的线程加入到队列中</p><p>CLH队列是一个虚拟的双向队列；AQS将每条请求共享资源的线程封装成一个节点，每个节点保存了线程的引用、当前节点的状态、前驱和后继</p><p>节点的同步状态是用volatile修饰的，通过CAS等方法进行操作。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="悲观锁和应用场景"><a href="#悲观锁和应用场景" class="headerlink" title="悲观锁和应用场景"></a>悲观锁和应用场景</h4><p>共享资源每次只给一个线程使用，其他线程阻塞，用完后再将资源转让给其他线程，例如ReentrantLock和synchronized这种独占锁；悲观锁一般用于多写场景</p><h4 id="乐观锁和应用场景"><a href="#乐观锁和应用场景" class="headerlink" title="乐观锁和应用场景"></a>乐观锁和应用场景</h4><p>乐观锁只有在提交修改时才去验证对应的资源是否被其他线程修改；一般用于多读场景</p><h4 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h4><p>一般用版本号机制或CAS算法实现</p><ul><li><p>版本号机制</p><p>在数据表中加一个版本号字段，当数据被修改时，版本号加一。线程A更新数据时，读取数据的同时也读取版本号，提交更新时，若刚刚读到的版本号和数据库记录的版本号相等，则更新成功；否则重试直到成功</p></li><li><p>CAS算法</p><p>Compare And Swap 比较与交换。用一个预期值和要更新的变量值进行比较，两者相等才进行更新操作。</p><p>CAS是一个原子操作，涉及到三个操作数：</p><ul><li>V：要更新的变量值</li><li>E：预期值</li><li>N：拟写入的新值</li></ul><p>当且仅当V和E相等时，CAS通过原子方式用N来更新E；否则就说明有其他线程更新了V，当前线程放弃更新</p></li></ul><h4 id="乐观锁的问题"><a href="#乐观锁的问题" class="headerlink" title="乐观锁的问题"></a>乐观锁的问题</h4><ul><li><p><strong>ABA问题</strong>是乐观锁最常见的问题</p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过</p><p>解决方案：可以在变量前追加<strong>时间戳或者版本号</strong></p></li><li><p>循环时间长开销大</p><p>可通过pause指令降低资源消耗</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>主要由五个部分组成，可分为两个类别：</p><ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：堆、方法区</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</p></li><li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</p></li></ul><p>因此，程序计数器必须是每个线程独有的，无法共享</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址</p><ul><li>局部变量表：数据类型、对象引用之类</li><li>操作数栈：临时变量、中间计算结果等</li><li>动态链接：将符号引用转换为所要调用方法的直接引用</li><li>方法返回地址</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为执行本地方法（Java调用非Java代码的接口）而服务</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>存放对象实例以及数组</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>当JVM要使用一个类时，它需要读取并解析Class文件并获取相关信息，这些信息就会被存入方法区。方法区会存储<strong>已被JVM加载的类信息、字段信息、方法信息、常量等数据</strong>。</p><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1 类加载检查"></a>Step1 类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2 分配内存"></a>Step2 分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>，分配方式有两种：<strong>指针碰撞</strong>和<strong>空闲列表</strong>，<strong>选择哪种分配方式由 Java 堆是否规整（即有无内存碎片）决定，而 Java 堆是否规整又由所采用的GC收集算法决定</strong></p><ul><li>指针碰撞<ul><li>适用情况：堆内存规整，无内存碎片</li><li>操作：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小即可</li><li>使用该分配方式的GC收集器：Serial、ParNew</li></ul></li><li>空闲列表<ul><li>适用情况：堆内存不规整</li><li>操作：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录</li><li>使用该分配方式的GC收集器：CMS</li></ul></li></ul><p><strong>创建对象时的线程安全问题</strong></p><ul><li><strong>CAS+失败重试</strong>：CAS是乐观锁的一种实现方式，乐观锁指的是，不加锁而是假设不存在冲突去执行操作，如果因为冲突失败就进行重试，直到操作成功</li><li><strong>TLAB</strong>：为每一个线程预先在Eden区分配一块内存，JVM在给对象分配内存时，首先在TLAB分配，当对象大于TLAB剩余内存时，再采用CAS+失败重试方法</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3 初始化零值"></a>Step3 初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4 设置对象头"></a>Step4 设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息， <strong>这些信息存放在对象头中</strong></p><h4 id="Step5-执行init方法"><a href="#Step5-执行init方法" class="headerlink" title="Step5 执行init方法"></a>Step5 执行init方法</h4><p>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化</p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><strong>对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h4><ul><li>新生代：Eden区、Survivor S0区、Survivor S1区</li><li>老年代</li><li>元空间，使用的是直接内存</li></ul><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><ul><li>对象优先在Eden区分配，若Eden区空间不足，则发起Minor GC</li><li>大对象直接进入老年代，如字符串、数组等需要大量连续内存空间的对象，以此避免由于复制而降低效率</li><li>长期存活的对象将进入老年代，对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁</li></ul><h4 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h4><p>可达性分析算法：基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p><p>可作为GC Roots的对象：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li>标记-清除<ul><li>该算法分为标记和清除阶段：首先标记出存活的对象，在标记完成后统一回收掉所有未标记的对象。效率不高，且会产生大量内存碎片</li></ul></li><li>标记-复制<ul><li>将内存分为相同大小的两块，每次使用其中一块，当一块的内存用完后，把存活的对象复制到另一块内存，然后把当前内存块清理掉</li></ul></li><li>标记-整理<ul><li>先标记出存活的对象，然后将存活对象向一端移动，再清理掉端边界以外的内存</li></ul></li><li>分代收集<ul><li>将堆分为新生代和老年代，新生代采用标记-复制的GC算法，老年代采用标记-清除或标记-整理的GC算法</li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li>Serial<ul><li>单线程，必须暂停其他所有的工作线程；新生代标记-复制，老年代标记-整理</li></ul></li><li>ParNew<ul><li>多线程，新生代标记-复制，老年代标记-整理；唯一能与CMS配合工作</li></ul></li><li>Parallel Scavenge<ul><li>关注点在于吞吐量（CPU中运行用户代码的时间与CPU总耗时的比值）</li></ul></li><li>Serial Old<ul><li>Serial的老年代版本</li></ul></li><li>Parallel Old<ul><li>Parallel Scavenge的老年代版本</li></ul></li><li>CMS<ul><li>关注点在于用户线程的停顿时间</li><li>并发收集，GC收集线程可与用户线程几乎同时工作，标记-清除</li><li>具体运作过程分为四个阶段<ul><li>初始标记：暂停其他线程，记录与GC Roots相连的对象</li><li>并发标记：GC线程和用户线程同时开启，记录可达对象和发生引用更新的地方</li><li>重新标记：修正并发阶段由于用户线程运行而产生的标记变动，该阶段的暂停时段比初始阶段稍长，远小于并发阶段</li><li>并发清除：用户线程开启，GC线程同时开始清除未标记区域</li></ul></li><li>缺点：无法处理浮动垃圾，且由于使用标记-清除算法，会产生内存碎片</li></ul></li><li>G1<ul><li>标记-复制</li></ul></li><li>ZGC<ul><li>标记-复制</li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载过程：加载 -&gt; 连接 -&gt; 初始化</li><li>连接过程分为三步：验证 -&gt; 准备 -&gt; 解析</li></ul><p>类加载器的主要作用是加载Java类的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）</p><p>加载规则：JVM启动时，只会在类被用到的时候去加载，对于已经加载过的类会放到ClassLoader中；系统会首先判断该类是否加载过，已加载的类会直接返回。因此，对于一个类加载器来说，相同二进制名称的类只会被加载一次</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型如下图所示</p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 75%;" /><ul><li>BootstrapClassLoader启动类加载器：最顶层的加载器，无父类，主要用来加载JDK内部的核心类库和Xbootclasspath参数指定路径下的所有类</li><li>ExtensionClassLoader扩展类加载器：主要加载ext目录下的jar包和类以及java.ext.dirs系统变量所指定的路径下的所有类</li><li>AppClassLoader应用程序类加载器：面向用户的类加载器，负责加载当前应用classpath下的所有jar包和类</li></ul><h5 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h5><ul><li>在类加载时，系统会首先判断当前类是否已加载过，已加载过的类会直接返回，否则会尝试加载</li><li>类加载器首先不会自己去尝试加载这个类，而是先将这个请求委派给父类加载器（调用父类加载器的<code>loadClass()</code>方法）来完成；那么，所有的请求最终都会传给最顶层的BootstrapClassLoader</li><li>只有当父类加载器反馈无法完成当前的加载请求时，子加载器才会尝试自己去加载（调用<code>findClass()</code>方法）</li></ul><p><strong>JVM判定两个Java类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同，才认为两个类是相同的</p><h5 id="为什么要使用双亲委派"><a href="#为什么要使用双亲委派" class="headerlink" title="为什么要使用双亲委派"></a>为什么要使用双亲委派</h5><ul><li>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改</li><li>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类</li></ul><h5 id="如何打破双亲委派"><a href="#如何打破双亲委派" class="headerlink" title="如何打破双亲委派"></a>如何打破双亲委派</h5><p>重写<code>loadClass()</code>方法</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="使用TCP和UDP的协议分别有哪些"><a href="#使用TCP和UDP的协议分别有哪些" class="headerlink" title="使用TCP和UDP的协议分别有哪些"></a>使用TCP和UDP的协议分别有哪些</h4><ul><li>运行于TCP之上的协议<ul><li>HTTP&#x2F;HTTPS</li><li>FTP</li><li>SMTP</li><li>POP3&#x2F;IMAP</li><li>Telnet</li><li>SSH</li></ul></li><li>运行于UDP之上的协议<ul><li>DHCP</li><li>DNS</li></ul></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="输入URL到页面展示的过程"><a href="#输入URL到页面展示的过程" class="headerlink" title="输入URL到页面展示的过程"></a>输入URL到页面展示的过程</h4><ul><li>DNS解析（浏览器缓存 -&gt; 路由器缓存 -&gt; DNS缓存），获取域名对应IP</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>断开连接</li></ul><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul><li>1类：信息性状态码</li><li>2类：成功状态码</li><li>3类：重定向状态码</li><li>4类：客户端错误状态码</li><li>5类：服务端错误状态码</li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul><li>端口：HTTP默认是80，HTTPS默认是443</li><li>安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>常见排序算法可分为比较类和非比较类</p><ul><li>比较类排序算法<ul><li>冒泡排序：稳定、原地、最佳$O(n)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>快速排序：不稳定、原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(nlogn)$</li><li>插入排序：稳定、原地、最佳$O(n)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>希尔排序：稳定、原地、最佳$O(nlogn)$，最差$O(n^2)$，平均$O(nlogn)$、空间$O(1)$</li><li>选择排序：不稳定、原地、最佳$O(n^2)$，最差$O(n^2)$，平均$O(n^2)$、空间$O(1)$</li><li>堆排序：不稳定、原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(1)$</li><li>归并排序：稳定、非原地、最佳$O(nlogn)$，最差$O(nlogn)$，平均$O(nlogn)$、空间$O(n)$</li></ul></li><li>非比较类排序算法<ul><li>基数排序：稳定、非原地、最佳$O(n\times k)$，最差$O(n\times k)$，平均$O(n\times k)$、空间$O(n+k)$</li><li>桶排序：稳定、非原地、最佳$O(n+k)$，最差$O(n^2)$，平均$O(n+k)$、空间$O(k)$</li><li>计数排序：稳定、非原地、最佳$O(n+k)$，最差$O(n+k)$，平均$O(n+k)$、空间$O(k)$</li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="事务的酸性ACID"><a href="#事务的酸性ACID" class="headerlink" title="事务的酸性ACID"></a>事务的酸性ACID</h4><ul><li>原子性：事务是最小的执行单位</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：一个用户的事务不被其他事务干扰</li><li>持久性：事务提交后，其对数据库的改变是持久的</li></ul><h4 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h4><ul><li>丢失修改：在一个事务读取一个数据时，另一个事务也访问了该数据，在第一个事务修改这个数据后，第二个事务也修改了这个数据，导致第一个事务所做的修改结果丢失</li><li>脏读：一个事务修改了一个数据，在其尚未提交之前，另一个事务读取了修改后的数据，此时第一个事务突然回滚，导致第二个事务读取了脏数据</li><li>不可重复读：在一个事务内多次读数据，但数据被另一个事务所修改，导致两次读取的数据不一致</li><li>幻读：发生在一个事务读取了几行数据，接着另一个事务插入了一些数据时。然后，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li></ul><h4 id="并发事务的控制方式"><a href="#并发事务的控制方式" class="headerlink" title="并发事务的控制方式"></a>并发事务的控制方式</h4><p>锁（悲观控制）和MVCC（乐观控制）</p><ul><li>锁可分为读写锁（可以读读并行，无法读写&#x2F;写写并行）<ul><li>共享锁（S锁）：读锁，事务在读取记录时获取共享锁，允许多个事务同时获取</li><li>排他锁（X锁）：写锁，事务在修改记录时获得排他锁，不允许多个事务同时获得；若一个记录已经被加了排他锁，其他事务不能再对该记录加任何锁</li><li>根据粒度可分为表级锁和行级锁<ul><li>表级锁是针对非索引字段的锁，加锁快，不会出现死锁，但触发锁冲突概率高，高并发场景效率较低</li><li>行级锁是针对索引字段的锁，开销大加锁慢，会出现死锁，但并发度高</li></ul></li></ul></li><li>MVCC对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本，实现手段主要是隐藏字段、read view和undo log<ul><li>undo log用来记录某行数据的多个版本的数据</li><li>read view和隐藏字段用来判断当前版本数据的可见性</li></ul></li></ul><h4 id="四个隔离级别"><a href="#四个隔离级别" class="headerlink" title="四个隔离级别"></a>四个隔离级别</h4><p>从低到高分别为：</p><ul><li>读取未提交 Read Uncommitted（脏读、不可重复读、幻读）</li><li>读取已提交 Read Committed（不可重复读、幻读）</li><li>可重复读 Repeatable Read（幻读）</li><li>可串行化 Serializable</li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><ul><li>MyISAM只支持表级别的锁粒度，而InnoDB可支持行级别的锁粒度</li><li>MyISAM不支持事务，InnoDB支持事务，实现了SQL的四个隔离级别</li><li>MyISAM不支持外键，InnoDB支持</li><li>MyISAM不支持MVCC，InnoDB支持</li><li>虽然两者均用B+树作为索引结构，但实现方式不同；InnoDB中，其数据文件本身就是索引文件。而MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录</li><li>MyISAM不支持数据库异常崩溃后的安全恢复，InnoDB支持</li><li>InnoDB性能更好</li></ul><h4 id="MySQL的隔离级别是如何实现的，默认隔离级别是什么"><a href="#MySQL的隔离级别是如何实现的，默认隔离级别是什么" class="headerlink" title="MySQL的隔离级别是如何实现的，默认隔离级别是什么"></a>MySQL的隔离级别是如何实现的，默认隔离级别是什么</h4><p>可串行化是通过锁来实现的，RR和RC是通过MVCC来实现的；默认隔离级别是RR</p><h4 id="InnoDB有哪几类行锁"><a href="#InnoDB有哪几类行锁" class="headerlink" title="InnoDB有哪几类行锁"></a>InnoDB有哪几类行锁</h4><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围</strong></p><h4 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h4><p>意向锁是一种表级锁，可以用来快速判断是否可对某个表使用表锁。意向锁之间是互相兼容的 </p><ul><li>意向共享锁：事务有意向表中的某些记录加共享锁，则必须先获得该表的IS锁</li><li>意向排他锁：事务有意向表中的某些记录加排他锁，则必须先获得该表的IX锁</li></ul><h4 id="快照读（一致性非锁定读）和当前读（一致性锁定读）的区别"><a href="#快照读（一致性非锁定读）和当前读（一致性锁定读）的区别" class="headerlink" title="快照读（一致性非锁定读）和当前读（一致性锁定读）的区别"></a>快照读（一致性非锁定读）和当前读（一致性锁定读）的区别</h4><p><strong>快照读</strong>的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景</p><p><strong>当前读</strong> 就是给行记录加 X 锁或 S 锁</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h5><p><strong>Hash表</strong></p><p>Hash表的优势在于O(1)的取值，但存在哈希冲突的问题，一般用拉链法解决（相同哈希结果的数据连在同一个链表中，后用红黑树代替链表）；作为索引不具备范围查找的功能，每次IO只能取一个值</p><p><strong>B树 &amp; B+树</strong></p><ul><li><p>B 树的所有节点既存放key也存放data，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</p></li></ul><h5 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h5><p>聚簇索引是索引结构和数据一起存放的索引，例如InnoDB的主键索引</p><ul><li>优点<ul><li>查询速度快：由于B+树本身就是平衡的，且叶子节点也都是有序的，定位到索引的同时，也就定位到了数据，相比于非聚簇，少了一次读取数据的IO操作</li><li>利于排序查找和范围查找</li></ul></li><li>缺点<ul><li>依赖于数据的有序性</li><li>更新代价大</li></ul></li></ul><p>非聚簇索引是索引结构和数据分开存放的索引，MyISAM使用的就是非聚簇索引；非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</p><ul><li>优点<ul><li>更新代价比聚簇小，因为叶子节点不存放数据</li></ul></li><li>缺点<ul><li>依赖于数据的有序性</li><li>可能需要回表：即根据查到的主键，再进行查询</li></ul></li></ul><h5 id="覆盖索引与联合索引"><a href="#覆盖索引与联合索引" class="headerlink" title="覆盖索引与联合索引"></a>覆盖索引与联合索引</h5><p>覆盖索引：一个索引包含所有需要查询的字段的值，则为覆盖索引；这种情况是不需要回表查询的</p><p>联合索引：使用表中的多个字段创建索引</p><h5 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h5><p>在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **<code>&gt;</code><strong>、</strong><code>&lt;</code>**）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><h5 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h5><h6 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h6><p>一种物理日志，InnoDB独有的功能，使MySQL具备了崩溃恢复的能力</p><p>MySQL中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里（刷盘时机由策略决定）</p><h6 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h6><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的；采用的是环形数组形式，从头开始写，写到末尾又回到头循环写</p><h5 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h5><p>binlog是逻辑日志，属于MySQL Server层，保证数据库的数据同步和一致性，记录所有涉及更新数据的逻辑操作，并且是顺序写</p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>在执行更新语句时，由于redo log可以在事务过程中写入，而binlog只能在提交事务时写入，因此可能会产生问题：</p><p>假设在redo log写完，binlog写入期间发生了异常，那么当MySQL重启后，redo log恢复出来的是修改后的新数据，而binlog由于没有记录到这次更新操作，因此会导致数据不一致的问题；为了解决这一问题，InnoDB采用了两阶段提交的方案</p><p>将redo log的写入拆分为两个步骤：<strong>prepare</strong>和<strong>commit</strong>，其中prepare阶段在事务执行过程中写入，commit阶段放在binlog写入之后完成，这样即使在binlog写入过程中发生异常，MySQL重启后只需检查redo log是否还处于prepare阶段，若redo log还处于prepare阶段，则将该事务回滚，以此保持数据的一致性</p><h5 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log 回滚日志"></a>undo log 回滚日志</h5><p>在 MySQL 中，恢复机制是通过undo log实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用undo log中的信息将数据回滚到修改之前的样子即可；并且，undo log会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询undo log来回滚之前未完成的事务</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><p>Redis中的key均为String类型，value包含五种基础数据类型，分别是：<strong>String、List、Set、Hash、Zset</strong></p><p><strong>String value</strong></p><p>String可以包含任何数据，例如数字、字符串、图片或者序列化对象等。</p><p><strong>应用场景：</strong>利用String value来做常用数据的缓存，redis做缓存层，mysql做持久化层，这样可以降低mysql的读写压力。</p><p><strong>List value</strong></p><p>Redis中的List是一种链表（以双端链表的形式来实现），其可以在队头队尾同时进行数据的压入弹出操作。</p><p><strong>应用场景</strong>：消息队列，例如微博的TimeLine</p><p><strong>Set value</strong></p><p>Redis中的Set是一种保存String的无序集合，其中的String变量无重复值。通过哈希表来实现，增删查的效率均为O(1)。</p><p><strong>应用场景：</strong>网站的点赞信息、网页元素的标签等。</p><p><strong>Hash value</strong></p><p>Redis中的Hash是一种k-v映射结构，其适用于存储对象。</p><p><strong>应用场景：</strong>是比String更加直观的一种存储方式。</p><p><strong>Zset value</strong></p><p>Redis中的Zset是一种有序集合，其和set一样不允许存在重复成员，不同的是Zset中每个成员会拥有一个分数，所有成员按照该分数来进行排序，不同成员的分数可以重复。</p><p>有序集合是通过两种数据结构实现：</p><ol><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的<strong>双向链表</strong>。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关；一般在：<strong>元素数量少于128和每个元素的长度小于64字节</strong>的时候才会采用压缩列表来实现Zset。</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li></ol><p><strong>应用场景：</strong>网站数据的排行榜等。</p><h5 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h5><p>Redis除了上述五种基础数据类型外，还包括三种特殊数据类型，分别是<strong>HyperLogLog基数统计、Bitmap位图、Geospatial地理位置</strong>。</p><p><strong>HyperLogLog基数统计</strong></p><p>这个结构可以非常省内存的去统计各种基数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。但这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值</p><p><strong>Bitmap位图</strong></p><p>操作二进制位来进行相关数据的记录，仅有0和1两个状态。比如：统计用户信息中的活跃与不活跃，登录与未登录，打卡与不打卡</p><p><strong>Geospatial地理位置</strong></p><p>可以推算地理位置的信息: 两地之间的距离, 方圆几里的人，获取成员的经纬度等。底层实现原理是Zset。</p><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Redis 5.0中增加了一个数据类型Stream，其借鉴了Kafka的设计，是一个支持多播的可持久化消息队列（Message Queue，MQ）</p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h5 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h5><p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。触发快照持久化有手动和自动两种方式。</p><p><strong>实际应用问题</strong></p><ul><li><p>一般Redis占据的内存较大，做快照的时间也可能较长，在快照时间内Redis很可能收到写数据的请求，那么在这种情况下如何保证Redis中的数据一致性？</p><p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p></li><li><p>在快照过程中，如果发生了服务的崩溃如何处理？</p><p>如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。</p></li><li><p>做快照的时间间隔越短越好？</p><p><strong>如果频繁地执行全量快照，会带来两方面的开销</strong>：</p><ul><li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁<strong>阻塞主线程</strong>了。</li></ul><p>因此可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。但这种方法需要使用另外的空间去记录哪些数据被修改了，所以一般采用RDB和AOF混合的持久化方式。</p></li></ul><h5 id="AOF写后日志"><a href="#AOF写后日志" class="headerlink" title="AOF写后日志"></a>AOF写后日志</h5><p><strong>实际应用问题</strong></p><ul><li><p>如何解决AOF日志不断增大的膨胀问题？</p><p>Redis会创建一个新的AOF文件，新旧AOF文件保存的数据没有区别，但新的AOF日志相较旧的AOF日志去除了冗余的中间命令。</p></li><li><p>AOF日志在重写的过程中会阻塞吗？</p><p>AOF日志的重写是通过fork创造的后台线程来进行的，因此阻塞只会在fork后台线程时发生。</p></li><li><p>重写AOF日志时，如果发生写操作如何应对？</p><p>在发生写操作时，Redis会将相应的命令存入AOF缓冲区，当负责重写的后台线程完成既定工作时，其会通知主线程，此时主线程则会将缓冲区内保存的写命令追加到重写日志中。</p></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>为了避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。Redis提供了主从复制的机制来实现数据的高可用性。</p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>主从库之间采用的是<strong>读写分离</strong>的方式。</p><ul><li><p>读操作：主库、从库都可以接收；</p></li><li><p>写操作：首先到主库执行，然后，主库将写操作同步给从库。</p></li></ul><h4 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h4><p>哨兵实现了如下所述的四个主要功能：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h5 id="哨兵集群的组建"><a href="#哨兵集群的组建" class="headerlink" title="哨兵集群的组建"></a>哨兵集群的组建</h5><p>哨兵通过在主库的频道上发布自己的IP和端口信息，其他哨兵通过订阅该频道从而获悉该哨兵的IP和端口，并建立网络连接。</p><h5 id="哨兵监控Redis库"><a href="#哨兵监控Redis库" class="headerlink" title="哨兵监控Redis库"></a>哨兵监控Redis库</h5><p>哨兵向主库发送INFO命令，主库则会将从库列表返回给该哨兵，那么该哨兵就可以和每个从库建立连接并进行监控。</p><h5 id="哨兵判断主库下线"><a href="#哨兵判断主库下线" class="headerlink" title="哨兵判断主库下线"></a>哨兵判断主库下线</h5><p>首先，哨兵可对主库做出“主观下线”的判断，并向其他哨兵发送信号；其他哨兵也会相应做出“主观下线”的判断，若所有的“主观下线”判断中“是”的数量不少于配置中的指标量，则可以认为主库已经达到“客观下线”。</p><h5 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h5><p>当主库“客观下线”后，需要有一个领头的哨兵节点来执行后续主从切换的动作。选举条件为：1. 拿到半数以上的赞成票；2. 得票数同时还需要不少于配置文件中的指标量（即主库达到“客观下线”的那个指标量）。</p><h5 id="新主库的选出"><a href="#新主库的选出" class="headerlink" title="新主库的选出"></a>新主库的选出</h5><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><h5 id="故障的转移"><a href="#故障的转移" class="headerlink" title="故障的转移"></a>故障的转移</h5><p>新主库选出后，最后哨兵leader要进行故障的转移，具体步骤如下：</p><ul><li><p>将某个slave节点脱离原从节点，升级成主节点；</p></li><li><p>将其他从节点指向新的主节点</p></li><li><p>通知客户端主节点已更换</p></li><li><p>将原主节点变成从节点，指向新的主节点</p></li></ul><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><ul><li>缓存穿透<ul><li><strong>问题来源</strong>：缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</li><li>解决方案<ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>布隆过滤器。bloomfilter就类似于一个HashSet，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小</li></ul></li></ul></li><li>缓存击穿<ul><li><strong>问题来源</strong>：缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</li><li><strong>解决方案</strong><ul><li>设置热点数据永远不过期。</li><li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li><li>加互斥锁</li></ul></li></ul></li><li>缓存雪崩<ul><li><strong>问题来源</strong>：缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机</strong>。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li><li><strong>解决方案</strong><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul></li></ul></li><li>缓存污染<ul><li><strong>问题来源</strong>：缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</li><li><strong>解决方案</strong><ul><li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li></ul></li></ul></li></ul><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>Consistency一致性：所有节点访问同一份最新的数据副本</li><li>Availability可用性：非故障的节点在合理的时间内返回合理的响应</li><li>Partition Tolerance分区容错性：分布式系统出现网络分区时，仍能够对外提供服务</li></ul><p>如果分布式系统发生了“分区”（某些节点由于故障不连通了，网络被分成了几块区域），则理论上只能支持CP或者AP架构，即P一定是要满足的。Nacos不仅支持AP也支持CP</p><h3 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h3><p>当分库之后，数据分布在不同服务器的DB上，DB的自增主键已经无法满足要求，因此需要生成分布式ID。</p><h4 id="分布式ID解决方案"><a href="#分布式ID解决方案" class="headerlink" title="分布式ID解决方案"></a>分布式ID解决方案</h4><ul><li>数据库<ul><li>关系型数据库自增主键</li><li>号段模式相比于自增主键，对于数据库的访问次数更少，DB压力更小</li><li>非关系型数据库使用Redis</li></ul></li><li>算法<ul><li>UUID（32个16进制）</li><li>雪花算法（64bit二进制数字）<ul><li>第0位符号位，1-41位时间戳，42-52位机房ID+机器ID，53-64位序列号</li></ul></li></ul></li><li>开源框架</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h4><ul><li>加锁<ul><li>用SETNX命令判断对应的锁是否存在，若不存在则加锁失败</li></ul></li><li>解锁<ul><li>为了保证释放锁的原子性，Redis会通过Lua脚本首先判断误删其他锁，没有问题则执行DEL命令释放锁</li></ul></li></ul><p>但存在这样的问题：<strong>释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问</strong></p><p>因此需要对锁设置一个过期时间，但又存在资源操作时间超过了过期时间导致服务中断的情况</p><h5 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h5><p>Redisson提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>一台主数据库负责写，其他的从数据库负责读；主库和从库之间会进行数据同步，以保证从库中数据的准确性</p><h4 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h4><p>写完主库后，主库的新数据同步到从库需要一定时间，这段时间内会产生主从数据库的数据不一致问题</p><ul><li>强制将读请求路由到主库</li><li>延迟读取</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>代理方式<ul><li>在应用和数据中间加一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中</li></ul></li><li>组件方式<ul><li>引入第三方组件来帮助处理读写请求（sharding-jdbc）</li></ul></li></ul><h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><p>根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中，具体步骤如下</p><ul><li><p>主库将数据库中数据的变化写入到 binlog</p></li><li><p>从库连接主库</p></li><li><p>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</p></li><li><p>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</p></li><li><p>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中</p></li><li><p>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）</p></li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>为了解决MySQL的存储压力，可以使用分库分表的方案</p><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库；<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分</p><h4 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h4><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题</p><ul><li>哈希分片，求指定key的哈希值，根据哈希值确定分配的表，适合随机读写场景，不适合大量范围查询场景</li><li>范围分片，分成连续的若干段数据</li><li>融合分片</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列的应用场景：通过异步处理提高系统性能、削峰限流、降低耦合度</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><strong>如何保证消息不丢失</strong></p><ul><li>生产者丢失消息<ul><li>当send后通过回调函数的形式返回发送消息成功与否，同时设置合理的retry间隔时间</li></ul></li><li>消费者丢失消息<ul><li>真正消费完当前消息后手动提交offset的更新，但如果提交offset之前自己挂了，则会产生重复消费的问题</li></ul></li></ul><p><strong>如何保证消息不被重复消费</strong></p><ul><li>消费后做幂等校验</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
